// ==UserScript==
// @name         YApi to TypeScript via Cursor
// @namespace    https://github.com/beilo/tampermonkey-yapi-to-typescript
// @version      0.2.1
// @author       YApi Helper
// @description  将 YApi 接口转换为 TypeScript 代码（通过 Cursor Agent）
// @license      MIT
// @icon         data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
// @supportURL   https://github.com/beilo/tampermonkey-yapi-to-typescript/issues
// @match        *://interface.codemao.cn/*
// @require      https://cdn.jsdelivr.net/npm/react@18.3.1/umd/react.production.min.js
// @require      https://cdn.jsdelivr.net/npm/react-dom@18.3.1/umd/react-dom.production.min.js
// @grant        GM_addStyle
// @grant        GM_getValue
// @grant        GM_notification
// @grant        GM_setValue
// ==/UserScript==

(o=>{if(typeof GM_addStyle=="function"){GM_addStyle(o);return}const e=document.createElement("style");e.textContent=o,document.head.append(e)})(" .yapi-helper-btn{position:fixed;top:20px;right:20px;z-index:9999;padding:10px 20px;background-color:#4285f4;color:#fff;border:none;border-radius:4px;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;box-shadow:0 2px 5px #0003;transition:all .3s ease}.yapi-helper-btn:hover{background-color:#3367d6;box-shadow:0 3px 8px #0000004d}.local-ts-btn{position:fixed;top:20px;right:200px;z-index:9999;padding:10px 20px;background-color:#00a86b;color:#fff;border:none;border-radius:4px;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;box-shadow:0 2px 5px #0003;transition:all .3s ease}.local-ts-btn:hover{background-color:#008f5d;box-shadow:0 3px 8px #0000004d}.json-to-ts-btn{position:fixed;top:20px;right:200px;z-index:9999;padding:10px 20px;background-color:#f44336;color:#fff;border:none;border-radius:4px;cursor:pointer;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;box-shadow:0 2px 5px #0003;transition:all .3s ease}.json-to-ts-btn:hover{background-color:#d32f2f;box-shadow:0 3px 8px #0000004d}.yapi-helper-modal{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background-color:#fff;padding:20px;border-radius:8px;box-shadow:0 4px 20px #00000026;max-width:800px;width:90%;max-height:80vh;overflow:auto;z-index:10000;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}.yapi-helper-notification{position:fixed;top:70px;right:20px;background-color:#4caf50;color:#fff;padding:10px 20px;border-radius:4px;z-index:10001;opacity:0;transition:opacity .3s ease;box-shadow:0 3px 10px #0003}.yapi-helper-notification.show{opacity:1}.yapi-helper-button-container{margin-top:15px;display:flex;justify-content:space-between;gap:10px}.yapi-helper-button{padding:8px 16px;border:none;border-radius:4px;cursor:pointer;transition:all .2s ease}.yapi-helper-button.primary{background-color:#4285f4;color:#fff}.yapi-helper-button.secondary{background-color:#f0f0f0}.yapi-helper-button:hover{filter:brightness(.95)}.yapi-helper-tabs{display:flex;margin-bottom:15px;border-bottom:1px solid #e0e0e0}.yapi-helper-tab{padding:8px 16px;cursor:pointer;border-bottom:2px solid transparent}.yapi-helper-tab.active{border-bottom:2px solid #4285f4;color:#4285f4}.yapi-helper-section{margin-bottom:15px}.yapi-helper-section-title{font-weight:700;margin-bottom:5px}.yapi-helper-checkbox-group{display:flex;flex-wrap:wrap;gap:10px;margin-bottom:15px}.yapi-helper-checkbox-item{display:flex;align-items:center;gap:5px}.yapi-helper-instruction-content{max-height:400px;overflow-y:auto}.yapi-helper-types-container{display:flex;flex-direction:column;gap:20px;margin-bottom:20px}.yapi-helper-type-section{border:1px solid #e0e0e0;border-radius:4px;overflow:hidden}.yapi-helper-type-header{display:flex;justify-content:space-between;align-items:center;padding:10px 16px;background-color:#f6f8fa;border-bottom:1px solid #e0e0e0}.yapi-helper-type-header h4{margin:0;font-size:16px;font-weight:500}.yapi-helper-button.small-btn{padding:4px 12px;font-size:13px}@media (min-width: 768px){.yapi-helper-types-container{max-height:70vh;overflow-y:auto}.yapi-helper-instruction-content pre{max-height:250px!important}} ");

(function (require$$0__default, require$$0$1) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const require$$0__default__namespace = /*#__PURE__*/_interopNamespaceDefault(require$$0__default);

  var __defProp = Object.defineProperty;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var require_main_001 = __commonJS({
    "main-BaNeF5jr.js"(exports, module) {
      function getDefaultExportFromCjs(x2) {
        return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
      }
      var jsxRuntime = { exports: {} };
      var reactJsxRuntime_production_min = {};
      /**
       * @license React
       * react-jsx-runtime.production.min.js
       *
       * Copyright (c) Facebook, Inc. and its affiliates.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */
      var hasRequiredReactJsxRuntime_production_min;
      function requireReactJsxRuntime_production_min() {
        if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
        hasRequiredReactJsxRuntime_production_min = 1;
        var f2 = require$$0__default, k2 = Symbol.for("react.element"), l2 = Symbol.for("react.fragment"), m2 = Object.prototype.hasOwnProperty, n2 = f2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p2 = { key: true, ref: true, __self: true, __source: true };
        function q2(c2, a2, g2) {
          var b2, d2 = {}, e2 = null, h2 = null;
          void 0 !== g2 && (e2 = "" + g2);
          void 0 !== a2.key && (e2 = "" + a2.key);
          void 0 !== a2.ref && (h2 = a2.ref);
          for (b2 in a2) m2.call(a2, b2) && !p2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
          if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
          return { $$typeof: k2, type: c2, key: e2, ref: h2, props: d2, _owner: n2.current };
        }
        reactJsxRuntime_production_min.Fragment = l2;
        reactJsxRuntime_production_min.jsx = q2;
        reactJsxRuntime_production_min.jsxs = q2;
        return reactJsxRuntime_production_min;
      }
      var hasRequiredJsxRuntime;
      function requireJsxRuntime() {
        if (hasRequiredJsxRuntime) return jsxRuntime.exports;
        hasRequiredJsxRuntime = 1;
        {
          jsxRuntime.exports = requireReactJsxRuntime_production_min();
        }
        return jsxRuntime.exports;
      }
      var jsxRuntimeExports = requireJsxRuntime();
      var client = {};
      var hasRequiredClient;
      function requireClient() {
        if (hasRequiredClient) return client;
        hasRequiredClient = 1;
        var m2 = require$$0$1;
        {
          client.createRoot = m2.createRoot;
          client.hydrateRoot = m2.hydrateRoot;
        }
        return client;
      }
      var clientExports = requireClient();
      const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
      function n$2(n2, t2) {
        n2.includes(t2) || n2.push(t2);
      }
      function t$1(n2, t2) {
        const r2 = n2.indexOf(t2);
        r2 >= 0 && n2.splice(r2, 1);
      }
      function r$2(n2) {
        return Array.from(new Set(n2));
      }
      function e$1(n2, t2) {
        let r2 = false;
        for (const e2 of n2) if (t2.includes(e2)) {
          r2 = true;
          break;
        }
        return r2;
      }
      function o$3(n2, t2) {
        let r2 = "";
        const e2 = n2.length;
        for (let o2 = 0; o2 < e2; o2++) {
          const e3 = n2[o2];
          if (t2.startsWith(e3)) {
            r2 = e3;
            break;
          }
        }
        return r2;
      }
      function i$2(n2, t2, r2) {
        if (!n2) return [];
        const e2 = n2(t2, r2);
        return Array.isArray(e2) ? e2 : [e2];
      }
      var u$3 = function() {
        if ("undefined" != typeof globalThis) return globalThis;
        if ("undefined" != typeof global) return global;
        if ("undefined" != typeof window) return window;
        if (void 0 !== this) return this;
        throw new Error("no globalThis");
      }();
      function f$2(...n2) {
      }
      var s$2 = f$2;
      function l$2(...n2) {
        return n2;
      }
      function a$3(...n2) {
        return [];
      }
      var b$1 = Object.prototype.toString;
      function y$1() {
        return !(!u$3.process || !u$3.global || u$3.document);
      }
      function d$2(n2) {
        return "[object Map]" === b$1.call(n2);
      }
      function h$1(n2) {
        return n2 === Number.MAX_SAFE_INTEGER;
      }
      function g$1() {
        return !("previewFrame" !== u$3.name && !u$3.BrowserFS);
      }
      function E$2(n2) {
        return n2 && "object" == typeof n2 && !Array.isArray(n2);
      }
      function v$1(n2) {
        return n2 && "object" == typeof n2;
      }
      function w$2(n2) {
        return "function" == typeof n2;
      }
      function j$1(n2) {
        return "symbol" == typeof n2;
      }
      function A$2(n2) {
        if (!n2) return false;
        const t2 = typeof n2;
        return ("object" === t2 || "function" === t2) && w$2(n2.then);
      }
      function O$2() {
        return "function" == typeof Proxy;
      }
      function S$2(n2, t2) {
        const { throwErr: r2 = false, prefixLabel: e2 = "", suffixLabel: o2 = ", see details in console.", logErr: i2 = true, alertErr: c2 } = t2 || {};
        let f2 = n2, s2 = false;
        n2 instanceof Error && (s2 = true, f2 = n2.message);
        if (("boolean" == typeof c2 ? c2 : g$1()) && u$3.alert && n2 && u$3.alert(`${e2}${f2}${o2}`), i2 && console.error(n2), r2) throw s2 ? n2 : new Error(String(n2));
      }
      function x$1(n2, t2 = 0) {
        0 === t2 ? (console.error(n2), g$1() && console.trace(n2)) : 1 === t2 ? console.error(n2) : console.warn(n2);
      }
      function $$2(n2) {
        return h$1(n2) ? 1 : n2 + 1;
      }
      var F$1 = !!Reflect, T$1 = Object.prototype.hasOwnProperty;
      function _$1(n2, t2) {
        return F$1 ? Reflect.has(n2, t2) : T$1.call(n2, t2);
      }
      function k$1(n2, t2, r2) {
        let e2 = n2[t2];
        return e2 || (e2 = n2[t2] = r2), e2;
      }
      function R$1(n2, t2, r2) {
        let e2 = n2.get(t2);
        return e2 || (n2.set(t2, r2), e2 = r2), e2;
      }
      function D$1(n2, t2) {
        let r2 = "";
        for (const e2 in n2) if (t2.startsWith(e2)) {
          r2 = e2;
          break;
        }
        return r2;
      }
      function L$1(n2, t2) {
        const r2 = n2.get(t2);
        if (void 0 !== r2) return r2;
        const e2 = n2.get(Number(t2) || t2);
        return void 0 !== e2 ? e2 : void 0;
      }
      function M$1(n2, t2) {
        let r2, e2 = n2;
        return t2.forEach((n3) => {
          r2 = d$2(e2) ? L$1(e2, n3) : e2[n3], e2 = r2;
        }), r2;
      }
      function P$1(n2, t2, r2) {
        let e2 = n2;
        const o2 = t2.length - 1;
        t2.forEach((n3, t3) => {
          const i2 = d$2(e2);
          if (t3 === o2) return void (i2 ? e2.set(n3, r2) : e2[n3] = r2);
          const u2 = i2 ? L$1(e2, n3) : e2[n3];
          e2 = u2;
        });
      }
      function V$1() {
        return x$1("changing shared state is invalid"), true;
      }
      function W$1(n2) {
        return n2;
      }
      function B$1(n2, t2) {
        return `${t2}/${n2}`;
      }
      function G$1(n2) {
        return n2 && O$2();
      }
      var t = Object.defineProperty, e = {};
      ((e2, n2) => {
        for (var r2 in n2) t(e2, r2, { get: n2[r2], enumerable: true });
      })(e, { useEffect: () => f$1, useForceUpdate: () => d$1, useIsStrict: () => l$1, useLayoutEffect: () => i$1, useObject: () => O$1, useObjectLogic: () => E$1, useStable: () => w$1 });
      var n$1 = /* @__PURE__ */ new Map(), r$1 = false;
      try {
        r$1 = false;
      } catch (t2) {
        console.log("ignored err:", t2);
      }
      function u$2() {
        if (!r$1) return "";
        let t2 = "";
        try {
          throw new Error("hook key");
        } catch (e2) {
          t2 = function(t3) {
            const e3 = t3.stack.split("\n");
            let n2 = "";
            for (const t4 of e3) {
              if (t4.includes("renderWithHooks")) break;
              n2 += t4;
            }
            return n2;
          }(e2), function(t3) {
            n$1.get(t3) ? n$1.set(t3, 2) : n$1.set(t3, 1);
          }(t2);
        }
        return t2;
      }
      globalThis.__LOG_HP__ && console.log("isDev", r$1);
      var o$2 = { count: 0 }, c$2 = /* @__PURE__ */ new Map();
      function s$1(t2, e2, n2, r2) {
        const u2 = () => {
          if (r2) return n2(e2), () => {
            c$2.delete(t2);
          };
          const u3 = n2();
          return () => {
            c$2.delete(t2), u3 && u3();
          };
        };
        if (!e2) return u2();
        !function(t3) {
          const e3 = c$2.get(t3);
          e3 ? e3.count += 1 : c$2.set(t3, { count: 1 });
        }(t2);
        const s2 = function(t3) {
          return c$2.get(t3) || o$2;
        }(t2);
        return s2.count > 1 ? u2() : void 0;
      }
      function a$2(t2, e2, o2) {
        const { useLayoutEffect: c2, useEffect: a2 } = t2.react, { isLayout: i2, deps: f2, passIsStrict: d2 } = o2, l2 = u$2();
        (i2 ? c2 : a2)(() => {
          const t3 = function(t4) {
            return !!r$1 && 2 === n$1.get(t4);
          }(l2);
          return s$1(l2, t3, e2, d2);
        }, f2);
      }
      function i$1(t2, e2, n2) {
        a$2(t2, e2, { isLayout: true, deps: n2 });
      }
      function f$1(t2, e2, n2) {
        a$2(t2, e2, { deps: n2 });
      }
      function d$1(t2) {
        const [, e2] = t2.react.useState({});
        return () => e2({});
      }
      function l$1(t2, e2) {
        a$2(t2, e2, { deps: [], isLayout: true, passIsStrict: true });
      }
      function m$1(t2) {
        const { data: e2 } = t2.current;
        w$2(e2) ? t2.current.wrap = (...e3) => t2.current.data(...e3) : E$2(e2) ? t2.current.wrap = function(t3, e3) {
          if (!O$2()) {
            const n3 = {};
            return Object.keys(t3).forEach((r2) => {
              const u2 = t3[r2];
              w$2(u2) ? n3[r2] = (...t4) => e3.current.data[r2](...t4) : Object.defineProperty(n3, r2, { get: () => e3.current.data[r2], set(t4) {
                e3.current.data[r2] = t4;
              } });
            }), n3;
          }
          const n2 = {};
          return new Proxy(t3, { get(t4, r2) {
            const u2 = t4[r2];
            return w$2(u2) ? k$1(n2, r2, (...t5) => e3.current.data[r2](...t5)) : u2;
          } });
        }(e2, t2) : t2.current.wrap = e2;
      }
      function w$1(t2, e2) {
        const { useRef: n2, useMemo: r2 } = t2.react, u2 = n2({ data: e2, wrap: {}, inited: false });
        return u2.current.data = r2(() => e2, [e2]), u2.current.inited || (m$1(u2), u2.current.inited = true), u2.current.wrap;
      }
      function E$1(t2, e2, n2, r2) {
        const { useState: u2, useRef: o2, useEffect: c2 } = t2.react, [s2] = u2(e2), a2 = d$1(t2), i2 = o2({ state: null, unmount: false, shouldCopy: true }), f2 = w$1(t2, { setState(t3) {
          const e3 = i2.current;
          if (e3.unmount) return;
          let u3;
          const { state: o3 } = e3;
          n2 ? (u3 = n2(t3, e3.state || s2), r2 && u3 ? (e3.state = u3, e3.shouldCopy = false) : e3.shouldCopy = true) : (u3 = (w$2(t3) ? t3(o3) : t3) || {}, e3.shouldCopy = true), Object.assign(s2, u3 || {}), a2();
        }, getLatestState() {
          const t3 = i2.current;
          return t3.shouldCopy && (t3.state = { ...s2 }, t3.shouldCopy = false), t3.state;
        } });
        return c2(() => {
          const t3 = i2.current;
          return t3.unmount = false, () => {
            t3.unmount = true;
          };
        }, [i2]), [s2, f2.setState, f2];
      }
      function O$1(t2, e2) {
        return E$1(t2, e2);
      }
      function S$1(t2) {
        const n2 = {}, r2 = { react: t2 }, u2 = e;
        return Object.keys(e).forEach((t3) => {
          n2[t3] = u2[t3].bind(null, r2);
        }), n2;
      }
      const VER$2 = "3.13.1";
      const META_KEY = Symbol("M");
      const META_VER = Symbol("V");
      const IMMUT_BASE = Symbol("IMMUT_BASE");
      const IS_RAW = Symbol("IS_RAW");
      const MAP$1 = "Map";
      const SET = "Set";
      const ARRAY = "Array";
      const OBJECT = "Object";
      const JS_SYM_KEYS = [Symbol.iterator, Symbol.toStringTag, IS_RAW];
      const CAREFUL_TYPES = { Map: MAP$1, Set: SET, Array: ARRAY };
      const OBJ_DESC = "[object Object]";
      const MAP_DESC = "[object Map]";
      const SET_DESC = "[object Set]";
      const ARR_DESC = "[object Array]";
      const FN_DESC = "[object Function]";
      const desc2dataType = {
        [MAP_DESC]: MAP$1,
        [SET_DESC]: SET,
        [ARR_DESC]: ARRAY,
        [OBJ_DESC]: OBJECT
      };
      const SHOULD_REASSIGN_ARR_METHODS = ["push", "pop", "shift", "splice", "unshift", "reverse", "copyWithin", "delete", "fill"];
      const SHOULD_REASSIGN_MAP_METHODS = ["set", "clear", "delete"];
      const SHOULD_REASSIGN_SET_METHODS = ["add", "clear", "delete"];
      const CHANGE_ARR_ORDER_METHODS = ["splice", "sort", "unshift", "shift"];
      const arrFnKeys = [
        "concat",
        "copyWithin",
        "entries",
        "every",
        "fill",
        "filter",
        "find",
        "findIndex",
        "flat",
        "flatMap",
        "forEach",
        "includes",
        "indexOf",
        "join",
        "keys",
        "lastIndexOf",
        "map",
        "pop",
        "push",
        "reduce",
        "reduceRight",
        "reverse",
        "shift",
        "unshift",
        "slice",
        "some",
        "sort",
        "splice",
        "values",
        "valueOf"
      ];
      const mapFnKeys = ["clear", "delete", "entries", "forEach", "get", "has", "keys", "set", "values"];
      const setFnKeys = ["add", "clear", "delete", "entries", "forEach", "has", "keys", "values"];
      const CAREFUL_FNKEYS = {
        [MAP$1]: mapFnKeys,
        [SET]: setFnKeys,
        [ARRAY]: arrFnKeys
      };
      const CHANGE_FNKEYS = {
        [MAP$1]: ["clear", "set", "delete"],
        [SET]: ["clear", "add", "delete"],
        [ARRAY]: ["pop", "push", "shift", "unshift", "splice", "sort", "copyWithin"]
      };
      const PROXYITEM_FNKEYS = {
        [MAP$1]: ["forEach", "get"],
        [SET]: ["forEach"],
        [ARRAY]: ["forEach", "map"]
      };
      const verWrap = { value: 0, usablePrefix: 1 };
      const conf = {
        autoFreeze: false,
        autoRevoke: true,
        fastModeRange: "array"
      };
      const toString = Object.prototype.toString;
      const canUseReflect = !!Reflect;
      const hasProp = Object.prototype.hasOwnProperty;
      function has(obj, key) {
        if (canUseReflect) {
          return Reflect.has(obj, key);
        }
        return hasProp.call(obj, key);
      }
      function deepDrill(obj, parentObj, key, subObjCb) {
        const list = [];
        const innerDeep = (obj2, parentObj2, key2) => {
          if (isPrimitive(obj2)) {
            return;
          }
          if (list.includes(obj2)) {
            return;
          }
          list.push(obj2);
          subObjCb(obj2, parentObj2, key2);
          if (Array.isArray(obj2)) {
            obj2.forEach((item, idx) => {
              innerDeep(item, obj2, idx);
            });
          }
          if (isMap(obj2)) {
            obj2.forEach((value, key3) => {
              innerDeep(value, obj2, key3);
            });
          }
          if (isObject(obj2)) {
            Object.keys(obj2).forEach((key3) => {
              innerDeep(obj2[key3], obj2, key3);
            });
          }
        };
        innerDeep(obj, parentObj, key);
      }
      function getValStrDesc(val) {
        return toString.call(val);
      }
      function noop(...args) {
        return args;
      }
      function isObject(val) {
        return getValStrDesc(val) === OBJ_DESC;
      }
      function isMap(val) {
        return getValStrDesc(val) === MAP_DESC;
      }
      function isSet(val) {
        return getValStrDesc(val) === SET_DESC;
      }
      function isFn(val) {
        return getValStrDesc(val) === FN_DESC;
      }
      function getDataType$1(dataNode) {
        var strDesc = getValStrDesc(dataNode);
        const dataType = desc2dataType[strDesc];
        return dataType;
      }
      function isPrimitive(val) {
        const desc = getValStrDesc(val);
        return ![OBJ_DESC, ARR_DESC, MAP_DESC, SET_DESC, FN_DESC].includes(desc);
      }
      function isPromiseFn(obj) {
        return obj.constructor.name === "AsyncFunction" || "function" === typeof obj.then;
      }
      function isPromiseResult(result) {
        return typeof Promise !== "undefined" && result instanceof Promise;
      }
      function canBeNum(val) {
        var valType = typeof val;
        if (valType === "number")
          return true;
        if (valType === "string")
          return /^[0-9]*$/.test(val);
        return false;
      }
      const descProto = {
        [ARR_DESC]: Array.prototype,
        [MAP_DESC]: Map.prototype,
        [SET_DESC]: Set.prototype,
        [FN_DESC]: Function.prototype
      };
      function injectMetaProto(rawObj) {
        const desc = getValStrDesc(rawObj);
        const rootProto = descProto[desc] || Object.prototype;
        const pureObj = /* @__PURE__ */ Object.create(null);
        Object.setPrototypeOf(pureObj, rootProto);
        Object.setPrototypeOf(rawObj, pureObj);
        return rawObj;
      }
      const ROOT_CTX = /* @__PURE__ */ new Map();
      function markModified(meta) {
        meta.rootMeta.modified = true;
        const doMark = (meta2) => {
          if (meta2 && !meta2.modified) {
            meta2.modified = true;
            doMark(meta2.parentMeta);
          }
        };
        doMark(meta);
      }
      function attachMeta(dataNode, meta, options) {
        if (options.apiCtx.debug) {
          const { fast } = options;
          if (fast) {
            dataNode[META_KEY] = meta;
          } else {
            injectMetaProto(dataNode);
            dataNode.__proto__[META_KEY] = meta;
          }
        }
        return dataNode;
      }
      function getKeyPath(draftNode, curKey, apiCtx) {
        const pathArr = [curKey];
        const meta = getSafeDraftMeta(draftNode, apiCtx);
        if (meta && meta.level > 0) {
          const { keyPath } = meta;
          return [...keyPath, curKey];
        }
        return pathArr;
      }
      function newMeta(key, baseData, options) {
        const { ver, parentMeta = null, immutBase, compareVer, apiCtx, hasOnOperate } = options;
        const dataType = getDataType$1(baseData);
        let keyPath = [];
        let level = 0;
        let copy = null;
        if (parentMeta) {
          copy = parentMeta.copy;
          level = getNextMetaLevel(copy, apiCtx);
          keyPath = getKeyPath(copy, key, apiCtx);
        }
        const meta = {
          // @ts-ignore add later
          rootMeta: null,
          parentMeta,
          parent: copy,
          selfType: dataType,
          self: baseData,
          // @ts-ignore add later
          copy: null,
          key,
          keyPath,
          level,
          // @ts-ignore add later
          /** @type any */
          proxyVal: null,
          proxyItems: null,
          modified: false,
          scopes: [],
          isImmutBase: immutBase,
          isDel: false,
          isFast: false,
          isArrOrderChanged: false,
          newNodeStats: {},
          newNodeMap: /* @__PURE__ */ new Map(),
          newNodes: [],
          ver,
          compareVer,
          revoke: noop,
          hasOnOperate,
          execOnOperate: noop
        };
        if (level === 0) {
          meta.rootMeta = meta;
        } else {
          meta.rootMeta = parentMeta.rootMeta;
        }
        return meta;
      }
      function isDraft$2(mayDraft) {
        const meta = getDraftProxyMeta(mayDraft);
        if (!meta) {
          return false;
        }
        return !meta.isImmutBase;
      }
      function genMetaVer() {
        if (verWrap.value >= Number.MAX_SAFE_INTEGER) {
          verWrap.value = 1;
          verWrap.usablePrefix += 1;
        } else {
          verWrap.value += 1;
        }
        const { value, usablePrefix } = verWrap;
        const metaVer = `${usablePrefix}_${value}`;
        return metaVer;
      }
      function getNextMetaLevel(mayContainMetaObj, apiCtx) {
        const meta = getDraftMeta(mayContainMetaObj, apiCtx);
        return meta ? meta.level + 1 : 1;
      }
      function getSafeDraftMeta(proxyDraft, apiCtx) {
        return apiCtx.metaMap.get(proxyDraft);
      }
      function getDraftMeta(proxyDraft, apiCtx) {
        let apiCtxVar = apiCtx || getApiCtx(proxyDraft);
        return (apiCtxVar === null || apiCtxVar === void 0 ? void 0 : apiCtxVar.metaMap.get(proxyDraft)) || null;
      }
      function getMetaVer(mayDraftProxy) {
        return mayDraftProxy ? mayDraftProxy[META_VER] || "" : "";
      }
      function getApiCtx(mayDraftProxy) {
        const ver = getMetaVer(mayDraftProxy);
        return ROOT_CTX.get(ver) || null;
      }
      function getDraftProxyMeta(mayDraftProxy) {
        const apiCtx = getApiCtx(mayDraftProxy);
        if (!apiCtx) {
          return null;
        }
        return apiCtx.metaMap.get(mayDraftProxy) || null;
      }
      function isDiff$2(val1, val2) {
        const meta1 = getDraftProxyMeta(val1);
        const meta2 = getDraftProxyMeta(val2);
        if (!meta1 && !meta2) {
          return !Object.is(val1, val2);
        }
        const { self: self1, modified: modified1, compareVer: cv1, ver: ver1, level: level1 } = meta1 || { self: val1, modified: false, compareVer: false, ver: "0", level: 0 };
        const { self: self2, modified: modified2, compareVer: cv2, ver: ver2, level: level2 } = meta2 || { self: val2, modified: false, compareVer: false, ver: "0", level: 0 };
        if (self1 !== self2) {
          return true;
        }
        if ((cv1 || cv2) && (level1 === 0 || level2 === 0) && ver1 !== ver2) {
          return true;
        }
        return modified1 || modified2;
      }
      function shallowCompare$2(prevObj, nextObj, compareLimuProxyRaw = true) {
        const diffFn = compareLimuProxyRaw ? isDiff$2 : Object.is;
        const isObjDiff = (a2, b2) => {
          for (let i2 in a2)
            if (!(i2 in b2))
              return true;
          for (let i2 in b2)
            if (diffFn(a2[i2], b2[i2]))
              return true;
          return false;
        };
        const isEqual = !isObjDiff(prevObj, nextObj);
        return isEqual;
      }
      function tryMakeCopy(val, options) {
        const { parentType, fastModeRange } = options;
        if (Array.isArray(val)) {
          return { copy: val.slice(), fast: false };
        }
        const fast = fastModeRange === "array" && parentType === ARRAY || fastModeRange === "all";
        let copy = val;
        if (val && isObject(val)) {
          copy = Object.assign({}, val);
        }
        if (isMap(val)) {
          copy = new Map(val);
        }
        if (isSet(val)) {
          copy = new Set(val);
        }
        return { copy, fast };
      }
      function makeCopyWithMeta(ori, meta, options) {
        const { apiCtx, immutBase } = options;
        if (immutBase) {
          return { copy: ori, fast: false };
        }
        const { copy, fast } = tryMakeCopy(ori, options);
        attachMeta(copy, meta, { apiCtx, fast });
        return { copy, fast };
      }
      function ressignArrayItem(listMeta, itemMeta, ctx2) {
        const { copy, isArrOrderChanged } = listMeta;
        const { targetNode, key } = ctx2;
        if (isArrOrderChanged) {
          const key2 = copy.findIndex((item) => item === itemMeta.copy);
          if (key2 >= 0) {
            copy[key2] = targetNode;
          }
          return;
        }
        copy[key] = targetNode;
      }
      function isInSameScope(mayDraftProxy, callerScopeVer) {
        if (!isObject(mayDraftProxy)) {
          return true;
        }
        return getMetaVer(mayDraftProxy) === callerScopeVer;
      }
      function clearScopes(rootMeta, apiCtx) {
        const { debug } = apiCtx;
        const drilledMap = /* @__PURE__ */ new Map();
        apiCtx.newNodeMap.forEach((v2) => {
          const { node, parent, key } = v2;
          const drilledNode = drilledMap.get(node);
          if (drilledNode) {
            parent[key] = drilledNode;
            return;
          }
          const item = v2;
          deepDrill(node, parent, key, (obj, parentObj, key2) => {
            const meta = getDraftMeta(obj, apiCtx);
            if (meta) {
              const { modified, copy, self: self2 } = meta;
              const targetNode = !modified ? self2 : copy;
              parentObj[key2] = targetNode;
            }
          });
          item.target = parent[key];
          drilledMap.set(node, item.target);
        });
        rootMeta.scopes.forEach((meta) => {
          const { modified, copy, parentMeta, key, self: self2, revoke, proxyVal, isDel, isFast } = meta;
          if (!copy)
            return revoke();
          if (debug) {
            if (isFast) {
              delete copy[META_KEY];
            } else {
              delete copy.__proto__[META_KEY];
            }
          }
          if (!parentMeta)
            return revoke();
          const targetNode = !modified ? self2 : copy;
          const parentCopy = parentMeta.copy;
          const parentType = parentMeta.selfType;
          if (parentType === MAP$1) {
            parentCopy.set(key, targetNode);
            return revoke();
          }
          if (parentType === SET) {
            parentCopy.delete(proxyVal);
            parentCopy.add(targetNode);
            return revoke();
          }
          if (parentType === ARRAY) {
            ressignArrayItem(parentMeta, meta, { targetNode, key });
            return revoke();
          }
          if (isDel !== true) {
            parentCopy[key] = targetNode;
            return revoke();
          }
        });
        rootMeta.scopes.length = 0;
      }
      function extractFinalData(rootMeta, apiCtx) {
        const { self: self2, copy, modified } = rootMeta;
        let final = self2;
        if (copy && modified) {
          final = rootMeta.copy;
        }
        clearScopes(rootMeta, apiCtx);
        return final;
      }
      function recordVerScope(meta) {
        meta.rootMeta.scopes.push(meta);
      }
      function createScopedMeta(key, baseData, options) {
        const { traps, parentType, fastModeRange, immutBase, apiCtx, autoRevoke } = options;
        const meta = newMeta(key, baseData, options);
        const { copy, fast } = makeCopyWithMeta(baseData, meta, {
          immutBase,
          parentType,
          fastModeRange,
          apiCtx
        });
        meta.copy = copy;
        meta.isFast = fast;
        if (immutBase) {
          const ret = new Proxy(copy, traps);
          meta.proxyVal = ret;
          meta.revoke = noop;
        } else {
          const ret = Proxy.revocable(copy, traps);
          meta.proxyVal = ret.proxy;
          meta.revoke = autoRevoke ? ret.revoke : noop;
        }
        apiCtx.metaMap.set(copy, meta);
        apiCtx.metaMap.set(meta.proxyVal, meta);
        return meta;
      }
      function shouldGenerateProxyItems(parentType, key) {
        if (parentType === ARRAY)
          return true;
        const fnKeys = PROXYITEM_FNKEYS[parentType] || [];
        return fnKeys.includes(key);
      }
      function getMayProxiedVal(val, options) {
        const { key, parentMeta, parent, parentType, fastModeRange, readOnly, apiCtx } = options;
        let curVal = val;
        if (readOnly && parentMeta && !isFn(val)) {
          const { copy, self: self2 } = parentMeta;
          const latestVal = self2[key];
          if (curVal !== latestVal) {
            const meta = apiCtx.metaMap.get(curVal);
            if (meta) {
              apiCtx.metaMap.delete(curVal);
              apiCtx.metaMap.delete(meta.proxyVal);
            }
            copy[key] = latestVal;
            curVal = latestVal;
          }
        }
        const mayCreateProxyVal = (val2, inputKey) => {
          const key2 = inputKey || "";
          if (isPrimitive(val2) || !val2) {
            return val2;
          }
          if (!parentMeta) {
            throw new Error("[[ createMeta ]]: meta should not be null");
          }
          if (!isFn(val2)) {
            if (
              // 是一个全新的节点，不必生成代理，以便提高性能
              parentMeta.newNodeStats[key2] || // 已被 markRaw 标记，不需转为代理
              val2[IS_RAW]
            ) {
              return val2;
            }
            let valMeta = getSafeDraftMeta(val2, apiCtx);
            if (!valMeta) {
              valMeta = createScopedMeta(key2, val2, options);
              recordVerScope(valMeta);
              if (parentMeta.selfType === MAP$1) {
                parent.set(key2, valMeta.copy);
              } else {
                parent[key2] = valMeta.copy;
              }
            }
            return valMeta.proxyVal;
          }
          if (!shouldGenerateProxyItems(parentType, key2)) {
            return val2;
          }
          if (parentMeta.proxyItems) {
            return val2;
          }
          let proxyItems = [];
          if (parentType === SET) {
            const tmp = /* @__PURE__ */ new Set();
            parent.forEach((val3) => tmp.add(mayCreateProxyVal(val3)));
            replaceSetOrMapMethods(tmp, parentMeta, {
              dataType: SET,
              apiCtx
            });
            proxyItems = attachMeta(tmp, parentMeta, { fast: fastModeRange, apiCtx });
            parentMeta.copy = proxyItems;
          } else if (parentType === MAP$1) {
            const tmp = /* @__PURE__ */ new Map();
            parent.forEach((val3, key3) => tmp.set(key3, mayCreateProxyVal(val3, key3)));
            replaceSetOrMapMethods(tmp, parentMeta, {
              dataType: MAP$1,
              apiCtx
            });
            proxyItems = attachMeta(tmp, parentMeta, { fast: fastModeRange, apiCtx });
            parentMeta.copy = proxyItems;
          } else if (parentType === ARRAY && key2 !== "sort") {
            parentMeta.copy = parentMeta.copy || parent.slice();
            proxyItems = parentMeta.proxyVal;
          }
          parentMeta.proxyItems = proxyItems;
          return val2;
        };
        return mayCreateProxyVal(curVal, key);
      }
      function getUnProxyValue(value, apiCtx) {
        if (!isObject(value)) {
          return value;
        }
        const valueMeta = getSafeDraftMeta(value, apiCtx);
        if (!valueMeta)
          return value;
        return valueMeta.copy;
      }
      function replaceSetOrMapMethods(mapOrSet, meta, options) {
        const { dataType, apiCtx } = options;
        const oriDel = mapOrSet.delete.bind(mapOrSet);
        const oriClear = mapOrSet.clear.bind(mapOrSet);
        mapOrSet.delete = function limuDelete(...args) {
          markModified(meta);
          return oriDel(...args);
        };
        mapOrSet.clear = function limuClear(...args) {
          markModified(meta);
          return oriClear(...args);
        };
        if (dataType === SET) {
          const oriAdd = mapOrSet.add.bind(mapOrSet);
          mapOrSet.add = function limuAdd(...args) {
            markModified(meta);
            return oriAdd(...args);
          };
        }
        if (dataType === MAP$1) {
          const oriSet = mapOrSet.set.bind(mapOrSet);
          const oriGet = mapOrSet.get.bind(mapOrSet);
          mapOrSet.set = function limuSet(...args) {
            markModified(meta);
            if (meta.hasOnOperate) {
              const value = args[1];
              meta.rootMeta.execOnOperate("set", args[0], { mayProxyVal: value, value, parentMeta: meta });
            }
            return oriSet(...args);
          };
          mapOrSet.get = function limuGet(...args) {
            const mayProxyVal = oriGet(...args);
            if (meta.hasOnOperate) {
              const draftMeta = getDraftMeta(mayProxyVal, apiCtx);
              const value = draftMeta ? draftMeta.copy || draftMeta.self : mayProxyVal;
              meta.rootMeta.execOnOperate("get", args[0], { mayProxyVal, value, parentMeta: meta, isChanged: false });
            }
            return mayProxyVal;
          };
        }
      }
      function mayMarkModified(options) {
        const { calledBy, parentMeta, op, parentType } = options;
        if (["deleteProperty", "set"].includes(calledBy) || calledBy === "get" && (parentType === SET && SHOULD_REASSIGN_SET_METHODS.includes(op) || // 针对 Set.add
        parentType === ARRAY && SHOULD_REASSIGN_ARR_METHODS.includes(op) || // 针对 Array 一系列的改变操作
        parentType === MAP$1 && SHOULD_REASSIGN_MAP_METHODS.includes(op))) {
          markModified(parentMeta);
        }
      }
      function getValPathKey(parentMeta, key) {
        const pathCopy = parentMeta.keyPath.slice();
        pathCopy.push(key);
        const valPathKey = pathCopy.join("|");
        return valPathKey;
      }
      function handleDataNode(parentDataNode, copyCtx) {
        const { op, key, value: mayProxyValue, calledBy, parentType, parentMeta, apiCtx, isValueDraft } = copyCtx;
        const value = getUnProxyValue(mayProxyValue, apiCtx);
        if (!parentMeta) {
          parentDataNode[key] = value;
          return;
        }
        const { self: self2, copy: parentCopy } = parentMeta;
        mayMarkModified({ calledBy, parentMeta, op, parentType });
        const fnKeys = CAREFUL_FNKEYS[parentType] || [];
        if (isFn(mayProxyValue) && fnKeys.includes(op)) {
          if ("slice" === op) {
            return self2.slice;
          }
          if (CHANGE_ARR_ORDER_METHODS.includes(op)) {
            parentMeta.isArrOrderChanged = true;
          }
          if (parentCopy) {
            if (parentType === SET || parentType === MAP$1) {
              return parentCopy[op].bind(parentCopy);
            }
            return parentCopy[op];
          }
          return self2[op].bind(self2);
        }
        if (!parentCopy) {
          return value;
        }
        const oldValue = parentCopy[key];
        const tryMarkDel = () => {
          const oldValueMeta = getDraftMeta(oldValue, apiCtx);
          oldValueMeta && (oldValueMeta.isDel = true);
        };
        const tryMarkUndel = () => {
          const valueMeta = getDraftMeta(mayProxyValue, apiCtx);
          if (valueMeta && valueMeta.isDel) {
            valueMeta.isDel = false;
            valueMeta.key = key;
            valueMeta.keyPath = parentMeta.keyPath.concat([key]);
            valueMeta.level = parentMeta.level + 1;
            valueMeta.parent = parentMeta.copy;
            valueMeta.parentMeta = parentMeta;
          }
        };
        if (calledBy === "deleteProperty") {
          const valueMeta = getDraftMeta(mayProxyValue, apiCtx);
          if (valueMeta) {
            valueMeta.isDel = true;
          } else {
            tryMarkDel();
          }
          const val = parentCopy[key];
          if (!isPrimitive(val)) {
            apiCtx.newNodeMap.delete(getValPathKey(parentMeta, key));
          }
          delete parentCopy[key];
          return;
        }
        if (!isValueDraft && !isPrimitive(value)) {
          parentMeta.newNodeStats[key] = true;
          apiCtx.newNodeMap.set(getValPathKey(parentMeta, key), { parent: parentCopy, node: value, key, target: null });
        }
        parentCopy[key] = value;
        tryMarkDel();
        tryMarkUndel();
      }
      function deepFreeze(obj) {
        if (isPrimitive(obj)) {
          return obj;
        }
        if (Array.isArray(obj) && obj.length > 0) {
          obj.forEach(deepFreeze);
          return Object.freeze(obj);
        }
        if (isSet(obj)) {
          const set = obj;
          set.add = () => set;
          set.delete = () => false;
          set.clear = noop;
          for (const item of set.values()) {
            Object.freeze(item);
          }
          return Object.freeze(obj);
        }
        if (isMap(obj)) {
          const map = obj;
          map.set = () => map;
          map.delete = () => false;
          map.clear = noop;
          for (const item of map.values()) {
            Object.freeze(item);
          }
          return Object.freeze(obj);
        }
        const propertyNames = Object.getOwnPropertyNames(obj);
        propertyNames.forEach((name) => {
          const value = obj[name];
          deepFreeze(value);
        });
        return Object.freeze(obj);
      }
      const PROPERTIES_BLACK_LIST = ["length", "constructor", "asymmetricMatch", "nodeType", "size"];
      const PBL_DICT = {};
      PROPERTIES_BLACK_LIST.forEach((item) => PBL_DICT[item] = 1);
      const TYPE_BLACK_DICT = { [ARRAY]: 1, [SET]: 1, [MAP$1]: 1 };
      const FINISH_HANDLER_MAP = /* @__PURE__ */ new Map();
      function buildLimuApis(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        const opts = options || {};
        const onOperate = opts.onOperate;
        const hasOnOperate = !!onOperate;
        const customKeys = opts.customKeys || [];
        const fastModeRange = opts.fastModeRange || conf.fastModeRange;
        const immutBase = (_a = opts[IMMUT_BASE]) !== null && _a !== void 0 ? _a : false;
        const readOnly = (_b = opts.readOnly) !== null && _b !== void 0 ? _b : false;
        const disableWarn = opts.disableWarn;
        const compareVer = (_c = opts.compareVer) !== null && _c !== void 0 ? _c : false;
        const debug = (_d = opts.debug) !== null && _d !== void 0 ? _d : false;
        const autoFreeze = (_e = opts.autoFreeze) !== null && _e !== void 0 ? _e : conf.autoFreeze;
        const metaVer = genMetaVer();
        const apiCtx = { metaMap: /* @__PURE__ */ new Map(), newNodeMap: /* @__PURE__ */ new Map(), debug, metaVer };
        ROOT_CTX.set(metaVer, apiCtx);
        const autoRevoke = (_f = opts.autoRevoke) !== null && _f !== void 0 ? _f : conf.autoRevoke;
        const silenceSetTrapErr = (_g = opts.silenceSetTrapErr) !== null && _g !== void 0 ? _g : true;
        const logChangeFailed = (op, key) => {
          console.warn(`${op} ${key} failed, cuase draft root has been finised!`);
          return silenceSetTrapErr;
        };
        let isDraftFinished = false;
        const warnReadOnly = () => {
          if (!disableWarn) {
            console.warn("can not mutate state at readOnly mode!");
          }
          return true;
        };
        const execOnOperate = (op, key, options2) => {
          const { mayProxyVal, parentMeta: inputPMeta, value, isCustom = false } = options2;
          let isChanged = false;
          if (!onOperate)
            return { isChanged, mayProxyVal };
          const parentMeta = inputPMeta || {};
          const { selfType = "", keyPath = [], copy, self: self2, modified, proxyVal: parentProxy } = parentMeta || {};
          let isBuiltInFnKey = false;
          if (options2.isChanged !== void 0) {
            isChanged = options2.isChanged;
          } else {
            const fnKeys = CAREFUL_FNKEYS[selfType] || [];
            if (fnKeys.includes(key)) {
              isBuiltInFnKey = true;
              const changeFnKeys = CHANGE_FNKEYS[selfType] || [];
              isChanged = changeFnKeys.includes(key);
            } else if (op !== "get") {
              const node = modified ? copy : self2;
              isChanged = inputPMeta ? node[key] !== value : true;
            }
          }
          let replacedValue = null;
          let isReplaced = false;
          const replaceValue = (value2) => {
            isReplaced = true;
            replacedValue = value2;
          };
          const getReplaced = () => ({ isReplaced, replacedValue });
          onOperate({
            immutBase,
            parent: self2,
            parentType: selfType,
            parentProxy,
            op,
            replaceValue,
            getReplaced,
            isBuiltInFnKey,
            isChanged,
            isCustom,
            key,
            keyPath,
            fullKeyPath: keyPath.concat(key),
            value,
            proxyValue: mayProxyVal
          });
          return {
            mayProxyVal: isReplaced ? replacedValue : mayProxyVal,
            isChanged
          };
        };
        const limuApis = /* @__PURE__ */ (() => {
          let canFreezeDraft = true;
          const limuTraps = {
            // parent指向的是代理之前的对象
            get: (parent, key) => {
              if (META_VER === key) {
                return metaVer;
              }
              const currentVal = parent[key];
              if (JS_SYM_KEYS.includes(key)) {
                if (isFn(currentVal)) {
                  if (Symbol.iterator === key && Array.isArray(parent)) {
                    let idx = 0;
                    const iter = () => ({
                      next: () => {
                        const len = parent.length;
                        if (len === 0) {
                          return { done: true, value: void 0 };
                        }
                        const done = idx === len;
                        const value = done ? void 0 : limuTraps.get(parent, String(idx));
                        idx++;
                        return { done, value };
                      },
                      [Symbol.iterator]: () => {
                        return iter;
                      }
                    });
                    return iter;
                  }
                  return currentVal.bind(parent);
                }
                return currentVal;
              }
              if (key === "__proto__" || key === "toJSON" && !has(parent, key)) {
                return currentVal;
              }
              let mayProxyVal = currentVal;
              const parentMeta = getSafeDraftMeta(parent, apiCtx);
              if (customKeys.includes(key)) {
                const ret2 = execOnOperate("get", key, { parentMeta, mayProxyVal, value: currentVal, isChanged: false, isCustom: true });
                return ret2.mayProxyVal;
              }
              const parentType = parentMeta === null || parentMeta === void 0 ? void 0 : parentMeta.selfType;
              if (TYPE_BLACK_DICT[parentType] && PBL_DICT[key]) {
                if (key === "length" || key === "size") {
                  execOnOperate("get", key, { parentMeta, mayProxyVal, value: currentVal });
                }
                return parentMeta.copy[key];
              }
              mayProxyVal = getMayProxiedVal(currentVal, {
                key,
                compareVer,
                parentMeta,
                parentType,
                ver: metaVer,
                traps: limuTraps,
                parent,
                fastModeRange,
                immutBase,
                readOnly,
                apiCtx,
                hasOnOperate,
                autoRevoke
              });
              if (parentType === ARRAY && canBeNum(key)) {
                const ret2 = execOnOperate("get", key, { parentMeta, mayProxyVal, value: currentVal });
                return ret2.mayProxyVal;
              }
              if (CAREFUL_TYPES[parentType]) {
                mayProxyVal = handleDataNode(parent, {
                  op: key,
                  key,
                  value: currentVal,
                  calledBy: "get",
                  parentType,
                  parentMeta,
                  apiCtx
                });
                const ret2 = execOnOperate("get", key, { parentMeta, mayProxyVal, value: currentVal });
                return ret2.mayProxyVal;
              }
              const ret = execOnOperate("get", key, { parentMeta, mayProxyVal, value: currentVal });
              return ret.mayProxyVal;
            },
            // parent 指向的是代理之前的对象
            set: (parent, key, value) => {
              if (isDraftFinished) {
                return logChangeFailed("set", key);
              }
              const parentMeta = getSafeDraftMeta(parent, apiCtx);
              let isValueDraft = false;
              if (isDraft$2(value)) {
                isValueDraft = true;
                if (isInSameScope(value, metaVer)) {
                  const rawValue = getUnProxyValue(value, apiCtx);
                  if (rawValue === parent[key]) {
                    return true;
                  }
                } else {
                  canFreezeDraft = false;
                }
              }
              if (readOnly) {
                execOnOperate("set", key, { parentMeta, isChanged: false, value });
                return warnReadOnly();
              }
              if (parentMeta && parentMeta.selfType === ARRAY) {
                if (parentMeta.copy && parentMeta.__callSet && canBeNum(key)) {
                  execOnOperate("set", key, { parentMeta, value });
                  parentMeta.copy[key] = value;
                  return true;
                }
                parentMeta.__callSet = true;
              }
              let isChanged = false;
              if (!onOperate) {
                const node = parentMeta.modified ? parentMeta.copy : parentMeta.self;
                isChanged = node[key] !== value;
              } else {
                const ret = execOnOperate("set", key, { parentMeta, value });
                isChanged = ret.isChanged;
              }
              if (isChanged) {
                handleDataNode(parent, {
                  parentMeta,
                  key,
                  value,
                  calledBy: "set",
                  apiCtx,
                  isValueDraft
                });
              }
              return true;
            },
            // delete or Reflect.deleteProperty will trigger this trap
            deleteProperty: (parent, key) => {
              if (isDraftFinished) {
                return logChangeFailed("delete", key);
              }
              const parentMeta = getSafeDraftMeta(parent, apiCtx);
              const value = parent[key];
              if (readOnly) {
                execOnOperate("del", key, { parentMeta, isChanged: false, value });
                return warnReadOnly();
              }
              execOnOperate("del", key, { parentMeta, isChanged: true, value });
              handleDataNode(parent, {
                parentMeta,
                op: "del",
                key,
                value: "",
                calledBy: "deleteProperty",
                apiCtx
              });
              return true;
            },
            // trap function call
            apply: function(target, thisArg, args) {
              return target.apply(thisArg, args);
            }
          };
          return {
            createDraft: (mayDraft) => {
              if (isPrimitive(mayDraft)) {
                throw new Error("base state can not be primitive");
              }
              let oriBase = mayDraft;
              const draftMeta = getSafeDraftMeta(mayDraft, apiCtx);
              if (draftMeta) {
                if (immutBase && draftMeta.isImmutBase) {
                  return draftMeta.proxyVal;
                }
                oriBase = draftMeta.self;
              }
              const meta = createScopedMeta("", oriBase, {
                ver: metaVer,
                traps: limuTraps,
                immutBase,
                compareVer,
                apiCtx,
                hasOnOperate,
                autoRevoke
              });
              recordVerScope(meta);
              meta.execOnOperate = execOnOperate;
              FINISH_HANDLER_MAP.set(meta.proxyVal, limuApis.finishDraft);
              return meta.proxyVal;
            },
            finishDraft: (proxyDraft) => {
              const rootMeta = getSafeDraftMeta(proxyDraft, apiCtx);
              if (!rootMeta) {
                throw new Error("rootMeta should not be null!");
              }
              if (rootMeta.level !== 0) {
                throw new Error("can not finish sub draft node!");
              }
              if (rootMeta.isImmutBase) {
                return proxyDraft;
              }
              let final = extractFinalData(rootMeta, apiCtx);
              if (autoFreeze && canFreezeDraft) {
                final = deepFreeze(final);
              }
              ROOT_CTX.delete(metaVer);
              isDraftFinished = true;
              return final;
            }
          };
        })();
        return limuApis;
      }
      function markRaw$1(rawVal) {
        if (!rawVal || isPrimitive(rawVal))
          return rawVal;
        rawVal[IS_RAW] = true;
        return rawVal;
      }
      const isDraft$1 = isDraft$2;
      const isDiff$1 = isDiff$2;
      const shallowCompare$1 = shallowCompare$2;
      const limuUtils = {
        isObject,
        isDraft: isDraft$1,
        isDiff: isDiff$1,
        shallowCompare: shallowCompare$1,
        getDataType: getDataType$1
      };
      const VER$1 = VER$2;
      function createDraft(base, options) {
        const apis = buildLimuApis(options);
        return apis.createDraft(base);
      }
      function finishDraft(draft) {
        const finishHandler = FINISH_HANDLER_MAP.get(draft);
        if (!finishHandler) {
          throw new Error(`Not a Limu root draft or draft has been finished!`);
        }
        FINISH_HANDLER_MAP.delete(draft);
        return finishHandler(draft);
      }
      function checkCbFn(cb) {
        if (!isFn(cb)) {
          throw new Error("produce callback is not a function");
        }
      }
      function checkCbPromise(cb, result) {
        if (isPromiseFn(cb) || isPromiseResult(result)) {
          throw new Error("produce callback can not be a promise function or result");
        }
      }
      function innerProduce(baseState, cb, options) {
        checkCbFn(cb);
        const draft = createDraft(baseState, options);
        const result = cb(draft);
        checkCbPromise(cb, result);
        return finishDraft(draft);
      }
      function produceFn(baseState, cb, options) {
        if (!cb || !isFn(cb)) {
          const mayCb = baseState;
          const mayOptions = cb;
          checkCbFn(baseState);
          return (state) => {
            return innerProduce(state, mayCb, mayOptions);
          };
        }
        return innerProduce(baseState, cb, options);
      }
      const produce = produceFn;
      function immut(base, options) {
        const limuApis = buildLimuApis(Object.assign(Object.assign({}, options || {}), { readOnly: true, [IMMUT_BASE]: true }));
        const immutData = limuApis.createDraft(base);
        return immutData;
      }
      const markRaw = markRaw$1;
      var __defProp2 = Object.defineProperty;
      var __export = (target, all) => {
        for (var name in all)
          __defProp2(target, name, { get: all[name], enumerable: true });
      };
      var api_exports = {};
      __export(api_exports, {
        $: () => $$1,
        action: () => action,
        addMiddleware: () => addMiddleware,
        addPlugin: () => addPlugin,
        assignThisHX: () => assignThisHX,
        atom: () => atom,
        atomx: () => atomx,
        bindAtom: () => bindAtom,
        block: () => block,
        createShared: () => createShared,
        cst: () => cst,
        currentDraftRoot: () => currentDraftRoot,
        defineDeriveFnItem: () => defineDeriveFnItem,
        defineDeriveTask: () => defineDeriveTask,
        defineMutateFnItem: () => defineMutateFnItem,
        defineStore: () => defineStore,
        derive: () => derive,
        deriveDict: () => deriveDict,
        dynamicBlock: () => dynamicBlock,
        emit: () => emit,
        flush: () => flush,
        getActionLoading: () => getActionLoading,
        getAtom: () => getAtom,
        getDeriveLoading: () => getDeriveLoading,
        getHX: () => getHX,
        getMutateLoading: () => getMutateLoading,
        getRawState: () => getRawState,
        getSnap: () => getSnap,
        init: () => init,
        isAtom: () => isAtom,
        isDerivedAtom: () => isDerivedAtom,
        isDerivedResult: () => isDerivedResult,
        isDiff: () => isDiff,
        isDraft: () => isDraft,
        isSharedState: () => isSharedState,
        makeWithAtomOptions: () => makeWithAtomOptions,
        markRaw: () => markRaw,
        mutate: () => mutate,
        mutateDict: () => mutateDict,
        on: () => on,
        produce: () => produce,
        reactiveDesc: () => reactiveDesc,
        runDerive: () => runDerive,
        runDeriveTask: () => runDeriveTask,
        runMutate: () => runMutate,
        runMutateTask: () => runMutateTask,
        shallowCompare: () => shallowCompare,
        share: () => share,
        sharex: () => sharex,
        signal: () => signal,
        storeSrv: () => storeSrv,
        sync: () => sync,
        syncer: () => syncer,
        useActionLoading: () => useActionLoading,
        useAtom: () => useAtom,
        useAtomX: () => useAtomX,
        useDerived: () => useDerived,
        useGlobalForceUpdate: () => useGlobalForceUpdate,
        useGlobalId: () => useGlobalId,
        useLocalForceUpdate: () => useLocalForceUpdate,
        useMutable: () => useMutable,
        useMutateLoading: () => useMutateLoading,
        useOnEvent: () => useOnEvent,
        useReactive: () => useReactive,
        useReactiveX: () => useReactiveX,
        useService: () => useService,
        useWatch: () => useWatch,
        useWatchEffect: () => useWatchEffect,
        watch: () => watch,
        watchEffect: () => watchEffect,
        withAtom: () => withAtom
      });
      var symbolSeed = 0;
      var NativeSym = Symbol;
      var HAS_SYMBOL = typeof NativeSym === "function";
      function createSymbol(str) {
        if (HAS_SYMBOL) {
          return NativeSym(str);
        }
        symbolSeed += 1;
        return `__HELUX_SYMBOL_${symbolSeed}__`;
      }
      var VER = "5.0.2";
      var LIMU_VER = VER$1;
      var EVENT_NAME = {
        ON_DATA_CHANGED: "ON_DATA_CHANGED",
        ON_SHARE_CREATED: "ON_SHARE_CREATED",
        ON_ERROR_OCCURED: "ON_ERROR_OCCURED"
      };
      var RECORD_LOADING = {
        NO: "no",
        PRIVATE: "private",
        GLOBAL: "global"
      };
      var PROTO_KEY = "__proto__";
      var HAS_PROXY = O$2();
      var RUN_AT_SERVER = y$1();
      var UNDEFINED = createSymbol("HeluxUndefined");
      var MUTATE_FN_ITEM = createSymbol("HeluxMutateFnItem");
      var FN_KEY = createSymbol("HeluxFnKey");
      var SHARED_KEY = createSymbol("HeluxSharedKey");
      var REACTIVE_META_KEY = createSymbol("HeluxReactiveMeta");
      var IS_BLOCK = createSymbol("HeluxIsBlock");
      var IS_ATOM = createSymbol("HeluxIsAtom");
      var IS_DERIVED_ATOM = createSymbol("HeluxIsDerivedAtom");
      var CLASS_ATOM = createSymbol("HeluxClassDefaultAtom");
      var CLASS_ERROR = createSymbol("HeluxClassError");
      var CLASS_ERROR_INFO = createSymbol("HeluxClassErrorInfo");
      var OP_KEYS = [SHARED_KEY, IS_ATOM, IS_DERIVED_ATOM, IS_BLOCK];
      var SINGLE_MUTATE = "SingleMutate";
      var HELUX_GLOBAL_LOADING = "HeluxGlobalLoading";
      var STOP_DEPTH = 6;
      var STOP_ARR_DEP = true;
      var EXPIRE_MS = 2e3;
      var SIZE_LIMIT = 20;
      var RENDER_START = "1";
      var RENDER_END = "2";
      var NOT_MOUNT = 1;
      var MOUNTED = 2;
      var UNMOUNT = 3;
      var KEY_SPLITER = "|";
      var ASYNC_TYPE = {
        TASK: "task",
        MAY_TRANSFER: "may_transfer"
      };
      var SCOPE_TYPE = {
        STATIC: "static",
        HOOK: "hook"
      };
      var STATE_TYPE = {
        USER_STATE: "user_state",
        GLOGAL_EMPTY: "global_empty",
        GLOGAL_LOADING: "global_loading",
        PRIVATE_LOADING: "private_loading"
      };
      var DERIVE = "derive";
      var WATCH = "watch";
      var DICT = "Object";
      var MAP = "Map";
      var ARR = "Array";
      var OTHER = "Other";
      var FROM = {
        /**
         * 来自 top setState(draft)、ins setState(draft) 的读写
         * ```ts
         * const [, setState] = atom({a:1});
         *
         * const [, setState] = useAtom();
         * ```
         */
        SET_STATE: "SetState",
        /**
         * 来自 mutate task setState(draft), mutate fn reactive draft 的读写
         * ```ts
         * mutate({
         *   fn: draft => draft.xx = 1,
         *   task: async({ setState }){ },
         * });
         * ```
         */
        MUTATE: "Mutate",
        /**
         * 来自 action setState(draft) 的读写
         * ```ts
         * action(({ setState })=>{
         *   setState();
         * })
         * ```
         */
        ACTION: "Action",
        /**
         * 来自 top reactive、ins reactive、mutate task reactive draft、action reactive draft 的读写
         * ```ts
         * mutate({
         *   task: async({ draft }){ },
         * });
         *
         * action(async ({ draft })=>{ });
         *
         * const [,,{ reactive }] = atom({a:1});
         *
         * const [ reactive ] = useReactive(someAtom);
         * ```
         */
        REACTIVE: "Reactive",
        /**
         * 来自伴生 loading 的读写
         */
        LOADING: "Loading",
        /**
         * 来自 sync 的读写
         * ```ts
         * import { sync } from 'helux';
         * sync(someState)(to=>to.a.b);
         *
         * const [,,{ sync }] = atom({a:1});
         * sync(to=>to.a.b);
         * ```
         */
        SYNC: "Sync"
      };
      function isAtom(mayAtom) {
        if (!mayAtom) {
          return false;
        }
        return mayAtom[IS_ATOM] ?? false;
      }
      function isSharedState(mayShared) {
        if (!mayShared) {
          return false;
        }
        return mayShared[IS_ATOM] !== void 0;
      }
      function isDerivedAtom(mayAtomDerived) {
        if (!mayAtomDerived) {
          return false;
        }
        return mayAtomDerived[IS_DERIVED_ATOM] || false;
      }
      function isDerivedResult(mayDerived) {
        if (!mayDerived) {
          return false;
        }
        return mayDerived[IS_DERIVED_ATOM] !== void 0;
      }
      function getAtom(mayAtom) {
        if (isAtom(mayAtom) || isDerivedAtom(mayAtom)) {
          return mayAtom.val;
        }
        return mayAtom;
      }
      function buildFnScope() {
        return {
          keySeed: {
            static: 0,
            hook: 0,
            Reactive: 0,
            Mutate: 0
          },
          runningFnKey: "",
          /**
           * 从 sharedKey 维度辅助 helpers/fnDep 丢弃一些异步逻辑中收集的依赖信息
           */
          runningSharedKey: 0,
          /**
           * 忽略依赖收集，辅助 helpers/fnDep mutateFn/callAsyncMutateFnLogic 里丢弃一些异步逻辑中收集的依赖信息
           * helux强制用户必须把依赖放置于同步逻辑中
           */
          isIgnore: false,
          /** 函数运行结束收集到的读依赖 depKeys */
          depKeys: [],
          /** 函数运行结束后，会做一次依赖精简逻辑，只保留最长路径依赖，若依赖在 fixedDepKeys 里则不会被精简掉 */
          fixedDepKeys: [],
          /**
           * del path array of array
           * 需要移除的 depKeys，解决 mutate 回调里 draft 里深层次读取修改的依赖收集不正确问题
           * ```
           * // 这里 get 收集到了 a，这个 a 需要移除，否则会造成死循环依赖误判
           * draft.a.val = state.someKey + 1;
           * ```
           */
          delPathAoa: [],
          /** globalId to Array<insKey> */
          GID_INSKEYS_MAP: /* @__PURE__ */ new Map(),
          FNKEY_STATIC_CTX_MAP: /* @__PURE__ */ new Map(),
          FNKEY_HOOK_CTX_MAP: /* @__PURE__ */ new Map(),
          DEPKEY_FNKEYS_MAP: /* @__PURE__ */ new Map(),
          /** sharedKeyStr to fnKeys */
          SKEY_FNKEYS_MAP: /* @__PURE__ */ new Map(),
          UNMOUNT_INFO_MAP: /* @__PURE__ */ new Map(),
          /** 记录第一次运行的各个函数，辅助推导出计算状态 */
          DEPKEY_COMPUTING_FNKEYS_MAP: /* @__PURE__ */ new Map()
        };
      }
      function buildBlockScope() {
        return {
          keySeed: 0,
          // for block key
          keyPrefix: 0,
          initCount: 0,
          mountedCount: 0,
          latest: {
            val: null,
            stateOrResult: null,
            sharedKey: 0,
            depKey: "",
            keyPath: [],
            isDerivedResult: false,
            isDerivedAtom: false
          },
          runningKey: "",
          isDynamic: false,
          /** blockKey to IBlockCtx */
          KEY_CTX_MAP: /* @__PURE__ */ new Map(),
          KEY_DYNAMIC_CTX_MAP: /* @__PURE__ */ new Map()
        };
      }
      function buildInsScope() {
        return {
          keySeed: 0,
          // for insKey
          UNMOUNT_INFO_MAP: /* @__PURE__ */ new Map()
        };
      }
      function buildSharedScope() {
        return {
          keySeed: 0,
          // for sharedKey
          SHARED_KEY_STATE_MAP: /* @__PURE__ */ new Map(),
          /** rawState to sharedKey */
          STATE_SHARED_KEY_MAP: /* @__PURE__ */ new Map(),
          /** sharedKey to internal */
          INTERMAL_MAP: /* @__PURE__ */ new Map(),
          /** cache value compare result */
          COMPARE_MAP: /* @__PURE__ */ new Map(),
          isStateChanged: false
        };
      }
      function buildEventBus() {
        const name2cbs = {};
        return {
          on: (name, cb) => {
            const cbs = k$1(name2cbs, name, []);
            cbs.push(cb);
          },
          emit: (name, ...args) => {
            const cbs = name2cbs[name] || [];
            cbs.slice().forEach((cb) => cb(...args));
          },
          off: (name, cb) => {
            const cbs = name2cbs[name] || [];
            const idx = cbs.findIndex((item) => item === cb);
            if (idx >= 0) cbs.splice(idx, 1);
          },
          /** for perf */
          canEmit: (name) => name2cbs[name]
        };
      }
      function createRoot() {
        const root = {
          VER,
          LIMU_VER: VER$1,
          rootState: {},
          setState: (moduleName, partialState) => {
            const modInternal = root.ctx.modMap.get(moduleName);
            if (!modInternal) {
              throw new Error(`moduleName ${moduleName} not found`);
            }
            modInternal.setState(partialState);
          },
          ctx: {
            bus: buildEventBus(),
            userBus: buildEventBus(),
            mod: {},
            // 与模块相关的辅助信息（4.7.0 之后使用 modMap 替代，后期会删除此属性）
            modMap: /* @__PURE__ */ new Map(),
            // 替代 mod
            middlewares: [],
            plugins: [],
            sharedScope: buildSharedScope(),
            fnScope: buildFnScope(),
            insScope: buildInsScope(),
            blockScope: buildBlockScope(),
            markAtomMap: /* @__PURE__ */ new Map(),
            // 不支持 symbol 的环境才会记录此map
            renderSN: 0,
            // 触发setState批次序列号的种子数
            globalLoading: W$1(null),
            // works for top api useLoading
            globalLoadingInternal: W$1(null),
            // works for top api useLoading
            globalEmpty: W$1(null),
            // works for top api useGlobalId
            globalEmptyInternal: W$1(null),
            // works for top api useGlobalId
            isRootRender: true
          },
          legacyRoot: {}
        };
        return root;
      }
      var ROOT = W$1({});
      var inited = false;
      var API = W$1(null);
      var optionsInited = false;
      function getRootCtx() {
        return ROOT.ctx || W$1({});
      }
      function getRoot() {
        return ROOT;
      }
      function setRootData(options) {
        ROOT = options.ROOT;
        API = options.api;
        inited = options.inited;
      }
      function getRootData() {
        return { ROOT, inited, API };
      }
      function init(options) {
        if (optionsInited) {
          return false;
        }
        optionsInited = true;
        const { isRootRender = true } = options;
        getRootCtx().isRootRender = isRootRender;
        return true;
      }
      var ctx = getRootCtx();
      function getCtxVal(key) {
        const safeCtx = getRootCtx();
        const val = safeCtx[key];
        ctx[key] = val;
        return val;
      }
      function getBlockScope() {
        return ctx.blockScope || getCtxVal("blockScope");
      }
      function getFnScope() {
        return ctx.fnScope || getCtxVal("fnScope");
      }
      function getSharedScope() {
        return ctx.sharedScope || getCtxVal("sharedScope");
      }
      function getInsScope() {
        return ctx.insScope || getCtxVal("insScope");
      }
      function getInternalMap() {
        const { INTERMAL_MAP } = getSharedScope();
        return INTERMAL_MAP;
      }
      function clearInternal(moduleName, loc) {
        if (!moduleName || !g$1() || !loc) return;
        const { INTERMAL_MAP, SHARED_KEY_STATE_MAP, STATE_SHARED_KEY_MAP } = getSharedScope();
        let matchedKeys = [];
        let cleared = false;
        INTERMAL_MAP.forEach((item) => {
          if (item.moduleName === moduleName && item.loc === loc && item.stateType === STATE_TYPE.USER_STATE) {
            matchedKeys.push(item.sharedKey);
          }
        });
        if (matchedKeys.length > 1) {
          const key = matchedKeys[0];
          const prev = INTERMAL_MAP.get(key);
          INTERMAL_MAP.delete(key);
          if (prev) {
            SHARED_KEY_STATE_MAP.delete(prev.sharedKey);
            STATE_SHARED_KEY_MAP.delete(prev.rawState);
          }
        }
        return cleared;
      }
      function getInternalByKey(sharedKey) {
        const internalMap = getInternalMap();
        return internalMap.get(sharedKey);
      }
      function getInternal(state) {
        const key = getSharedKey(state);
        return getInternalByKey(key);
      }
      function setInternal(state, internal) {
        const internalMap = getInternalMap();
        const key = getSharedKey(state);
        internalMap.set(key, internal);
      }
      function getRawState(state) {
        const internal = getInternal(state);
        return internal.rawState;
      }
      function getSnap(state, isPrev = true) {
        const internal = getInternal(state);
        return isPrev ? internal.prevSnap : internal.snap;
      }
      function getSharedKey(state) {
        if (!state) return 0;
        return state[SHARED_KEY] || getSharedScope().STATE_SHARED_KEY_MAP.get(state) || 0;
      }
      function getBoundStateInfo(extraState) {
        let boundInfo = { state: {}, stateRoot: {}, isAtom: false };
        if (!extraState) {
          return boundInfo;
        }
        const extraInternal = getInternal(extraState);
        if (extraInternal) {
          const { sharedState: state, sharedRoot: stateRoot } = extraInternal;
          boundInfo = { state, stateRoot, isAtom: extraInternal.forAtom };
        }
        return boundInfo;
      }
      function markSharedKey(state) {
        const scope = getSharedScope();
        const { STATE_SHARED_KEY_MAP } = scope;
        const keySeed = $$2(scope.keySeed);
        STATE_SHARED_KEY_MAP.set(state, keySeed);
        scope.keySeed = keySeed;
        return keySeed;
      }
      function mapSharedState(sharedKey, sharedRoot) {
        const { SHARED_KEY_STATE_MAP, STATE_SHARED_KEY_MAP } = getSharedScope();
        SHARED_KEY_STATE_MAP.set(sharedKey, sharedRoot);
        STATE_SHARED_KEY_MAP.set(sharedRoot, sharedKey);
      }
      function getSharedState(sharedKey) {
        return getSharedScope().SHARED_KEY_STATE_MAP.get(sharedKey);
      }
      function recordMod(sharedState, options) {
        if (RUN_AT_SERVER) {
          return;
        }
        const { rootState, ctx: ctx2 } = getRoot();
        const { moduleName, usefulName } = options;
        const existedShared = rootState[usefulName];
        const existedInternal = getInternal(existedShared);
        if (moduleName && existedInternal && existedInternal.loc !== options.loc) {
          if (!moduleName.endsWith("@Loading")) {
            const locInfo = `
loc1:${existedInternal.loc} 
loc2:${options.loc}`;
            x$1(
              `only-dev-mode tip: moduleName ${moduleName} duplicate! this does not effect helux but the duplicated module will be ignored by devtool` + locInfo
            );
          }
          return;
        }
        rootState[usefulName] = sharedState;
        ctx2.modMap.set(usefulName, getInternal(sharedState));
      }
      var fakeInternal = { innerSetState: f$2 };
      function buildInternal(parsedOptions, innerOptions) {
        const { rawState, forAtom, before } = parsedOptions;
        const insCtxMap = /* @__PURE__ */ new Map();
        const key2InsKeys = {};
        const id2InsKeys = {};
        const level1ArrKeys = [];
        const copy = { ...rawState };
        let rawStateVal = copy;
        if (forAtom) {
          rawStateVal = rawState.val;
        }
        const hasBeforeCommit = before !== f$2;
        return {
          ver: 0,
          sn: 0,
          insCount: 0,
          // reactive and reactiveRoot will be replaced in buildReactive process later
          reactive: rawState,
          reactiveRoot: rawState,
          // sync and syncer will be replaced after buildInternal
          sync: f$2,
          syncer: f$2,
          // snap and prevSnap will be replaced after changing state
          // 这里 copy 两份不同的，避免 commitState 阶段这段逻辑（需要判断 ver 是不是 0，是 0 时 做一次 prevSnap 的替换）
          // 否则 snap 和 prevSnap 是一样的，导致首次运行时的值比较是失败的
          snap: copy,
          prevSnap: copy,
          // TODO 接入 limu copy 函数，这个值目前内部用不到
          // 本意是给 reactive 模块生成 draft 时，代理 rawStateVal 之用，这样控制台展开代理后可看到最新的状态，
          // 且 chrome 浏览器没无 .val 封装的对象，避免作者误会拆封后的 reactive 对象为何还有一层 .val
          // 这个优化做和不做都对逻辑正确性无影响
          rawStateVal,
          ...parsedOptions,
          ...innerOptions,
          insCtxMap,
          key2InsKeys,
          id2InsKeys,
          lifecycle: {
            willMount: f$2,
            mounted: f$2,
            willUnmount: f$2,
            // 5.0 之后，将之前的 before 迁移到 lifecycle 里，同时用户透传的 lifecycle.beforeCommit 也会合并到此处
            beforeCommit: before,
            afterCommit: f$2,
            /** 严格模式下，在 effect 里判断 insCount=1 是失败的，需提前标记此变量，确保 mounted 触发 */
            shouldCallMounted: false,
            // 优化 beforeCommit 执行效率
            hasBeforeCommit
          },
          recordId(id, insKey) {
            if (!id) return;
            const insKeys = k$1(id2InsKeys, id, []);
            n$2(insKeys, insKey);
          },
          delId(id, insKey) {
            if (!id) return;
            t$1(id2InsKeys[id] || [], insKey);
          },
          recordDep(depKey, insKey) {
            const insKeys = k$1(key2InsKeys, depKey, []);
            n$2(insKeys, insKey);
          },
          delDep(depKey, insKey) {
            t$1(key2InsKeys[depKey] || [], insKey);
          },
          mapInsCtx(insCtx, insKey) {
            insCtxMap.set(insKey, insCtx);
          },
          delInsCtx(insKey) {
            insCtxMap.delete(insKey);
          },
          extra: {},
          // 记录一些需复用的中间生成的数据
          loadingInternal: fakeInternal,
          level1ArrKeys
        };
      }
      var fnKeyPrefix = {
        Mutate: "",
        Reactive: "r",
        [SCOPE_TYPE.STATIC]: "s",
        [SCOPE_TYPE.HOOK]: "h"
      };
      function genInsKey() {
        const insScope = getInsScope();
        const nextKey = $$2(insScope.keySeed);
        insScope.keySeed = nextKey;
        return nextKey;
      }
      function genBlockKey() {
        const blockScope = getBlockScope();
        const { keySeed, keyPrefix } = blockScope;
        const nextKey = $$2(keySeed);
        blockScope.keySeed = nextKey;
        let prefix = keyPrefix;
        if (h$1(keySeed)) {
          prefix = $$2(keyPrefix);
          blockScope.keyPrefix = prefix;
        }
        return `${prefix}_${nextKey}`;
      }
      function genRenderSN() {
        const ctx2 = getRootCtx();
        const renderSN = ctx2.renderSN;
        const nextNo = renderSN === Number.MAX_VALUE ? 1 : renderSN + 1;
        ctx2.renderSN = nextNo;
        return nextNo;
      }
      function genFnKey(keyType) {
        const prefix = fnKeyPrefix[keyType];
        const fnScope = getFnScope();
        const keyMap = fnScope.keySeed;
        const keySeed = $$2(keyMap[keyType]);
        keyMap[keyType] = keySeed;
        return `${prefix}${keySeed}`;
      }
      function getReactiveKey() {
        return genFnKey("Reactive");
      }
      var { MAY_TRANSFER } = ASYNC_TYPE;
      var { SET_STATE, REACTIVE } = FROM;
      var fakeGetReplaced = () => ({ isReplaced: false, replacedValue: null });
      var noopAny = () => {
      };
      var fnItem = newMutateFnItem({ isFake: true });
      function newReactiveMeta(draft, buildOptions, finish = f$2) {
        const { desc = "", onRead, from = REACTIVE, depKeys = [], isTop = false, expired = false, insKey = 0, payloadArgs } = buildOptions;
        return {
          draft,
          finish,
          modified: false,
          expired,
          sharedKey: 0,
          moduleName: "",
          hasFlushTask: false,
          nextTickFlush: f$2,
          data: [],
          isTop,
          key: "",
          fnKey: "",
          depKeys,
          writeKeys: [],
          desc,
          onRead,
          from,
          insKey,
          payloadArgs
        };
      }
      function newMutateCtx(options) {
        const {
          ids = [],
          globalIds = [],
          isReactive = false,
          from = SET_STATE,
          enableDep = false,
          handleCbReturn = true,
          sn = genRenderSN(),
          isFirstCall = false,
          desc = ""
        } = options;
        return {
          fnKey: "",
          depKeys: [],
          forcedDepKeys: [],
          triggerReasons: [],
          ids,
          globalIds,
          readKeys: {},
          writeKeys: {},
          arrKeyDict: {},
          // 记录读取过程中遇到的数组 key
          writeKeyPathInfo: {},
          handleCbReturn,
          draftVal: null,
          from,
          isReactive,
          enableDep,
          sn,
          isFirstCall,
          desc,
          payloadArgs: void 0
        };
      }
      function newOpParams(key, value, options) {
        const { isChanged = true, parentKeyPath = [], op = "set", parentType = "Object" } = options;
        const fullKeyPath = parentKeyPath.slice();
        fullKeyPath.push(key);
        return {
          isChanged,
          isCustom: false,
          op,
          immutBase: false,
          key,
          value,
          proxyValue: value,
          parentType,
          keyPath: parentKeyPath,
          fullKeyPath,
          isBuiltInFnKey: false,
          replaceValue: f$2,
          getReplaced: fakeGetReplaced
        };
      }
      function newMutateFnItem(partial) {
        const {
          desc = "",
          fn = f$2,
          task = noopAny,
          depKeys = [],
          writeKeys = [],
          deps = a$3,
          isFake = false,
          onlyDeps = false,
          ...rest
        } = partial || {};
        const base = {
          fn,
          task,
          deps,
          oriDesc: "",
          onlyDeps,
          desc,
          depKeys,
          writeKeys,
          checkDeadCycle: void 0,
          watchKey: "",
          isFake,
          enabled: true,
          extraBound: { state: {}, stateRoot: {}, isAtom: false },
          ...rest
        };
        return base;
      }
      function newFnCtx() {
        const base = {
          fnKey: "",
          // 在 fnDep.mapFn 阶段会生成
          fn: f$2,
          subFnInfo: fnItem,
          checkDeadCycle: true,
          isFirstLevel: true,
          isExpired: false,
          task: f$2,
          deps: a$3,
          status: { loading: false, err: null, ok: true },
          stateRoot: {},
          isStateAtom: false,
          forAtom: false,
          remainRunCount: 0,
          showLoading: false,
          nextLevelFnKeys: [],
          prevLevelFnKeys: [],
          mountStatus: NOT_MOUNT,
          depKeys: [],
          depSharedKeys: [],
          result: {},
          fnType: "watch",
          returnUpstreamResult: false,
          scopeType: "static",
          renderStatus: RENDER_START,
          proxyResult: {},
          updater: f$2,
          createTime: Date.now(),
          shouldReplaceResult: false,
          isAsync: false,
          isAsyncTransfer: false,
          forBlock: false,
          isRunning: false,
          dcErrorInfo: { err: null, tipFn: f$2 },
          asyncType: MAY_TRANSFER,
          subscribe: (cb) => {
            cb();
          },
          extra: {},
          setLoading: (loading, err = null) => {
            const ok = !loading && !err;
            base.status = { loading, err, ok };
          },
          renderInfo: {
            time: 0,
            insKey: 0,
            sn: 0,
            getDeps: () => base.depKeys.slice()
          }
        };
        return base;
      }
      var fakeDraftRootMeta = { draftRoot: { val: null }, isFake: true, isAtom: true };
      newMutateCtx({});
      var fakeReativeMeta = newReactiveMeta(true, { expired: true, from: "Reactive", desc: "" });
      newMutateFnItem();
      var fakeInternal2 = buildInternal({ rawState: {}, forAtom: false, usefulName: "" }, {});
      var fakeFnCtx = newFnCtx();
      function setProtoOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
      }
      function mixinProperties(obj, proto) {
        for (var prop in proto) {
          if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
            obj[prop] = proto[prop];
          }
        }
        return obj;
      }
      var setProto = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
      function createHeluxObj(rawObj) {
        const obj = /* @__PURE__ */ Object.create(null);
        setProto(obj, { ...Object.prototype });
        return obj;
      }
      function injectHeluxProto(rawObj) {
        if (w$2(rawObj)) {
          return;
        }
        const pureObj = /* @__PURE__ */ Object.create(null);
        setProto(pureObj, Object.prototype);
        setProto(rawObj, pureObj);
        return rawObj;
      }
      function dset(target, key, val) {
        target[key] = val;
        return true;
      }
      function dget(target, key) {
        return target[key];
      }
      function createDpOb(rawObj, options) {
        const { set = dset, get: get2 = dget, obj = {} } = options || {};
        Object.keys(rawObj).forEach((key) => {
          Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: false,
            set: function(val) {
              return set(rawObj, key, val);
            },
            get: function() {
              return get2(rawObj, key);
            }
          });
        });
        return obj;
      }
      function createOb(rawObj, options) {
        const { set = dset, get: get2 = dget } = options || {};
        if (O$2()) {
          return new Proxy(rawObj, {
            set(target, key, val) {
              return set(target, key, val);
            },
            get(target, key) {
              return get2(target, key);
            }
          });
        }
        const downgradeObj = createHeluxObj();
        const oneLevelOb = createDpOb(downgradeObj, { obj: downgradeObj, set, get: get2 });
        return oneLevelOb;
      }
      var CURRENT_DRAFT_ROOT_META = fakeDraftRootMeta;
      var CURRENT_CB_REACTIVE_KEY = "";
      var CURRENT_INS_CTX = /* @__PURE__ */ new Map();
      var CURRENT_REACTIVE_DESC = /* @__PURE__ */ new Map();
      var CURRENT_REACTIVE_META = /* @__PURE__ */ new Map();
      var CURRENT_DEPS_CB = f$2;
      var CURRENT_FN_DEPS = [];
      var CURRENT_TRIGGERED_WATCH = "";
      function currentDraftRoot() {
        return CURRENT_DRAFT_ROOT_META;
      }
      var TRIGGERED_WATCH = {
        current: () => CURRENT_TRIGGERED_WATCH,
        set: (val) => CURRENT_TRIGGERED_WATCH = val,
        del: () => CURRENT_TRIGGERED_WATCH = ""
      };
      var DEPS_CB = {
        current: () => CURRENT_DEPS_CB,
        set: (cb) => CURRENT_DEPS_CB = cb,
        del: () => CURRENT_DEPS_CB = f$2
      };
      var REACTIVE_DESC = {
        current: (key) => CURRENT_REACTIVE_DESC.get(key) || "SetState",
        /** 用一次就清理, 无默认值返回 */
        currentOnce: (key) => {
          const desc = CURRENT_REACTIVE_DESC.get(key);
          CURRENT_REACTIVE_DESC.delete(key);
          return desc;
        },
        set: (key, desc) => CURRENT_REACTIVE_DESC.set(key, desc),
        del: (key) => CURRENT_REACTIVE_DESC.delete(key)
      };
      var FN_DEP_KEYS = {
        current: () => CURRENT_FN_DEPS,
        set: (val) => CURRENT_FN_DEPS = val,
        del: () => CURRENT_FN_DEPS = []
      };
      var REACTIVE_META = {
        delActive: () => CURRENT_CB_REACTIVE_KEY = "",
        current: () => CURRENT_REACTIVE_META.get(CURRENT_CB_REACTIVE_KEY) || fakeReativeMeta,
        markUsing: (key) => CURRENT_CB_REACTIVE_KEY = key,
        set: (key, obj) => CURRENT_REACTIVE_META.set(key, obj),
        del: (key) => CURRENT_REACTIVE_META.delete(key)
      };
      var INS_CTX = {
        current: (rootVal) => CURRENT_INS_CTX.get(rootVal),
        set: (rootVal, insCtx) => CURRENT_INS_CTX.set(rootVal, insCtx),
        del: (rootVal) => CURRENT_INS_CTX.delete(rootVal)
      };
      var DRAFT_ROOT = {
        /** may use ' get current(){}...' in the future */
        current: () => CURRENT_DRAFT_ROOT_META,
        set: (draftRoot, isAtom2) => {
          Object.assign(CURRENT_DRAFT_ROOT_META, { draftRoot, isAtom: isAtom2, isFake: false });
        },
        del: () => CURRENT_DRAFT_ROOT_META = fakeDraftRootMeta
      };
      function getCtxMap(scopeKeyOrFnKey) {
        const { FNKEY_STATIC_CTX_MAP, FNKEY_HOOK_CTX_MAP } = getFnScope();
        const map = scopeKeyOrFnKey[0] === "s" ? FNKEY_STATIC_CTX_MAP : FNKEY_HOOK_CTX_MAP;
        return map;
      }
      function putComputingFnKey(depKey, fnKey) {
        const { DEPKEY_COMPUTING_FNKEYS_MAP } = getFnScope();
        const fnKeys = R$1(DEPKEY_COMPUTING_FNKEYS_MAP, depKey, []);
        fnKeys.push(fnKey);
      }
      function delComputingFnKey(depKey, fnKey) {
        const { DEPKEY_COMPUTING_FNKEYS_MAP } = getFnScope();
        const fnKeys = DEPKEY_COMPUTING_FNKEYS_MAP.get(depKey);
        if (fnKeys) {
          t$1(fnKeys, fnKey);
        }
      }
      function delFnDepData(fnCtx) {
        const { DEPKEY_FNKEYS_MAP, SKEY_FNKEYS_MAP } = getFnScope();
        const { depKeys, fnKey, depSharedKeys } = fnCtx;
        const toDel = [];
        depKeys.forEach((key) => {
          const fnKeys = DEPKEY_FNKEYS_MAP.get(key) || [];
          t$1(fnKeys, fnKey);
          n$2(toDel, fnKey);
        });
        depSharedKeys.forEach((key) => {
          const fnKeysOfSkey = SKEY_FNKEYS_MAP.get(String(key)) || [];
          toDel.forEach((key2) => {
            t$1(fnKeysOfSkey, key2);
          });
        });
      }
      function opUpstreamFnKey(fnCtx, isAdd) {
        const { FNKEY_STATIC_CTX_MAP } = getFnScope();
        const { fnKey, prevLevelFnKeys } = fnCtx;
        prevLevelFnKeys.forEach((upFnKey) => {
          var _a;
          const next = (_a = FNKEY_STATIC_CTX_MAP.get(upFnKey)) == null ? void 0 : _a.nextLevelFnKeys;
          if (next) {
            isAdd ? n$2(next, fnKey) : t$1(next, fnKey);
          }
        });
      }
      function ensureHMRRunWell() {
        if (g$1()) {
          REACTIVE_META.delActive();
          const { FNKEY_HOOK_CTX_MAP } = getFnScope();
          FNKEY_HOOK_CTX_MAP.forEach((item) => {
            item.isExpired = true;
          });
        }
      }
      function markFnKey(fnOrObj, scopeType, fnKey) {
        const fnKeyStr = fnKey || genFnKey(scopeType);
        if (w$2(fnOrObj)) {
          fnOrObj[FN_KEY] = fnKeyStr;
        } else {
          injectHeluxProto(fnOrObj);
          fnOrObj.__proto__[FN_KEY] = fnKeyStr;
        }
        return fnKeyStr;
      }
      function getFnKey(fnOrObj) {
        if (w$2(fnOrObj)) {
          return fnOrObj[FN_KEY] || "";
        }
        if (E$2(fnOrObj)) {
          return fnOrObj.__proto__[FN_KEY] || "";
        }
        return "";
      }
      function getFnCtx(fnKey) {
        const map = getCtxMap(fnKey);
        return map.get(fnKey);
      }
      function getSafeFnCtx(fnKey) {
        return getCtxMap(fnKey).get(fnKey) || fakeFnCtx;
      }
      function getFnCtxByObj(obj) {
        const fnKey = getFnKey(obj);
        return getFnCtx(fnKey) || null;
      }
      function getRunningFn() {
        const { runningFnKey, depKeys, fixedDepKeys, runningSharedKey, isIgnore, delPathAoa } = getFnScope();
        const fnCtx = !runningFnKey ? null : getFnCtx(runningFnKey);
        return { fnCtx, depKeys, fixedDepKeys, delPathAoa, isIgnore, runningSharedKey };
      }
      function hasRunningFn() {
        return getFnScope().runningFnKey;
      }
      var { ON_DATA_CHANGED, ON_SHARE_CREATED, ON_ERROR_OCCURED } = EVENT_NAME;
      var loadingTypes = [STATE_TYPE.GLOGAL_LOADING, STATE_TYPE.PRIVATE_LOADING];
      function addPlugin(plugin) {
        const { plugins, bus } = getRootCtx();
        plugins.push(plugin);
        const pluginCtx = {
          on: (evName, cb) => bus.on(evName, cb),
          onStateChanged: (cb) => bus.on(ON_DATA_CHANGED, cb)
        };
        plugin.install(pluginCtx);
      }
      function emitDataChanged(internal, mutateCtx) {
        const { bus } = getRootCtx();
        if (bus.canEmit(ON_DATA_CHANGED)) {
          const { from, desc, payloadArgs } = mutateCtx;
          const { forAtom, sharedKey, moduleName, snap, usefulName, stateType } = internal;
          let type;
          if (loadingTypes.includes(stateType)) {
            type = `${usefulName}/setState`;
          } else {
            type = `${usefulName}@${from || "Api"}/${desc}`;
          }
          bus.emit(ON_DATA_CHANGED, { forAtom, snap, sharedKey, moduleName, usefulName, type, payloadArgs });
        }
      }
      function emitShareCreated(internal) {
        const { bus } = getRootCtx();
        if (bus.canEmit(ON_SHARE_CREATED)) {
          const { forAtom, snap, sharedKey, moduleName, usefulName } = internal;
          const type = `${usefulName}@FactoryApi/createShared`;
          bus.emit(ON_SHARE_CREATED, { forAtom, snap, sharedKey, moduleName, usefulName, type });
        }
      }
      function emitPluginEvent(internal, evName, data) {
        const { bus } = getRootCtx();
        if (!bus.canEmit(evName)) {
          return false;
        }
        const { sharedKey, moduleName } = internal;
        bus.emit(evName, { moduleName, sharedKey, data });
        return true;
      }
      function emitErr(internal, err) {
        if (!emitPluginEvent(internal, ON_ERROR_OCCURED, { err })) {
          console.warn("found uncaught error, sugguest add a plugin to handle this error");
          console.error(err);
        }
      }
      function fmtDepKeys(depKeys, prefixModuleName = true, spliter = KEY_SPLITER) {
        return depKeys.map((key) => {
          const [skey, restStr] = key.split("/");
          const keys = restStr.split(KEY_SPLITER);
          const prefix = prefixModuleName ? `${getInternalByKey(Number(skey)).usefulName}/` : "";
          return `${prefix}${keys.join(spliter)}`;
        });
      }
      var logMap = /* @__PURE__ */ new Map();
      var cbTypes = {
        WATCH: "1",
        MUTATE: "2"
      };
      var cbTips = {
        [cbTypes.WATCH]: "watch",
        [cbTypes.MUTATE]: "mutate fn or task"
      };
      function newLog(sn = 0) {
        return { sn, descs: [], errs: [], timer: null, cycle: [] };
      }
      function dcErr(usefulName, descs, runDesc) {
        const err = new Error(`DEAD_CYCLE: module(${usefulName}) found mutate fn(${runDesc}) in these dead cycle fns [${descs.join(",")}]`);
        err.cause = "DeadCycle";
        err.data = descs;
        return err;
      }
      function clearDcLog(usefulName) {
        logMap.delete(usefulName);
      }
      function depKeyDcError(internal, fnCtx, depKeys, cbType) {
        const tip = cbTips[cbType];
        const { desc, task, fn, isFake } = fnCtx.subFnInfo;
        const descStr = desc ? `(${desc})` : "";
        const dcInfo = `DEAD_CYCLE: found reactive object in ${tip}${descStr} cb is changing module(${internal.usefulName})'s some of these dep keys(${fmtDepKeys(depKeys, false, ".")}), it will cause a infinity loop call!`;
        const targetFn = isFake ? fnCtx.fn : task || fn;
        return {
          err: new Error(`[only-dev-mode alert] ${dcInfo}`),
          tipFn: () => console.error(` ${dcInfo} open the stack to find the below fn: 
`, targetFn)
        };
      }
      function probeFnDeadCycle(internal, sn, desc) {
        if (internal && desc) {
          const { usefulName } = internal;
          const log = R$1(logMap, usefulName, newLog(sn));
          if (log.sn !== sn) {
            log.descs = [];
            log.errs = [];
          }
          const { descs } = log;
          if (descs.length > 1 && descs[0] === desc) {
            const listCopy = descs.slice();
            log.cycle = listCopy;
            descs.length = 0;
            throw dcErr(usefulName, listCopy, desc);
          }
          n$2(descs, desc);
        }
      }
      function alertDepKeyDeadCycleErr(internal, dcErrorInfo) {
        dcErrorInfo.tipFn();
        S$2(dcErrorInfo.err, {
          logErr: false,
          throwErr: false,
          alertErr: internal.alertDeadCycleErr
        });
      }
      function probeDepKeyDeadCycle(internal, fnCtx, changedDepKeys) {
        const { depKeys, subFnInfo } = fnCtx;
        let shortArr = fnCtx.depKeys;
        let longArr = changedDepKeys;
        if (depKeys.length > changedDepKeys.length) {
          shortArr = changedDepKeys;
          longArr = depKeys;
        }
        let foundDc = false;
        if (e$1(shortArr, longArr)) {
          const cbType = subFnInfo.desc ? cbTypes.MUTATE : cbTypes.WATCH;
          const dcErrorInfo = depKeyDcError(internal, fnCtx, changedDepKeys, cbType);
          alertDepKeyDeadCycleErr(internal, dcErrorInfo);
          fnCtx.dcErrorInfo = dcErrorInfo;
          foundDc = true;
        }
        return foundDc;
      }
      function inDeadCycle(usefulName, desc) {
        const log = logMap.get(usefulName);
        if (!log || !log.cycle.includes(desc)) {
          return { isIn: false, cycle: [] };
        }
        return { isIn: true, cycle: log.cycle };
      }
      function analyzeErrLog(usefulName, err, alertErr = true) {
        const log = logMap.get(usefulName);
        if (!log) return;
        const { timer, errs } = log;
        errs.push(err);
        timer && clearTimeout(timer);
        log.timer = setTimeout(() => {
          let targetErr = null;
          for (const err2 of errs) {
            if (!targetErr) {
              targetErr = err2;
            } else if (err2.data.length > targetErr.data.length) {
              targetErr = err2;
            }
          }
          if (targetErr) {
            S$2(targetErr, { alertErr });
          }
          errs.length = 0;
        }, 0);
      }
      var { REACTIVE: REACTIVE2 } = FROM;
      var metas = /* @__PURE__ */ new Map();
      function canFlush(meta) {
        return !!(meta && !meta.expired && meta.modified);
      }
      function flushModified(meta, desc) {
        const { key, from } = meta;
        meta.expired = true;
        REACTIVE_META.del(key);
        return meta.finish(null, { from, desc: desc || meta.desc, payloadArgs: meta.payloadArgs });
      }
      function reactiveDesc(sharedState, desc) {
        const sharedKey = getSharedKey(sharedState);
        desc && REACTIVE_DESC.set(sharedKey, desc);
        return sharedKey;
      }
      function flush(sharedState, desc) {
        const sharedKey = getSharedKey(sharedState);
        innerFlush(sharedKey, desc);
      }
      function flushActive() {
        const meta = REACTIVE_META.current();
        if (meta.isTop) {
          innerFlush(meta.sharedKey, meta.desc);
        }
      }
      function innerFlush(sharedKey, desc) {
        const meta = metas.get(sharedKey);
        if (canFlush(meta)) {
          flushModified(meta, desc);
        }
      }
      function markExpired(sharedKey) {
        const meta = metas.get(sharedKey) || fakeReativeMeta;
        meta.expired = true;
      }
      function nextTickFlush(sharedKey) {
        const meta = metas.get(sharedKey) || fakeReativeMeta;
        meta.modified = true;
        meta.nextTickFlush();
      }
      function buildMeta(internal, options) {
        const { from = REACTIVE2 } = options;
        const { finish, draftRoot } = internal.setStateFactory({ isReactive: true, from, handleCbReturn: false, enableDep: true });
        const latestMeta = newReactiveMeta(draftRoot, options, finish);
        const { sharedKey } = internal;
        latestMeta.key = getReactiveKey();
        latestMeta.sharedKey = sharedKey;
        latestMeta.nextTickFlush = () => {
          const { hasFlushTask } = latestMeta;
          if (!hasFlushTask) {
            latestMeta.hasFlushTask = true;
            Promise.resolve().then(() => {
              const desc = REACTIVE_DESC.currentOnce(sharedKey);
              innerFlush(sharedKey, desc);
            });
          }
        };
        return latestMeta;
      }
      function getReactiveInfo(internal, options, forAtom) {
        const { sharedKey } = internal;
        const { insKey = 0, from, desc, payloadArgs } = options;
        let meta = metas.get(sharedKey) || fakeReativeMeta;
        if (meta.expired) {
          meta = buildMeta(internal, { isTop: true, from, desc, payloadArgs });
          metas.set(sharedKey, meta);
          REACTIVE_META.set(meta.key, meta);
          meta.fnKey = TRIGGERED_WATCH.current();
        } else {
          meta.from = from;
          meta.desc = desc;
          meta.payloadArgs = payloadArgs;
        }
        REACTIVE_META.markUsing(meta.key);
        meta.onRead = insKey ? options.onRead : void 0;
        meta.insKey = insKey;
        const { draft } = meta;
        return { val: forAtom ? draft.val : draft, meta };
      }
      function buildReactive(internal, options) {
        let draftRoot = {};
        let draft = {};
        const { rawState, deep, forAtom, isPrimitive: isPrimitive2, sharedKey } = internal;
        if (G$1(deep)) {
          const innerData = {
            [SHARED_KEY]: sharedKey,
            [IS_ATOM]: forAtom
          };
          const set = (forAtom2, key, value) => {
            const { val } = getReactiveInfo(internal, options, forAtom2);
            val[key] = value;
            return true;
          };
          const get2 = (forAtom2, key, innerData2) => {
            const innerVal = innerData2[key];
            if (innerVal !== void 0) {
              return innerVal;
            }
            const { val, meta } = getReactiveInfo(internal, options, forAtom2);
            if (REACTIVE_META_KEY === key) {
              return meta;
            }
            return val[key];
          };
          draftRoot = new Proxy(rawState, {
            set: (t2, key, value) => set(false, key, value),
            get: (t2, key) => get2(false, key, innerData)
          });
          draft = draftRoot;
          if (forAtom) {
            const subInnerData = { ...innerData, [IS_ATOM]: false };
            draft = isPrimitive2 ? rawState.val : new Proxy(rawState.val, {
              set: (t2, key, value) => set(true, key, value),
              get: (t2, key) => get2(true, key, subInnerData)
            });
          }
        } else {
          draftRoot = rawState;
          draft = rawState.val;
        }
        return { draftRoot, draft };
      }
      var { USER_STATE } = STATE_TYPE;
      function tryGetLoc(moduleName, endCutIdx = 8) {
        let loc = "";
        if (g$1() && moduleName) {
          try {
            throw new Error("loc");
          } catch (err) {
            const arr = err.stack.split("\n");
            const item1 = arr[1] || "";
            if (item1.includes("webpack-internal") || item1.includes("/node_modules/")) {
              loc = arr.slice(0, 16).join(" -> ");
            } else {
              const pureArr = arr.map((codeLoc) => {
                return codeLoc.substring(0, codeLoc.indexOf("(")).trim();
              });
              loc = pureArr.slice(4, endCutIdx).join(" -> ");
            }
          }
        }
        return loc;
      }
      function getDepKeyInfo(depKey) {
        const [sharedKey, rest] = depKey.split("/");
        const keyPath = rest.split(KEY_SPLITER);
        return { sharedKey: Number(sharedKey), keyPath, depKey };
      }
      function getRootValDepKeyInfo(internal) {
        const { sharedKey, forAtom } = internal;
        const suffix = forAtom ? "/val" : "";
        const keyPath = forAtom ? ["val"] : [];
        return { depKey: `${sharedKey}${suffix}`, keyPath, sharedKey };
      }
      function getDepKeyByPath(fullKeyPath, sharedKey) {
        try {
          return B$1(fullKeyPath.join(KEY_SPLITER), sharedKey);
        } catch (err) {
          console.warn("found Symbol key in your path :", fullKeyPath);
          return `${sharedKey}`;
        }
      }
      function isValChanged(internal, depKey) {
        const { snap, prevSnap, stateType } = internal;
        if (USER_STATE !== stateType) {
          return true;
        }
        const { keyPath } = getDepKeyInfo(depKey);
        try {
          const currVal = M$1(snap, keyPath);
          const prevVal = M$1(prevSnap, keyPath);
          return currVal !== prevVal;
        } catch (err) {
          return true;
        }
      }
      function createImmut(obj, onOperate) {
        if (O$2()) {
          return immut(obj, { onOperate, compareVer: true });
        }
        return createOb(obj, {
          get(target, key) {
            const val = target[key];
            const op = newOpParams(key, val, { isChanged: false, parentKeyPath: [] });
            onOperate(op);
            return val;
          }
        });
      }
      function wrapPartial(forAtom, val) {
        if (val === void 0) return;
        if (forAtom) return { val };
        if (E$2(val)) return val;
      }
      function runPartialCb(forAtom, mayCb, draft) {
        const val = !w$2(mayCb) ? mayCb : mayCb(draft);
        return wrapPartial(forAtom, val);
      }
      function callOnRead(opParams, onRead) {
        let { value } = opParams;
        if (onRead) {
          onRead(opParams);
          const { replacedValue, isReplaced } = opParams.getReplaced();
          if (isReplaced) {
            value = replacedValue;
          }
        }
        return value;
      }
      function isArrLike(parentType) {
        return [ARR, MAP].includes(parentType);
      }
      function isArrLikeVal(val) {
        return Array.isArray(val) || d$2(val);
      }
      var { isObject: isDict, getDataType } = limuUtils;
      function ensureBool(mayBool, defaultBool) {
        return typeof mayBool === "boolean" ? mayBool : defaultBool;
      }
      function diffVal(internal, depKey) {
        const scope = getSharedScope();
        const { COMPARE_MAP } = scope;
        let result = COMPARE_MAP.get(depKey);
        if (result !== void 0) {
          return result;
        }
        if (internal.sharedKeyStr === depKey) {
          return scope.isStateChanged;
        }
        result = isValChanged(internal, depKey);
        COMPARE_MAP.set(depKey, result);
        if (result) {
          scope.isStateChanged = true;
        }
        return result;
      }
      function hasChangedNode(internal, depKeys, depKey) {
        if (depKeys.includes(depKey) && diffVal(internal, depKey)) {
          return true;
        }
        let subValChanged = false;
        for (const storedDepKey of depKeys) {
          if (storedDepKey.startsWith(depKey) && diffVal(internal, storedDepKey)) {
            subValChanged = true;
          }
        }
        return subValChanged;
      }
      function clearDiff() {
        const scope = getSharedScope();
        scope.COMPARE_MAP.clear();
        scope.isStateChanged = false;
      }
      function markIgnore(isIgnore = true) {
        const fnScope = getFnScope();
        fnScope.isIgnore = isIgnore;
      }
      function recordFnDepKeys(inputDepKeys, options) {
        const { fnCtx: runningFnCtx, depKeys, fixedDepKeys, isIgnore } = getRunningFn();
        const fnCtx = options.specificCtx || runningFnCtx;
        if (!fnCtx) {
          DEPS_CB.current()(inputDepKeys);
          return;
        }
        const { fnKey, scopeType } = fnCtx;
        if (RUN_AT_SERVER && scopeType === "hook") {
          return;
        }
        const { DEPKEY_FNKEYS_MAP, SKEY_FNKEYS_MAP } = getFnScope();
        const { belongCtx, sharedKey, kv = {} } = options;
        if (sharedKey) {
          n$2(fnCtx.depSharedKeys, sharedKey);
        }
        if (runningFnCtx && belongCtx) {
          runningFnCtx.isFirstLevel = false;
          if (belongCtx.isAsync) {
            runningFnCtx.isAsync = true;
          }
          const fnKey2 = belongCtx.fnKey;
          n$2(fnCtx.prevLevelFnKeys, fnKey2);
          n$2(belongCtx.nextLevelFnKeys, runningFnCtx.fnKey);
        }
        inputDepKeys.forEach((depKey) => {
          if (PROTO_KEY === depKey || isIgnore) {
            return;
          }
          if (runningFnCtx) {
            n$2(depKeys, depKey);
            if (runningFnCtx.forBlock) {
              const val = kv[depKey];
              if (Array.isArray(val)) {
                n$2(fixedDepKeys, depKey);
              }
            }
          }
          const fnKeys = R$1(DEPKEY_FNKEYS_MAP, depKey, []);
          n$2(fnKeys, fnKey);
          const [sKey] = depKey.split("/");
          const fnKeysOfSkey = R$1(SKEY_FNKEYS_MAP, sKey, []);
          n$2(fnKeysOfSkey, fnKey);
        });
      }
      function ensureFnDepData(fnCtx) {
        if (fnCtx) {
          fnCtx.depKeys.forEach((depKey) => recordFnDepKeys([depKey], { specificCtx: fnCtx }));
        }
      }
      function recoverDep(fnCtx) {
        const { FNKEY_HOOK_CTX_MAP, UNMOUNT_INFO_MAP } = getFnScope();
        if (RUN_AT_SERVER) return;
        const { fnKey } = fnCtx;
        FNKEY_HOOK_CTX_MAP.set(fnKey, fnCtx);
        opUpstreamFnKey(fnCtx, true);
        let info = UNMOUNT_INFO_MAP.get(fnKey);
        if (info) {
          info.c = 2;
        } else {
          info = { c: 1, t: Date.now(), prev: 0 };
          UNMOUNT_INFO_MAP.set(fnKey, info);
        }
        const { c: mountCount } = info;
        if (mountCount === 2) {
          const fnCtx2 = getFnCtx(fnKey);
          ensureFnDepData(fnCtx2);
        }
      }
      function getDepSharedStateFeature(fn) {
        let feature = "";
        fn.depSharedKeys.forEach((key) => {
          var _a;
          const ver = ((_a = getInternalByKey(key)) == null ? void 0 : _a.ver) || 0;
          feature += `${ver}_`;
        });
        return feature;
      }
      function getDepFnStats(internal, depKey, runCountStats, isSharedKey = false) {
        const { DEPKEY_FNKEYS_MAP, SKEY_FNKEYS_MAP } = getFnScope();
        const map = isSharedKey ? SKEY_FNKEYS_MAP : DEPKEY_FNKEYS_MAP;
        const fnKeys = map.get(depKey) || [];
        const firstLevelFnKeys = [];
        const asyncFnKeys = [];
        fnKeys.forEach((fnKey) => {
          const fnCtx = getFnCtx(fnKey);
          if (!fnCtx) return;
          if (hasChangedNode(internal, fnCtx.depKeys, depKey)) {
            if (fnCtx.isFirstLevel) {
              firstLevelFnKeys.push(fnKey);
            }
            if (fnCtx.isAsync && fnCtx.fnType === DERIVE) {
              asyncFnKeys.push(fnKey);
            }
            const count = runCountStats[fnKey];
            if (count === void 0) {
              runCountStats[fnKey] = 1;
            } else if (!isSharedKey) {
              runCountStats[fnKey] = count + 1;
            }
          }
        });
        return { firstLevelFnKeys, asyncFnKeys };
      }
      function delFnDep(fnCtx) {
        delFnDepData(fnCtx);
        opUpstreamFnKey(fnCtx);
      }
      function delHistoryUnmoutFnCtx() {
        const { FNKEY_HOOK_CTX_MAP } = getFnScope();
        if (FNKEY_HOOK_CTX_MAP.size >= SIZE_LIMIT) {
          const now = Date.now();
          FNKEY_HOOK_CTX_MAP.forEach((fnCtx) => {
            const { mountStatus, createTime, fnKey } = fnCtx;
            if ([NOT_MOUNT, UNMOUNT].includes(mountStatus) && now - createTime > EXPIRE_MS) {
              delFnDep(fnCtx);
              FNKEY_HOOK_CTX_MAP.delete(fnKey);
            }
          });
        }
      }
      function buildFnCtx(specificProps) {
        const base = newFnCtx();
        return Object.assign(base, specificProps || {});
      }
      function markFnEnd() {
        const fnScope = getFnScope();
        const { runningFnKey } = fnScope;
        if (!runningFnKey) return [];
        const fnCtx = getFnCtx(runningFnKey);
        let targetKeys = [];
        if (fnCtx) {
          const { depKeys: afterRunDepKeys, fixedDepKeys, delPathAoa, runningSharedKey } = fnScope;
          const { depKeys } = fnCtx;
          const dict = {};
          afterRunDepKeys.forEach((k2) => dict[k2] = 1);
          afterRunDepKeys.forEach((depKey) => {
            const matched = D$1(dict, depKey);
            if (matched && matched !== depKey) {
              delete dict[matched];
            }
          });
          fixedDepKeys.forEach((k2) => dict[k2] = 1);
          const validDepKeys = Object.keys(dict);
          validDepKeys.forEach((depKey) => n$2(depKeys, depKey));
          delPathAoa.forEach((pathArr) => {
            const len = pathArr.length;
            for (let i2 = 1; i2 <= len; i2++) {
              const toDel = getDepKeyByPath(pathArr.slice(0, i2), runningSharedKey);
              t$1(depKeys, toDel);
            }
          });
          targetKeys = depKeys.slice();
        }
        fnScope.runningFnKey = "";
        fnScope.depKeys = [];
        fnScope.fixedDepKeys = [];
        fnScope.delPathAoa = [];
        fnScope.runningSharedKey = 0;
        return targetKeys;
      }
      function markFnStart(fnKey, sharedKey) {
        const fnScope = getFnScope();
        fnScope.runningFnKey = fnKey;
        fnScope.runningSharedKey = sharedKey;
        fnScope.isIgnore = false;
      }
      function registerFn(fn, options) {
        const { specificProps, fnCtxBase } = options;
        const { scopeType } = specificProps;
        const fnKey = markFnKey(fn, scopeType);
        const props = { fn, fnKey, ...specificProps };
        const fnCtx = fnCtxBase ? Object.assign(fnCtxBase, props) : buildFnCtx(props);
        if (scopeType === "static" || !RUN_AT_SERVER) {
          getCtxMap(scopeType).set(fnKey, fnCtx);
        }
        return fnCtx;
      }
      function delFnCtx(fnCtx) {
        var _a;
        const { FNKEY_HOOK_CTX_MAP, UNMOUNT_INFO_MAP } = getFnScope();
        const { fnKey } = fnCtx;
        delFnDep(fnCtx);
        fnCtx.extra.deferedWatch = null;
        FNKEY_HOOK_CTX_MAP.delete(fnKey);
        if (((_a = UNMOUNT_INFO_MAP.get(fnKey)) == null ? void 0 : _a.c) === 2) {
          UNMOUNT_INFO_MAP.delete(fnKey);
        }
        delHistoryUnmoutFnCtx();
      }
      function shouldShowComputing(fnCtx) {
        const { DEPKEY_COMPUTING_FNKEYS_MAP } = getFnScope();
        const { prevLevelFnKeys, depKeys } = fnCtx;
        let ret = false;
        for (const depKey of depKeys) {
          const fnKeys = DEPKEY_COMPUTING_FNKEYS_MAP.get(depKey) || [];
          if (e$1(fnKeys, prevLevelFnKeys)) {
            ret = true;
            break;
          }
        }
        return ret;
      }
      function markComputing(fnKey, runCount = 0) {
        const fnCtx = getFnCtx(fnKey);
        if (!fnCtx) return;
        if (fnCtx.showLoading) {
          fnCtx.setLoading(true);
          fnCtx.updater();
        }
        if (runCount) {
          fnCtx.remainRunCount += runCount;
        }
      }
      var { MAY_TRANSFER: MAY_TRANSFER2 } = ASYNC_TYPE;
      function runWatch(fnCtx, options) {
        const { isFirstCall = false, triggerReasons = [], sn = 0, from, internal = fakeInternal2, desc, fromFnKey } = options;
        if (fnCtx.dcErrorInfo.err) {
          alertDepKeyDeadCycleErr(internal, fnCtx.dcErrorInfo);
          return;
        }
        if (fnCtx.fnKey === fromFnKey) {
          probeDepKeyDeadCycle(internal, fnCtx, fnCtx.depKeys);
          return;
        }
        if (fnCtx.forBlock || !fnCtx.checkDeadCycle) {
          return fnCtx.fn({ isFirstCall, triggerReasons, sn });
        }
        if (FROM.MUTATE === from) {
          probeFnDeadCycle(internal, sn, desc);
        }
        if (fnCtx.isRunning && probeDepKeyDeadCycle(internal, fnCtx, options.depKeys || [])) {
          return;
        }
        const rmeta = REACTIVE_META.current();
        if (rmeta.fnKey === fnCtx.fnKey && probeDepKeyDeadCycle(internal, fnCtx, rmeta.writeKeys)) {
          return;
        }
        innerFlush(rmeta.sharedKey, rmeta.desc);
        const isReactiveInCb = fnCtx.isRunning === true && rmeta.isTop;
        if (isReactiveInCb && probeDepKeyDeadCycle(internal, fnCtx, rmeta.writeKeys)) {
          return;
        }
        fnCtx.isRunning = true;
        TRIGGERED_WATCH.set(fnCtx.fnKey);
        const ret = fnCtx.fn({ isFirstCall, triggerReasons, sn });
        TRIGGERED_WATCH.del();
        const afterRunRmeta = REACTIVE_META.current();
        if (afterRunRmeta.isTop && afterRunRmeta.fnKey === fnCtx.fnKey && probeDepKeyDeadCycle(internal, fnCtx, afterRunRmeta.writeKeys)) {
          return;
        }
        if (ret && ret.task) {
          if (afterRunRmeta.from === FROM.MUTATE && probeDepKeyDeadCycle(internal, fnCtx, fnCtx.subFnInfo.writeKeys)) {
            return;
          }
        }
        fnCtx.isRunning = false;
        return ret;
      }
      function runDeps(deps, stateRoot, forAtom) {
        let state = stateRoot.val;
        if (!forAtom) {
          state = stateRoot;
        }
        const input = i$2(deps, { state, stateRoot, isAtom: forAtom });
        return { input, state, stateRoot };
      }
      function runFn(fnKey, options = {}) {
        const {
          isFirstCall = false,
          forceFn = false,
          forceTask = false,
          throwErr = false,
          triggerReasons = [],
          watchFnKeys = [],
          skipWatch = false,
          sn = 0,
          err,
          unbox = false,
          internal = fakeInternal2
        } = options;
        const fnCtx = getFnCtx(fnKey);
        const resultTuple = (err2 = null) => {
          if (err2 && throwErr) throw err2;
          const ctx2 = fnCtx || fakeFnCtx;
          return unbox ? [ctx2.result.val, err2] : [ctx2.result, err2];
        };
        if (!fnCtx) {
          return resultTuple(new Error(`not a valid watch or derive cb for key ${fnKey}`));
        }
        if (fnCtx.fnType === WATCH) {
          if (skipWatch) {
            return n$2(watchFnKeys, fnCtx.fnKey);
          }
          return runWatch(fnCtx, options);
        }
        const { isAsync, fn, task, isAsyncTransfer, forAtom, result, depKeys } = fnCtx;
        if (fnCtx.remainRunCount > 0) {
          fnCtx.remainRunCount -= 1;
        }
        const assignResult = (data) => {
          const dataVar = forAtom ? { val: data } : data;
          if (!fnCtx.returnUpstreamResult && dataVar) {
            Object.assign(fnCtx.result, dataVar);
          }
          fnCtx.shouldReplaceResult = true;
        };
        const triggerUpdate = () => {
          fnCtx.renderInfo.sn = sn;
          fnCtx.updater();
        };
        const updateAndDrillDown = (options2) => {
          const { data, err: err2 = null } = options2;
          if (!err2) {
            assignResult(data);
            if (isFirstCall) {
              if (isAsync && fnCtx.status.loading && !shouldShowComputing(fnCtx)) {
                fnCtx.setLoading(false, err2);
              }
            } else if (fnCtx.remainRunCount === 0) {
              fnCtx.setLoading(false, err2);
            }
          } else {
            fnCtx.setLoading(false, err2);
          }
          triggerUpdate();
          const runOptions = { isFirstCall, sn, triggerReasons, err: err2, watchFnKeys, skipWatch };
          fnCtx.nextLevelFnKeys.forEach((key) => {
            runFn(key, runOptions);
          });
        };
        const prevResult = forAtom ? result : result.val;
        const { deps, isStateAtom } = fnCtx;
        const { input, state, stateRoot } = runDeps(deps, fnCtx.stateRoot, isStateAtom);
        const fnParams = { isAtom: fnCtx.isStateAtom, state, stateRoot, isFirstCall, prevResult, triggerReasons, input, sn };
        const shouldRunFn = !isAsync || forceFn || isAsync && !task;
        if (shouldRunFn) {
          const result2 = fn(fnParams);
          updateAndDrillDown({ data: result2 });
          return resultTuple();
        }
        if (isAsync && isFirstCall) {
          fnCtx.nextLevelFnKeys.forEach((key) => markComputing(key, 0));
        }
        if (isAsyncTransfer) {
          updateAndDrillDown({ err });
          return resultTuple();
        }
        if (fnCtx.asyncType === MAY_TRANSFER2) {
          const result2 = fn(fnParams);
          updateAndDrillDown({ data: result2 });
          return resultTuple();
        }
        if (task) {
          let del = s$2;
          if (isFirstCall) {
            depKeys.forEach((depKey) => putComputingFnKey(depKey, fnKey));
            del = () => depKeys.forEach((depKey) => delComputingFnKey(depKey, fnKey));
          } else if (forceTask) {
            fnCtx.nextLevelFnKeys.forEach((fnKey2) => markComputing(fnKey2));
          }
          return Promise.resolve(() => {
            const result2 = task(fnParams);
            if (!A$2(result2)) {
              S$2("ERR_NON_FN: derive task arg should be async function!", { throwErr });
              return null;
            }
            return result2;
          }).then((wrap) => wrap()).then((data) => {
            del();
            updateAndDrillDown({ data });
            return resultTuple();
          }).catch((err2) => {
            del();
            updateAndDrillDown({ err: err2 });
            if (throwErr) throw err2;
            emitErr(internal, err2);
            return resultTuple(err2);
          });
        }
        return resultTuple(err);
      }
      function rerunDeriveFn(result, options) {
        const fnCtx = getFnCtxByObj(result);
        if (!fnCtx) {
          throw new Error("[Helux]: not a derived result");
        }
        return runFn(fnCtx.fnKey, { ...options || {} });
      }
      function runDerive(result, throwErr) {
        return rerunDeriveFn(result, { forceFn: true, throwErr });
      }
      function runDeriveTask(result, throwErr) {
        return Promise.resolve(rerunDeriveFn(result, { forceTask: true, throwErr }));
      }
      function innerRunDerive(result, throwErr) {
        return rerunDeriveFn(result, { forceFn: true, throwErr, unbox: true });
      }
      function innerRunDeriveTask(result, throwErr) {
        return Promise.resolve(rerunDeriveFn(result, { forceTask: true, throwErr, unbox: true }));
      }
      function getDeriveLoading(result) {
        const fnCtx = getFnCtxByObj(result);
        if (fnCtx) {
          return fnCtx.status;
        }
        return { loading: false, err: null, ok: true };
      }
      function getArrIndexKey(confKey, fullKey) {
        if (confKey === fullKey) {
          return confKey;
        }
        const restStr = fullKey.substring(confKey.length + 1);
        const keys = restStr.split(KEY_SPLITER);
        return `${confKey}${KEY_SPLITER}${keys[0]}`;
      }
      function recordArrKey(arrKeys, depKey) {
        const parentDepKey = o$3(arrKeys, depKey);
        if (parentDepKey) return;
        n$2(arrKeys, depKey);
      }
      var cutCache = /* @__PURE__ */ new Map();
      function cutDepKeyByStop(depKeyInfo, options) {
        let isKeyRerord = false;
        const { depKey, keyPath, sharedKey } = depKeyInfo;
        const { stopDepInfo, level1ArrKeys, recordCb } = options;
        const cutKey = cutCache.get(depKey);
        if (cutKey) {
          recordCb(cutKey);
          return true;
        }
        const { keys: stopDepKeys, isArrDict, depth, arrKeyStopDcit, stopArrDep } = stopDepInfo;
        const mayArrKeyPrefix = o$3(level1ArrKeys, depKey);
        const isGtDepth = keyPath.length > depth;
        if (isGtDepth || mayArrKeyPrefix) {
          let newDepKey = "";
          let cutDepth = depth;
          if (mayArrKeyPrefix) {
            cutDepth = depth + 1;
            const notStopByRule = arrKeyStopDcit[mayArrKeyPrefix] === false;
            if (notStopByRule) ;
            else if (stopArrDep) {
              if (isGtDepth) {
                newDepKey = getDepKeyByPath(keyPath.slice(0, cutDepth), sharedKey);
              } else {
                newDepKey = getArrIndexKey(mayArrKeyPrefix, depKey);
              }
            }
          }
          if (!newDepKey) {
            newDepKey = getDepKeyByPath(keyPath.slice(0, cutDepth), sharedKey);
          }
          if (!mayArrKeyPrefix) {
            cutCache.set(depKey, newDepKey);
          }
          recordCb(newDepKey);
          return true;
        }
        const sharedKeyStr = String(sharedKey);
        for (const confKey of stopDepKeys) {
          if (!depKey.startsWith(confKey) || confKey === sharedKeyStr) {
            continue;
          }
          const isArr = isArrDict[confKey];
          const recordKey = isArr ? getArrIndexKey(confKey, depKey) : confKey;
          if (!isArr) {
            cutCache.set(depKey, recordKey);
          }
          recordCb(recordKey);
          isKeyRerord = true;
          break;
        }
        return isKeyRerord;
      }
      function recordBlockDepKey(depKeys, result) {
        const blockScope = getBlockScope();
        const { runningKey } = blockScope;
        if (runningKey) {
          const { KEY_DYNAMIC_CTX_MAP, KEY_CTX_MAP, isDynamic } = blockScope;
          const ctxMap = isDynamic ? KEY_DYNAMIC_CTX_MAP : KEY_CTX_MAP;
          const blockCtx = ctxMap.get(runningKey);
          if (blockCtx) {
            const { results, depKeys: blockDepKeys } = blockCtx;
            if (result) {
              n$2(results, result);
            } else {
              depKeys.forEach((depKey) => n$2(blockDepKeys, depKey));
            }
          }
        }
      }
      function recordLastest(sharedKey, val, sharedState, depKey, keyPath, isDerivedResult2 = false, isDerivedAtom2 = false) {
        const scope = getBlockScope();
        scope.latest = { sharedKey, val, stateOrResult: sharedState, depKey, keyPath, isDerivedResult: isDerivedResult2, isDerivedAtom: isDerivedAtom2 };
      }
      function getLastest() {
        const scope = getBlockScope();
        return scope.latest;
      }
      function getBlockCtxMap(isDynamic) {
        const { KEY_DYNAMIC_CTX_MAP, KEY_CTX_MAP } = getBlockScope();
        const map = isDynamic ? KEY_DYNAMIC_CTX_MAP : KEY_CTX_MAP;
        return map;
      }
      function cannotSet() {
        x$1("changing shared state is invalid");
        return true;
      }
      function handleHeluxKey(isRoot, forAtom, sharedKey, key, value) {
        if (key === IS_ATOM) {
          return isRoot ? forAtom : false;
        }
        if (key === SHARED_KEY) {
          return sharedKey;
        }
        return value;
      }
      function handleCustomKey(opParams, forAtom, sharedKey) {
        opParams.replaceValue(handleHeluxKey(opParams.keyPath.length === 0, forAtom, sharedKey, opParams.key, opParams.value));
      }
      function buildSharedState(options) {
        let sharedRoot = {};
        const { rawState, sharedKey, forAtom, onRead, isPrimitive: isPrimitive2, stopDepth } = options;
        const collectDep2 = (keyPath, val) => {
          const depKey = getDepKeyByPath(keyPath, sharedKey);
          recordFnDepKeys([depKey], { sharedKey, kv: { [depKey]: val } });
          recordBlockDepKey([depKey]);
          recordLastest(sharedKey, val, sharedRoot, depKey, keyPath);
        };
        if (HAS_PROXY) {
          sharedRoot = immut(rawState, {
            customKeys: OP_KEYS,
            onOperate: (params) => {
              const { isBuiltInFnKey, isCustom } = params;
              if (isCustom) {
                return handleCustomKey(params, forAtom, sharedKey);
              }
              if (!isBuiltInFnKey) {
                const { fullKeyPath } = params;
                const rawVal = callOnRead(params, onRead);
                collectDep2(fullKeyPath, rawVal);
              }
            },
            compareVer: true
          });
        } else {
          const toShallowProxy = (obj, keyLevel, parentKeyPath) => createDpOb(obj, {
            set: cannotSet,
            get: (target, key) => {
              const value = target[key];
              if (OP_KEYS.includes(key)) {
                return handleHeluxKey(keyLevel === 1, forAtom, sharedKey, key, value);
              }
              const opParams = newOpParams(key, value, { isChanged: false, parentKeyPath });
              if (keyLevel < stopDepth && isDict(value)) {
                return toShallowProxy(value, keyLevel + 1, opParams.fullKeyPath);
              }
              const rawVal = callOnRead(opParams, onRead);
              collectDep2(opParams.fullKeyPath, rawVal);
              return rawVal;
            }
          });
          sharedRoot = toShallowProxy(rawState, 1, []);
        }
        let sharedState = sharedRoot;
        if (forAtom) {
          if (isPrimitive2) {
            sharedState = rawState.val;
          } else {
            sharedState = createOb(rawState, {
              set: cannotSet,
              get: (t2, k2) => sharedRoot.val[k2]
            });
          }
        }
        mapSharedState(sharedKey, sharedRoot);
        return { sharedRoot, sharedState };
      }
      var GLOBAL_EMPTY = null;
      function getGlobalEmpty() {
        return GLOBAL_EMPTY;
      }
      function initGlobalEmpty(apiCtx, createFn) {
        const ctx2 = getRootCtx();
        let shared = ctx2.globalEmpty;
        if (!shared) {
          const { stateRoot } = createFn({ apiCtx, rawState: {}, forGlobal: true, stateType: STATE_TYPE.GLOGAL_EMPTY });
          const internal = getInternal(stateRoot);
          ctx2.globalEmpty = stateRoot;
          ctx2.globalEmptyInternal = internal;
        }
        GLOBAL_EMPTY = shared;
        return shared;
      }
      function getGlobalIdInsKeys(id) {
        const { GID_INSKEYS_MAP } = getFnScope();
        return R$1(GID_INSKEYS_MAP, id, []);
      }
      function getGlobalEmptyInternal() {
        return getRootCtx().globalEmptyInternal;
      }
      function mapGlobalId(id, insKey) {
        if (!id || RUN_AT_SERVER) return;
        const keys = getGlobalIdInsKeys(id);
        n$2(keys, insKey);
      }
      function delGlobalId(id, insKey) {
        if (!id) return;
        const keys = getGlobalIdInsKeys(id);
        t$1(keys, insKey);
      }
      function recoverDep2(insCtx) {
        const { UNMOUNT_INFO_MAP } = getInsScope();
        const { insKey, readMap, internal } = insCtx;
        internal.mapInsCtx(insCtx, insKey);
        let info = UNMOUNT_INFO_MAP.get(insKey);
        if (info) {
          info.c = 2;
          info.prev = insKey - 1;
        } else {
          info = { c: 1, t: Date.now(), prev: 0 };
          UNMOUNT_INFO_MAP.set(insKey, info);
        }
        const { c: mountCount } = info;
        if (mountCount === 2) {
          Object.keys(readMap).forEach((key) => {
            internal.recordDep(key, insKey);
          });
        }
      }
      function clearDep(insCtx) {
        const { readMap, insKey, internal } = insCtx;
        Object.keys(readMap).forEach((key) => internal.delDep(key, insKey));
        internal.delInsCtx(insKey);
      }
      function updateDep(insCtx) {
        const { canCollect, isFirstRender, currentDepKeys } = insCtx;
        if (!canCollect) {
          if (isFirstRender) {
            insCtx.depKeys = currentDepKeys.slice();
          }
          return;
        }
        insCtx.depKeys = currentDepKeys.slice();
      }
      function resetDepHelpData(insCtx) {
        const { canCollect } = insCtx;
        if (!canCollect) {
          return;
        }
        insCtx.readMap = {};
        insCtx.delReadMap = {};
        insCtx.depKeys = insCtx.currentDepKeys.slice();
        insCtx.currentDepKeys.length = 0;
      }
      function collectDep(insCtx, info, options) {
        const { parentType, rawVal } = options;
        const isValArrLike = isArrLikeVal(rawVal);
        if (isValArrLike) {
          recordArrKey(insCtx.internal.level1ArrKeys, info.depKey);
        }
        insCtx.recordDep(info, parentType, isValArrLike);
      }
      function getInsDeps(insCtx, isCurrent) {
        const { depKeys, currentDepKeys, fixedDepKeys } = insCtx;
        const dynamic = isCurrent ? currentDepKeys : depKeys;
        return dynamic.concat(fixedDepKeys);
      }
      function runInsUpdater(insCtx) {
        if (!insCtx) return;
        const { updater, mountStatus, createTime } = insCtx;
        if (mountStatus === NOT_MOUNT) {
          if (Date.now() - createTime > EXPIRE_MS) {
            clearDep(insCtx);
          } else {
            insCtx.needEFUpdate = true;
          }
          return;
        }
        updater();
      }
      function attachInsProxyState(insCtx) {
        const { internal, isReactive, insKey } = insCtx;
        const { rawState, isDeep, sharedKey, onRead, forAtom } = internal;
        if (isDeep) {
          const onOperate = (opParams) => {
            if (RUN_AT_SERVER) return;
            const { isBuiltInFnKey, key } = opParams;
            if (isBuiltInFnKey) return;
            if (j$1(key)) {
              return handleCustomKey(opParams, forAtom, sharedKey);
            }
            const { fullKeyPath, keyPath, parentType } = opParams;
            const rawVal = callOnRead(opParams, onRead);
            if (!insCtx.canCollect) return;
            const depKey = getDepKeyByPath(fullKeyPath, sharedKey);
            const depKeyInfo = { depKey, keyPath: fullKeyPath, parentKeyPath: keyPath, sharedKey };
            collectDep(insCtx, depKeyInfo, { parentType, rawVal });
          };
          if (isReactive) {
            const { draft, draftRoot } = buildReactive(internal, { onRead: onOperate, insKey, from: "Reactive", desc: "mutate" });
            insCtx.proxyState = draftRoot;
            insCtx.proxyStateVal = draft;
          } else {
            insCtx.proxyState = immut(rawState, { onOperate, compareVer: true });
          }
        } else {
          insCtx.proxyState = createOb(rawState, {
            set: () => {
              x$1("changing shared state is invalid");
              return true;
            },
            get: (target, key) => {
              if (RUN_AT_SERVER) return;
              const value = target[key];
              if (j$1(key)) {
                return handleHeluxKey(true, forAtom, sharedKey, key, value);
              }
              const rawVal = callOnRead(newOpParams(key, value, { isChanged: false, parentKeyPath: [] }), onRead);
              if (!insCtx.canCollect) return;
              const depKey = B$1(key, sharedKey);
              const parentType = isDict(target) ? DICT : OTHER;
              collectDep(insCtx, { depKey, keyPath: [key], sharedKey }, { parentType, rawVal });
              return rawVal;
            }
          });
        }
      }
      function buildInsCtx(options) {
        const {
          updater,
          sharedState,
          id = "",
          globalId = "",
          collectType = "every",
          deps,
          pure = true,
          arrDep = true,
          isReactive = false
        } = options;
        const arrIndexDep = !arrDep ? true : options.arrIndexDep ?? true;
        const internal = getInternal(sharedState);
        if (!internal) {
          throw new Error("ERR_OBJ_NOT_SHARED: input object is not a result returned by share api");
        }
        const insKey = genInsKey();
        const { rawState, isDeep, ver, ruleConf, level1ArrKeys, forAtom, sharedKey, sharedKeyStr, snap } = internal;
        const { stopDepInfo } = ruleConf;
        const insCtx = {
          readMap: {},
          delReadMap: {},
          pure,
          depKeys: [],
          fixedDepKeys: [],
          currentDepKeys: [],
          isDeep,
          isReactive,
          insKey,
          internal,
          rawState,
          sharedState,
          sharedKey,
          proxyState: {},
          proxyStateVal: {},
          updater,
          mountStatus: NOT_MOUNT,
          renderStatus: RENDER_START,
          needEFUpdate: false,
          createTime: Date.now(),
          rootVal: null,
          ver,
          id,
          globalId,
          collectType,
          // 设定了 no，才关闭依赖收集功能，此时依赖靠 deps 函数提供
          canCollect: collectType !== "no",
          isFirstRender: true,
          subscribe: (cb) => {
            cb();
          },
          /** 记录一些需复用的中间生成数据 */
          extra: {},
          getDeps: () => getInsDeps(insCtx, true),
          renderInfo: {
            isAtom: forAtom,
            setDraft: internal.insSetDraft,
            time: Date.now(),
            sn: 0,
            snap,
            insKey,
            getDeps: () => getInsDeps(insCtx, true),
            // depKeys 的后续更新流程在 helpers/insDep.resetReadMap 和 updateDep 函数里，做了双保险备份
            getPrevDeps: () => getInsDeps(insCtx, false)
          },
          recordDep: (depKeyInfo, parentType, isValArrLike) => {
            let depKey = depKeyInfo.depKey;
            cutDepKeyByStop(depKeyInfo, {
              stopDepInfo,
              level1ArrKeys,
              recordCb: (key) => {
                depKey = key;
              }
            });
            const { renderStatus, fixedDepKeys } = insCtx;
            if (renderStatus === RENDER_END) {
              return;
            }
            const { readMap, insKey: insKey2, currentDepKeys, delReadMap } = insCtx;
            recordFnDepKeys([depKey], {});
            if (hasRunningFn()) {
              t$1(currentDepKeys, depKey);
              n$2(insCtx.fixedDepKeys, depKey);
            }
            const doRecord = () => {
              readMap[depKey] = 1;
              internal.recordDep(depKey, insKey2);
              if (!fixedDepKeys.includes(depKey)) {
                n$2(currentDepKeys, depKey);
              }
            };
            if (!readMap[depKey] && !delReadMap[depKey]) {
              const { parentKeyPath } = depKeyInfo;
              if (pure && parentType === DICT && parentKeyPath) {
                const parentDepKey = parentKeyPath.length ? getDepKeyByPath(parentKeyPath, sharedKey) : sharedKeyStr;
                if (readMap[parentDepKey]) {
                  delete readMap[parentDepKey];
                  delReadMap[parentDepKey] = 1;
                  t$1(currentDepKeys, parentDepKey);
                }
              }
              const isParentArrLike = isArrLike(parentType);
              if (isParentArrLike) {
                arrIndexDep && doRecord();
                return;
              }
              if (!isValArrLike || !isParentArrLike && arrDep) {
                doRecord();
              }
            }
          }
        };
        globalId && mapGlobalId(globalId, insKey);
        attachInsProxyState(insCtx);
        if (RUN_AT_SERVER) {
          return insCtx;
        }
        internal.mapInsCtx(insCtx, insKey);
        internal.recordId(id, insKey);
        internal.insCount += 1;
        if (internal.insCount === 1) {
          const { lifecycle } = internal;
          lifecycle.willMount();
          lifecycle.shouldCallMounted = true;
        }
        if (w$2(deps)) {
          const rootVal = forAtom ? insCtx.proxyState.val : insCtx.proxyState;
          const list = i$2(deps, rootVal);
          const fixedDepKeys = insCtx.getDeps().slice();
          if (list.includes(rootVal)) {
            fixedDepKeys.push(internal.rootValKey);
          }
          insCtx.fixedDepKeys = fixedDepKeys;
        }
        return insCtx;
      }
      function attachInsDerivedResult(fnCtx) {
        const { result, forAtom } = fnCtx;
        fnCtx.proxyResult = createOb(result, {
          set: () => {
            x$1("changing derived result is invalid");
            return false;
          },
          get: (target, resultKey) => {
            if (IS_DERIVED_ATOM === resultKey) {
              return forAtom;
            }
            if (RENDER_START === fnCtx.renderStatus && !RUN_AT_SERVER) {
              ensureFnDepData(fnCtx);
            }
            return result[resultKey];
          }
        });
      }
      function prepareTuple(insCtx) {
        const { proxyState, internal, renderInfo, canCollect, isReactive } = insCtx;
        const { sharedKey, sharedKeyStr, insSetState, forAtom } = internal;
        renderInfo.snap = internal.snap;
        renderInfo.time = Date.now();
        const rootVal = forAtom ? proxyState.val : proxyState;
        if (insCtx.isFirstRender) {
          insCtx.rootVal = rootVal;
          INS_CTX.set(insCtx.rootVal, insCtx);
        }
        if (!forAtom && canCollect) {
          insCtx.recordDep({ depKey: sharedKeyStr, keyPath: [], sharedKey }, DICT);
        }
        const finalRoot = isReactive ? proxyState : rootVal;
        return [finalRoot, insSetState, renderInfo];
      }
      function checkAtom(mayAtom, forAtom) {
        if (forAtom && !isAtom(mayAtom)) {
          throw new Error("useAtom only accept atom");
        }
      }
      function checkStateVer(insCtx) {
        const {
          ver,
          internal: { ver: dataVer }
        } = insCtx;
        if (ver === dataVer) {
          return;
        }
        insCtx.ver = dataVer;
        attachInsProxyState(insCtx);
      }
      function recoverInsCtx(insCtx) {
        insCtx.mountStatus = MOUNTED;
        const { id, globalId, insKey } = insCtx;
        insCtx.internal.recordId(id, insKey);
        mapGlobalId(globalId, insKey);
        recoverDep2(insCtx);
      }
      function delInsCtx(insCtx) {
        insCtx.mountStatus = UNMOUNT;
        const { id, globalId, insKey, internal } = insCtx;
        internal.delId(id, insKey);
        internal.insCount -= 1;
        if (internal.insCount === 0) {
          internal.lifecycle.willUnmount();
        }
        delGlobalId(globalId, insKey);
        clearDep(insCtx);
      }
      function isSharedKeyChanged(insCtx, sharedState) {
        const curSharedKey = getInternal(sharedState).sharedKey;
        return insCtx.internal.sharedKey !== curSharedKey;
      }
      function useSync(api, subscribe, getSnapshot, getServerSnapshot) {
        if (!getRootCtx().isRootRender) {
          return;
        }
        try {
          const getServerSnapshotFn = getServerSnapshot || getSnapshot;
          api.react.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshotFn);
        } catch (err) {
          console.error(err);
        }
      }
      var nullInsCtx = null;
      function useInsCtx(apiCtx, sharedState, options) {
        const { hookImpl, react } = apiCtx;
        const updater = hookImpl.useForceUpdate();
        const ctxRef = react.useRef({ ctx: nullInsCtx });
        let insCtx = ctxRef.current.ctx;
        if (!insCtx || isSharedKeyChanged(insCtx, sharedState)) {
          insCtx = buildInsCtx({ updater, sharedState, ...options });
          ctxRef.current.ctx = insCtx;
        }
        return insCtx;
      }
      function useClearEffect(apiCtx, insCtx) {
        apiCtx.react.useEffect(() => {
          const { lifecycle } = insCtx.internal;
          if (lifecycle.shouldCallMounted) {
            lifecycle.mounted();
            lifecycle.shouldCallMounted = false;
          }
          insCtx.isFirstRender = false;
          INS_CTX.del(insCtx.rootVal);
          if (insCtx.collectType === "first") {
            insCtx.canCollect = false;
          }
          if (insCtx.needEFUpdate) {
            insCtx.needEFUpdate = false;
            insCtx.updater();
          }
          recoverInsCtx(insCtx);
          return () => {
            delInsCtx(insCtx);
          };
        }, [insCtx]);
      }
      function useCollectDep(apiCtx, sharedState, insCtx) {
        insCtx.renderStatus = RENDER_START;
        resetDepHelpData(insCtx);
        useSync(apiCtx, insCtx.subscribe, () => getInternal(sharedState).snap);
        apiCtx.react.useEffect(() => {
          insCtx.renderStatus = RENDER_END;
          insCtx.isFirstRender = false;
          updateDep(insCtx);
        });
      }
      function useAtomSimpleLogic(apiCtx, sharedState, options = {}) {
        const insCtx = useInsCtx(apiCtx, sharedState, options);
        useSync(apiCtx, insCtx.subscribe, () => getInternal(sharedState).snap);
        useClearEffect(apiCtx, insCtx);
        return insCtx;
      }
      function useAtomLogic(apiCtx, sharedState, options = {}) {
        const { forAtom } = options;
        checkAtom(sharedState, forAtom);
        const insCtx = useInsCtx(apiCtx, sharedState, options);
        useCollectDep(apiCtx, sharedState, insCtx);
        useClearEffect(apiCtx, insCtx);
        checkStateVer(insCtx);
        const tuple = prepareTuple(insCtx);
        return { tuple, insCtx };
      }
      function useAtom(apiCtx, sharedState, options = {}) {
        const { tuple } = useAtomLogic(apiCtx, sharedState, options);
        return tuple;
      }
      function useAtomX(apiCtx, sharedState, options = {}) {
        const { tuple } = useAtomLogic(apiCtx, sharedState, options);
        const [state, setState, renderInfo] = tuple;
        return { ...renderInfo, state, setState };
      }
      var { TASK } = ASYNC_TYPE;
      var { STATIC, HOOK } = SCOPE_TYPE;
      function checkResult(fnCtx, result, forAtom) {
        if (!forAtom) {
          if (!E$2(result) || A$2(result)) {
            throw new Error("ERR_NON_OBJ: derive,deriveAsync expect result to be a plain object");
          }
        }
        const { isAsync, isAsyncTransfer } = fnCtx;
        if (isAsync && !isAsyncTransfer) {
          const fnKey = getFnKey(result);
          const sharedKey = getSharedKey(result);
          if (fnKey && fnCtx.fnKey !== fnKey || sharedKey) {
            throw new Error(
              "ERR_INVALID_CALL: derive,deriveAsync can not transfer another derived result or shared state, it will cause wrong result"
            );
          }
        }
      }
      function attachStaticProxyResult(fnCtx, forAtom) {
        const proxyResult = createOb(fnCtx.result, {
          set: () => {
            x$1("changing derived result is invalid");
            return false;
          },
          get: (target, key) => {
            if (key === IS_DERIVED_ATOM) {
              return forAtom;
            }
            const val = target[key];
            recordFnDepKeys(fnCtx.depKeys, { belongCtx: fnCtx });
            recordBlockDepKey(fnCtx.depKeys, proxyResult);
            recordLastest(0, val, proxyResult, "", [key], true, forAtom);
            return val;
          }
        });
        fnCtx.proxyResult = proxyResult;
        return proxyResult;
      }
      function transferDep(fnCtx, options) {
        const { result, isUpstream } = options;
        const upstreamFnCtx = getFnCtxByObj(result);
        if (upstreamFnCtx) {
          fnCtx.depKeys = r$2(fnCtx.depKeys.concat(upstreamFnCtx.depKeys));
          n$2(upstreamFnCtx.nextLevelFnKeys, fnCtx.fnKey);
          n$2(fnCtx.prevLevelFnKeys, upstreamFnCtx.fnKey);
          fnCtx.isFirstLevel = false;
          isUpstream == null ? void 0 : isUpstream();
        }
      }
      function initDeriveFn(options) {
        const {
          scopeType = STATIC,
          fnCtxBase,
          // 目前仅 hook 函数支持转移异步结果
          isAsyncTransfer = false,
          asyncType = TASK,
          returnUpstreamResult,
          runAsync = true,
          forAtom = false,
          immediate
        } = options;
        if (!w$2(options.fn)) {
          throw new Error("ERR_NON_FN: derive need fn arg!");
        }
        const { fn = f$2, deps = f$2, task, stateRoot = {} } = options;
        const isStateAtom = isAtom(stateRoot);
        const isAsync = options.isAsync ?? w$2(task);
        const showLoading = options.showLoading ?? isAsync;
        const fnCtx = registerFn(fn, {
          specificProps: {
            forAtom,
            scopeType,
            stateRoot,
            isStateAtom,
            fnType: DERIVE,
            task,
            deps,
            isAsync,
            asyncType,
            isAsyncTransfer,
            showLoading
          },
          fnCtxBase
        });
        markFnStart(fnCtx.fnKey, 0);
        const { input, state } = runDeps(deps, stateRoot, isStateAtom);
        input.forEach((result2) => transferDep(fnCtx, { result: result2 }));
        const fnParams = {
          isFirstCall: true,
          prevResult: null,
          triggerReasons: [],
          input,
          sn: 0,
          state,
          stateRoot,
          isAtom: isStateAtom
        };
        let result = fn(fnParams);
        markFnEnd();
        const upstreamFnCtx = getFnCtxByObj(result);
        if (forAtom && !upstreamFnCtx) {
          result = { val: result, z__is_atom_result__: true };
        }
        const curFnKey = fnCtx.fnKey;
        checkResult(fnCtx, result);
        transferDep(fnCtx, {
          result,
          isUpstream: () => {
            fnCtx.returnUpstreamResult = returnUpstreamResult ?? !isAsync;
          }
        });
        ensureFnDepData(fnCtx);
        if (!fnCtx.returnUpstreamResult) {
          markFnKey(result, scopeType, curFnKey);
        }
        const canRunTask = runAsync && asyncType === TASK && (immediate ?? !options.fn);
        if (task && canRunTask) {
          runFn(curFnKey, { isFirstCall: true, sn: fnCtx.renderInfo.sn + 1, throwErr: true }).then((data) => {
            checkResult(fnCtx, data[0], forAtom);
          }).catch((err) => S$2(err));
        }
        fnCtx.result = result;
        if (scopeType === HOOK && shouldShowComputing(fnCtx)) {
          fnCtx.setLoading(true);
        }
        if (fnCtx.returnUpstreamResult) {
          fnCtx.proxyResult = result;
        } else {
          attachStaticProxyResult(fnCtx, forAtom);
        }
        return fnCtx;
      }
      function createDeriveLogic(fn, options) {
        const fnItem2 = w$2(fn) ? { fn } : fn || {};
        const fnCtx = initDeriveFn({ ...options || {}, ...fnItem2 });
        return fnCtx;
      }
      function derive(deriveFn, stateRoot) {
        const fnCtx = createDeriveLogic(deriveFn, { forAtom: true, stateRoot });
        return fnCtx.proxyResult;
      }
      function deriveDict(deriveFn, stateRoot) {
        const fnCtx = createDeriveLogic(deriveFn, { stateRoot });
        return fnCtx.proxyResult;
      }
      function defineDeriveTask(deps) {
        return (options) => ({ ...options, deps });
      }
      function defineDeriveFnItem(fnItem2) {
        return fnItem2;
      }
      var InvalidInput = "ERR_NOT_DERIVED_RESULT: useDerived only accept derived result";
      var NotDerivedAtom = "ERR_NOT_ATOM_RESULT: useDerivedAtom only accept derived atom";
      function isInputChanged(fnCtx, storedInput, curInput) {
        if (fnCtx.isExpired) {
          fnCtx.isExpired = false;
          return true;
        }
        if (w$2(curInput)) {
          return false;
        }
        return curInput !== storedInput;
      }
      function ensureHotReload(fnCtx) {
        delFnCtx(fnCtx);
        fnCtx.depKeys.length = 0;
        fnCtx.prevLevelFnKeys.length = 0;
        fnCtx.renderInfo.sn += 1;
      }
      function genDerivedResult(deriveCtx, options) {
        const { result, forAtom, showLoading } = options;
        const { fnCtx, input, deriveFn } = deriveCtx;
        let isCtxChanged = false;
        if (deriveFn) {
          const isChanged = isInputChanged(fnCtx, input, result);
          if (!isChanged) {
            return;
          }
          isCtxChanged = true;
          ensureHotReload(fnCtx);
        }
        deriveCtx.input = result;
        const upstreamFnCtx = getFnCtxByObj(result);
        if (!upstreamFnCtx) {
          throw new Error(InvalidInput);
        }
        if (forAtom && !isDerivedAtom(result)) {
          throw new Error(NotDerivedAtom);
        }
        deriveCtx.deriveFn = () => upstreamFnCtx.result;
        createDeriveLogic(
          { fn: () => upstreamFnCtx.result, deps: () => [], task: async () => upstreamFnCtx.result },
          {
            isAsync: upstreamFnCtx.isAsync,
            scopeType: SCOPE_TYPE.HOOK,
            fnCtxBase: fnCtx,
            isAsyncTransfer: true,
            runAsync: false,
            returnUpstreamResult: true,
            forAtom,
            asyncType: ASYNC_TYPE.MAY_TRANSFER,
            showLoading
          }
        );
        attachInsDerivedResult(fnCtx);
        if (isCtxChanged) {
          fnCtx.updater();
        }
      }
      function useFnCtx(apiCtx, options) {
        const { result, forAtom } = options;
        const { hookImpl, react } = apiCtx;
        const updater = hookImpl.useForceUpdate();
        const { current: deriveCtx } = react.useRef({ input: result, deriveFn: null, fnCtx: null });
        if (!deriveCtx.fnCtx) {
          deriveCtx.fnCtx = buildFnCtx({ updater, scopeType: SCOPE_TYPE.HOOK, forAtom });
        }
        const fnCtx = deriveCtx.fnCtx;
        fnCtx.renderStatus = RENDER_START;
        genDerivedResult(deriveCtx, options);
        return fnCtx;
      }
      function useReplace(apiCtx, fnCtx) {
        if (fnCtx.shouldReplaceResult) {
          attachInsDerivedResult(fnCtx);
          fnCtx.shouldReplaceResult = false;
        }
        useSync(apiCtx, fnCtx.subscribe, () => getDepSharedStateFeature(fnCtx));
        apiCtx.react.useEffect(() => {
          fnCtx.renderStatus = RENDER_END;
        });
      }
      function useFnCtxEffect(apiCtx, fnCtx) {
        apiCtx.react.useEffect(() => {
          fnCtx.mountStatus = MOUNTED;
          recoverDep(fnCtx);
          return () => {
            delFnCtx(fnCtx);
          };
        }, [fnCtx]);
      }
      function useDerivedSimpleLogic(apiCtx, options) {
        const fnCtx = useFnCtx(apiCtx, options);
        useSync(apiCtx, fnCtx.subscribe, () => getDepSharedStateFeature(fnCtx));
        useFnCtxEffect(apiCtx, fnCtx);
        return fnCtx;
      }
      function useDerivedLogic(apiCtx, options) {
        const fnCtx = useFnCtx(apiCtx, options);
        useReplace(apiCtx, fnCtx);
        useFnCtxEffect(apiCtx, fnCtx);
        return fnCtx;
      }
      function useDerived(api, result, options) {
        const fnCtx = useDerivedLogic(api, { result, ...options || {} });
        const { proxyResult, status, renderInfo } = fnCtx;
        const resultForComp = isDerivedAtom(result) ? proxyResult.val : proxyResult;
        return [resultForComp, status, renderInfo];
      }
      function checkShared(sharedStateOrKey, options) {
        const { forAtom, label, strict = false } = options || {};
        let internal;
        if (typeof sharedStateOrKey === "number") {
          internal = getInternalByKey(sharedStateOrKey);
        } else {
          internal = getInternal(sharedStateOrKey);
        }
        if (!internal && sharedStateOrKey) {
          const rMeta = sharedStateOrKey[REACTIVE_META_KEY];
          internal = getInternalByKey(rMeta == null ? void 0 : rMeta.sharedKey);
        }
        let prefix = label ? `[[${label}]] err:` : "err:";
        if (!internal) {
          if (strict) {
            S$2(`${prefix} not a valid shared or atom`, { throwErr: true });
          } else {
            return null;
          }
        }
        if (forAtom !== void 0) {
          if (forAtom && !internal.forAtom) {
            S$2(`${prefix} expect a shared but recived a atom`, { throwErr: true });
          }
          if (!forAtom && internal.forAtom) {
            S$2(`${prefix} expect a atom but recived a shared`, { throwErr: true });
          }
        }
        return internal;
      }
      function checkSharedStrict(sharedStateOrKey, options) {
        return checkShared(sharedStateOrKey, { ...options || {}, strict: true });
      }
      function updateIns(insCtxMap, insKey, sn) {
        const insCtx = insCtxMap.get(insKey);
        if (insCtx) {
          insCtx.renderInfo.sn = sn;
          runInsUpdater(insCtx);
        }
      }
      function execDepFns(opts) {
        const { mutateCtx, internal } = opts;
        const { ids, globalIds, depKeys, triggerReasons, isFirstCall, from, sn, desc, fnKey: fromFnKey } = mutateCtx;
        const { key2InsKeys, id2InsKeys, insCtxMap, rootValKey } = internal;
        let dirtyInsKeys = [];
        let dirtyGlobalInsKeys = [];
        let dirtyFnKeys = [];
        let dirtyAsyncFnKeys = [];
        const runCountStats = {};
        if (isFirstCall) {
          const depKeys2 = markFnEnd();
          FN_DEP_KEYS.set(depKeys2);
        }
        const findDirtyFnKeys = (key, forSharedKey = false) => {
          const { firstLevelFnKeys, asyncFnKeys } = getDepFnStats(internal, key, runCountStats, forSharedKey);
          dirtyFnKeys = dirtyFnKeys.concat(firstLevelFnKeys);
          dirtyAsyncFnKeys = dirtyAsyncFnKeys.concat(asyncFnKeys);
        };
        const analyzeDepKey = (key) => {
          if (!diffVal(internal, key)) {
            return;
          }
          const insKeys = key2InsKeys[key] || [];
          const validInsKeys = [];
          for (const insKey of insKeys) {
            if (dirtyInsKeys.includes(insKey)) {
              continue;
            }
            const insCtx = insCtxMap.get(insKey);
            if (!insCtx) {
              continue;
            }
            const depKeys2 = insCtx.getDeps();
            if (depKeys2[0] === rootValKey) {
              if (diffVal(internal, rootValKey)) {
                validInsKeys.push(insKey);
              }
              continue;
            }
            if (hasChangedNode(internal, depKeys2, key)) {
              validInsKeys.push(insKey);
            }
          }
          dirtyInsKeys = dirtyInsKeys.concat(validInsKeys);
          findDirtyFnKeys(key);
        };
        depKeys.forEach((k2) => analyzeDepKey(k2));
        if (!depKeys.includes(rootValKey)) {
          analyzeDepKey(rootValKey);
        }
        findDirtyFnKeys(rootValKey, true);
        clearDiff();
        ids.forEach((id) => {
          dirtyInsKeys = dirtyInsKeys.concat(id2InsKeys[id] || []);
        });
        globalIds.forEach((id) => {
          getGlobalIdInsKeys(id).forEach((insKey) => n$2(dirtyGlobalInsKeys, insKey));
        });
        dirtyInsKeys = r$2(dirtyInsKeys);
        dirtyFnKeys = r$2(dirtyFnKeys);
        dirtyAsyncFnKeys = r$2(dirtyAsyncFnKeys);
        dirtyAsyncFnKeys.forEach((fnKey) => markComputing(fnKey, runCountStats[fnKey]));
        const watchFnKeys = [];
        const runOptions = { depKeys, sn, from, triggerReasons, watchFnKeys, skipWatch: true, internal, desc, isFirstCall, fromFnKey };
        dirtyFnKeys.forEach((fnKey) => runFn(fnKey, runOptions));
        const runOptionsOfWatch = { depKeys, sn, from, triggerReasons, internal, desc, isFirstCall, fromFnKey };
        watchFnKeys.forEach((fnKey) => runFn(fnKey, runOptionsOfWatch));
        dirtyInsKeys.forEach((insKey) => updateIns(insCtxMap, insKey, sn));
        if (dirtyGlobalInsKeys.length) {
          const globalInsCtxMap = getGlobalEmptyInternal().insCtxMap;
          dirtyGlobalInsKeys.forEach((insKey) => updateIns(globalInsCtxMap, insKey, sn));
        }
      }
      function getDepKeyDict(internal, deps, defaultDict) {
        if (deps === null) {
          return defaultDict;
        }
        if (!w$2(deps)) {
          return null;
        }
        const { sharedState, forAtom } = internal;
        const rootVal = forAtom ? sharedState.val : sharedState;
        const depKeyDict = {};
        DEPS_CB.set((keys) => depKeyDict[keys[0]] = 1);
        const depItems = i$2(deps, rootVal);
        DEPS_CB.del();
        if (depItems.includes(rootVal)) {
          return internal.key2InsKeys;
        }
        return depKeyDict;
      }
      function useGlobalForceUpdate(apiCtx, sharedState, presetDeps) {
        const internal = checkSharedStrict(sharedState);
        const [presetDepKeyDict] = apiCtx.react.useState(() => {
          return getDepKeyDict(internal, presetDeps, null);
        });
        return (overWriteDeps) => {
          const { insCtxMap, key2InsKeys } = internal;
          const depKeyDict = getDepKeyDict(internal, overWriteDeps, key2InsKeys) || presetDepKeyDict || key2InsKeys;
          const insKeyDict = {};
          Object.keys(depKeyDict).forEach((depKey) => {
            const insKeys2 = key2InsKeys[depKey] || [];
            insKeys2.forEach((insKey) => insKeyDict[insKey] = 1);
          });
          const insKeys = Object.keys(insKeyDict);
          if (insKeys.length) {
            internal.sn += 1;
            const nextSn = internal.sn;
            Object.keys(insKeyDict).forEach((insKey) => {
              updateIns(insCtxMap, Number(insKey), nextSn);
            });
          }
        };
      }
      function useGlobalId(apiCtx, globalId) {
        ensureGlobal(apiCtx);
        const globalEmpty = getGlobalEmpty();
        const insCtx = useAtomSimpleLogic(apiCtx, globalEmpty, { collectType: "no", globalId });
        return insCtx.renderInfo;
      }
      var { MUTATE, LOADING } = FROM;
      var { GLOGAL_LOADING, PRIVATE_LOADING } = STATE_TYPE;
      var { PRIVATE, GLOBAL } = RECORD_LOADING;
      var fakeExtra = {};
      var fakeLoading = {};
      var fakeRenderInfo = { time: 0, sn: 0, getDeps: a$3, getPrevDeps: a$3, insKey: 0, setDraft: f$2, isAtom: false };
      var fakeTuple = [createSafeLoading(fakeExtra, fakeLoading, MUTATE), f$2, fakeRenderInfo];
      function createLoading(createFn, options) {
        const { internal, apiCtx } = options;
        const { mutateFnDict, moduleName } = internal;
        const rawLoading = {};
        Object.keys(mutateFnDict).forEach((desc) => {
          rawLoading[desc] = { loading: false, err: null, ok: true };
        });
        const name = moduleName ? `${moduleName}@Loading` : "";
        const loadingCtx = createFn({ apiCtx, rawState: rawLoading, isLoading: true, stateType: PRIVATE_LOADING }, { moduleName: name });
        return loadingCtx.state;
      }
      var GLOBAL_LOADING = null;
      function getGlobalLoading() {
        return GLOBAL_LOADING;
      }
      function getGlobalLoadingInternal() {
        return getRootCtx().globalLoadingInternal;
      }
      function initGlobalLoading(apiCtx, createFn) {
        const ctx2 = getRootCtx();
        let shared = ctx2.globalLoading;
        if (!shared) {
          const { stateRoot } = createFn({ apiCtx, rawState: {}, stateType: GLOGAL_LOADING }, { moduleName: HELUX_GLOBAL_LOADING });
          const internal = getInternal(stateRoot);
          ctx2.globalLoadingInternal = internal;
          ctx2.globalLoading = stateRoot;
        }
        GLOBAL_LOADING = shared;
        return shared;
      }
      function getStatusKey(from, desc) {
        let descStr = desc;
        if (j$1(desc)) {
          descStr = desc.toString();
        }
        return `${from}>${descStr}`;
      }
      function setLoadStatus(internal, statusKey, status) {
        if (!statusKey) return;
        const { loadingInternal } = internal;
        loadingInternal.innerSetState(
          (draft) => {
            draft[statusKey] = status;
          },
          { from: LOADING }
        );
        if (status.err) {
          emitPluginEvent(internal, EVENT_NAME.ON_ERROR_OCCURED, { err: status.err });
          console.error(status.err);
        }
      }
      function createSafeLoading(extra, loadingObj, from) {
        let safeLoading = extra[from];
        if (!safeLoading) {
          safeLoading = createOb(loadingObj, {
            get(target, key) {
              const realKey = getStatusKey(from, key);
              return target[realKey] || { loading: false, ok: true, err: null };
            }
          });
          extra[from] = safeLoading;
        }
        return safeLoading;
      }
      function getLoadingInfo(createFn, options) {
        const { internal, from } = options;
        const { stateType, recordLoading } = internal;
        const isUserState = STATE_TYPE.USER_STATE === stateType;
        let loadingState = createSafeLoading(fakeExtra, {}, from);
        let loadingProxy = {};
        if (isUserState) {
          if (PRIVATE === recordLoading) {
            loadingProxy = internal.extra.loadingProxy;
            if (!loadingProxy) {
              loadingProxy = createLoading(createFn, options);
              internal.extra.loadingProxy = loadingProxy;
              internal.loadingInternal = getInternal(loadingProxy);
            }
            loadingState = createSafeLoading(internal.extra, loadingProxy, from);
          } else if (GLOBAL === recordLoading) {
            const globalLoadingInternal = getGlobalLoadingInternal();
            loadingProxy = getGlobalLoading();
            internal.loadingInternal = globalLoadingInternal;
            loadingState = createSafeLoading(globalLoadingInternal.extra, loadingProxy, from);
          } else {
            loadingProxy = getGlobalEmpty();
          }
        } else {
          loadingProxy = internal.sharedState;
          loadingState = createSafeLoading(internal.extra, loadingProxy, from);
        }
        return { loadingState, loadingProxy };
      }
      function getLoadingOpts(options, actionsOrMutate) {
        if (!isDict(actionsOrMutate)) {
          return options;
        }
        const keys = Object.keys(actionsOrMutate);
        if (!keys.length) {
          return options;
        }
        const oneItem = actionsOrMutate[keys[0]];
        if (!oneItem.__sharedKey) {
          return options;
        }
        return {
          ...options,
          internal: checkSharedStrict(oneItem.__sharedKey)
        };
      }
      function initLoadingCtx(createFn, options) {
        const { internal: leaderInternal, from, apiCtx } = options;
        const { stateType } = leaderInternal;
        const isUserState = STATE_TYPE.USER_STATE === stateType;
        getLoadingInfo(createFn, options);
        let useLoading = () => fakeTuple;
        if (isUserState) {
          useLoading = (actionsOrMutate) => {
            const targetOptions = getLoadingOpts(options, actionsOrMutate);
            const loadingProxy = getLoadingInfo(createFn, targetOptions).loadingProxy;
            const {
              insCtx: { proxyState, internal, extra, renderInfo }
            } = useAtomLogic(apiCtx, loadingProxy);
            return [createSafeLoading(extra, proxyState, from), internal.setState, renderInfo];
          };
        }
        return {
          useLoading,
          getLoading: (actionsOrMutate) => {
            const targetOptions = getLoadingOpts(options, actionsOrMutate);
            return getLoadingInfo(createFn, targetOptions).loadingState;
          }
        };
      }
      var { ACTION, MUTATE: MUTATE2 } = FROM;
      function getLoadingCtx(apiCtx, options) {
        ensureGlobal(apiCtx);
        const { target, from = "Mutate" } = options || {};
        let internal = getGlobalLoadingInternal();
        if (target) {
          internal = checkSharedStrict(target);
        }
        const { loadingProxy, loadingState } = getLoadingInfo(createSharedLogic, { apiCtx, internal, from });
        return { loadingProxy, loadingState, internal, from };
      }
      function useLoadingLogic(apiCtx, options) {
        const { loadingProxy, internal, from } = getLoadingCtx(apiCtx, options);
        const { proxyState, extra, renderInfo } = useAtomSimpleLogic(apiCtx, loadingProxy);
        return [createSafeLoading(extra, proxyState, from), internal.setState, renderInfo];
      }
      function getMutateLoading(apiCtx, target) {
        const { loadingProxy } = getLoadingCtx(apiCtx, { target, from: MUTATE2 });
        return loadingProxy;
      }
      function useMutateLoading(apiCtx, target) {
        return useLoadingLogic(apiCtx, { target, from: MUTATE2 });
      }
      function getActionLoading(apiCtx, target) {
        const { loadingProxy } = getLoadingCtx(apiCtx, { target, from: ACTION });
        return loadingProxy;
      }
      function useActionLoading(apiCtx, target) {
        return useLoadingLogic(apiCtx, { target, from: ACTION });
      }
      function useLocalForceUpdate(apiCtx) {
        const updater = apiCtx.hookImpl.useForceUpdate();
        return updater;
      }
      function useMutable(apiCtx, initialState) {
        const handleState = (partialStateOrCb, prevState) => {
          let final = null;
          if (w$2(partialStateOrCb)) {
            const draft = createDraft(prevState, { autoRevoke: false });
            const mayPartial = partialStateOrCb(draft);
            final = finishDraft(draft);
            if (E$2(mayPartial)) {
              Object.assign(final, mayPartial);
            }
          } else if (E$2(partialStateOrCb)) {
            final = { ...prevState, ...partialStateOrCb };
          }
          return final;
        };
        return apiCtx.hookImpl.useObjectLogic(initialState, handleState, true);
      }
      function getUserBus() {
        const { userBus } = getRootCtx();
        return userBus;
      }
      function emit(name, ...args) {
        const { userBus } = getRootCtx();
        userBus.emit(name, ...args);
      }
      function on(name, cb) {
        const { userBus } = getRootCtx();
        userBus.on(name, cb);
        return () => userBus.off(name, cb);
      }
      function useOnEvent(apiCtx, name, evCb, onBeforeMount) {
        const { useRef, useMemo, useEffect: useEffect2 } = apiCtx.react;
        const fnRef = useRef({ fn: evCb, wrap: null, onBeforeMount });
        fnRef.current.fn = useMemo(() => evCb, [evCb]);
        if (!fnRef.current.wrap) {
          fnRef.current.wrap = (...args) => {
            fnRef.current.fn(...args);
          };
          if (onBeforeMount) {
            getUserBus().on(name, fnRef.current.wrap);
          }
        }
        useEffect2(() => {
          const userBus = getUserBus();
          const { wrap, onBeforeMount: onBeforeMount2 } = fnRef.current;
          if (!onBeforeMount2) {
            userBus.on(name, wrap);
          }
          return () => userBus.off(name, wrap);
        }, [name, fnRef]);
      }
      function useReactive(apiCtx, sharedState, options = {}) {
        const forAtom = isAtom(sharedState);
        const { insCtx } = useAtomLogic(apiCtx, sharedState, { ...options, forAtom, isReactive: true });
        return [insCtx.proxyStateVal, insCtx.proxyState, insCtx.renderInfo];
      }
      function useReactiveX(apiCtx, sharedState, options = {}) {
        const [state, stateRoot, info] = useReactive(apiCtx, sharedState, options);
        return { ...info, state, stateRoot };
      }
      function useExposeService(apiCtx, srv, mayProps) {
        const props = E$2(mayProps) ? mayProps : {};
        apiCtx.react.useEffect(() => {
          const { srvRef } = props;
          w$2(srvRef) && srvRef(srv);
        }, []);
      }
      function useService(apiCtx, serviceImpl, props) {
        const srv = apiCtx.hookImpl.useStable(serviceImpl);
        useExposeService(apiCtx, srv, props);
        return srv;
      }
      function storeSrv(ref) {
        return (srv) => ref.current = srv;
      }
      function markSharedKeyOnState(rawState) {
        injectHeluxProto(rawState);
        const sharedKey = markSharedKey(rawState);
        return sharedKey;
      }
      function pureSetOptions(options) {
        if (!options) return {};
        const { desc, ids, globalIds } = options;
        return { desc, ids, globalIds };
      }
      function parseRawState(innerOptions) {
        const { forAtom = false } = innerOptions;
        let rawState = innerOptions.rawState;
        const isStateFn = w$2(rawState);
        let isPrimitive2 = false;
        if (forAtom) {
          rawState = isStateFn ? { val: rawState() } : { val: rawState };
          isPrimitive2 = !rawState.val || !v$1(rawState.val);
        } else {
          rawState = isStateFn ? rawState() : rawState;
          if (!E$2(rawState)) {
            throw new Error("ERR_NON_OBJ: pass an non-object to createShared!");
          }
          if (getSharedKey(rawState)) {
            throw new Error("ERR_ALREADY_SHARED: pass a shared object to createShared!");
          }
        }
        return { isPrimitive: isPrimitive2, rawState };
      }
      function parseMutateFn(fnItem2, inputDesc, checkDupDict) {
        let validItem = null;
        let desc = inputDesc || "";
        if (w$2(fnItem2) && fnItem2 !== f$2) {
          validItem = {
            [MUTATE_FN_ITEM]: 1,
            fn: fnItem2,
            deps: a$3,
            oriDesc: desc,
            onlyDeps: false,
            desc,
            depKeys: [],
            writeKeys: [],
            checkDeadCycle: void 0,
            watchKey: "",
            isFake: false,
            enabled: true,
            extraBound: { state: {}, stateRoot: {}, isAtom: false }
          };
        } else if (E$2(fnItem2)) {
          const { fn, desc: desc2, deps, task, immediate, checkDeadCycle, onlyDeps = false } = fnItem2;
          const descVar = inputDesc || desc2 || "";
          const fnVar = w$2(fn) ? fn : void 0;
          const taskVar = w$2(task) ? task : void 0;
          const depsVar = w$2(deps) ? deps : a$3;
          if (fn || task) {
            validItem = {
              [MUTATE_FN_ITEM]: 1,
              checkDeadCycle,
              fn: fnVar,
              watchKey: "",
              desc: descVar,
              oriDesc: descVar,
              deps: depsVar,
              task: taskVar,
              onlyDeps,
              immediate,
              depKeys: [],
              writeKeys: [],
              isFake: false,
              enabled: true,
              extraBound: { state: {}, stateRoot: {}, isAtom: false }
            };
          }
        }
        if (validItem && checkDupDict) {
          const { oriDesc } = validItem;
          if (!oriDesc || checkDupDict[oriDesc]) {
            validItem.desc = genFnKey(FROM.MUTATE);
          }
        }
        return validItem;
      }
      function parseMutate(mutate2, cachedDict, enabled = true) {
        const mutateFnDict = {};
        const checkDupDict = cachedDict || {};
        if (!mutate2) return mutateFnDict;
        const handleItem = (item, inputDesc) => {
          const stdFn = parseMutateFn(item, inputDesc, checkDupDict);
          if (stdFn) {
            stdFn.enabled = enabled;
            mutateFnDict[stdFn.desc] = stdFn;
            checkDupDict[stdFn.desc] = stdFn;
          }
        };
        if (Array.isArray(mutate2)) {
          if (mutate2.length === 1) {
            const singleFn = mutate2[0];
            const desc = (E$2(singleFn) ? singleFn.desc : "") || SINGLE_MUTATE;
            handleItem(mutate2[0], desc);
          } else {
            mutate2.forEach((item) => handleItem(item));
          }
        } else if (w$2(mutate2)) {
          handleItem(mutate2, SINGLE_MUTATE);
        } else if (E$2(mutate2)) {
          Object.keys(mutate2).forEach((key) => {
            handleItem(mutate2[key], key);
          });
        }
        return mutateFnDict;
      }
      function parseOptions(innerOptions, options = {}) {
        const { forAtom = false, forGlobal = false, stateType = STATE_TYPE.USER_STATE } = innerOptions;
        const { rawState, isPrimitive: isPrimitive2 } = parseRawState(innerOptions);
        const sharedKey = markSharedKeyOnState(rawState);
        const moduleName = options.moduleName || "";
        const alertDeadCycleErr = options.alertDeadCycleErr ?? g$1();
        const deep = options.deep ?? true;
        const checkDeadCycle = options.checkDeadCycle ?? true;
        const enableMutate = options.enableMutate ?? true;
        const recordLoading = options.recordLoading || RECORD_LOADING.PRIVATE;
        const rules = options.rules || [];
        const before = options.before || f$2;
        const mutate2 = options.mutate || f$2;
        const onRead = options.onRead || void 0;
        const stopArrDep = options.stopArrDep ?? true;
        const stopDepth = options.stopDepth || STOP_DEPTH;
        const sharedKeyStr = `${sharedKey}`;
        const rootValKey = forAtom ? `${sharedKey}/val` : sharedKeyStr;
        const usefulName = moduleName || sharedKeyStr;
        const loc = tryGetLoc(moduleName);
        const dict1 = parseMutate(mutate2, {}, enableMutate);
        const dict2 = parseMutate(options.mutateList || [], dict1, enableMutate);
        const mutateFnDict = Object.assign(dict1, dict2);
        return {
          /** TODO 未来可能支持 atom 对象销毁 */
          isDestroyed: false,
          alertDeadCycleErr,
          checkDeadCycle,
          rawState,
          sharedKey,
          sharedKeyStr,
          rootValKey,
          moduleName,
          usefulName,
          forAtom,
          forGlobal,
          loc,
          deep,
          rules,
          before,
          mutate: mutate2,
          mutateFnDict,
          onRead,
          enableMutate,
          stateType,
          recordLoading,
          stopArrDep,
          stopDepth,
          isPrimitive: isPrimitive2
        };
      }
      function parseRules(options) {
        const { rawState, sharedKey, rootValKey, deep, rules, stopDepth, stopArrDep, forAtom } = options;
        const idsDict = {};
        const globalIdsDict = {};
        const stopDepInfo = { keys: [], isArrDict: {}, arrKeyStopDcit: {}, depth: stopDepth, stopArrDep };
        const isArrDict = {};
        const isDeep = G$1(deep);
        rules.forEach((rule) => {
          const confKeys = [];
          const { when, ids = [], globalIds = [], stopDep } = rule;
          let state;
          if (isDeep) {
            let pervKey = "";
            state = immut(rawState, {
              onOperate: ({ fullKeyPath, value, isBuiltInFnKey }) => {
                if (isBuiltInFnKey) return;
                const confKey = getDepKeyByPath(fullKeyPath, sharedKey);
                if (pervKey && confKey.includes(pervKey)) {
                  confKeys.pop();
                }
                confKeys.push(confKey);
                isArrDict[confKey] = Array.isArray(value);
                pervKey = confKey;
              }
            });
          } else {
            state = createOb(rawState, {
              set: V$1,
              get: (target, key) => {
                const confKey = getDepKeyByPath([key], sharedKey);
                confKeys.push(confKey);
                const value = target[key];
                isArrDict[confKey] = Array.isArray(value);
                return value;
              }
            });
          }
          const stateNode = forAtom ? state.val : state;
          const result = i$2(when, stateNode);
          const pushId = (idsDict2, ids2, confKey) => {
            const idList = k$1(idsDict2, confKey, []);
            ids2.forEach((id) => n$2(idList, id));
          };
          const setRuleConf = (confKey) => {
            pushId(idsDict, ids, confKey);
            pushId(globalIdsDict, globalIds, confKey);
            let stopKeyDep;
            if (isArrDict[confKey]) {
              stopKeyDep = stopDep ?? STOP_ARR_DEP;
              stopDepInfo.arrKeyStopDcit[confKey] = stopKeyDep;
              stopDepInfo.isArrDict[confKey] = isArrDict[confKey];
            } else {
              stopKeyDep = stopDep ?? false;
            }
            if (stopKeyDep) {
              n$2(stopDepInfo.keys, confKey);
            }
          };
          confKeys.forEach(setRuleConf);
          if (result.includes(stateNode)) {
            setRuleConf(rootValKey);
          }
        });
        const hasIds = Object.keys(idsDict).length > 0;
        const hasGlobalIds = Object.keys(globalIdsDict).length > 0;
        return { hasIds, idsDict, hasGlobalIds, globalIdsDict, stopDepInfo };
      }
      function parseCreateMutateOpt(descOrOptions) {
        const { desc = SINGLE_MUTATE, strict = false, throwErr = false, extraArgs } = {};
        const optType = typeof descOrOptions;
        if (optType === "string") {
          return { desc: descOrOptions, strict, throwErr, extraArgs };
        }
        const finalOpt = { desc, strict, throwErr, extraArgs };
        if (descOrOptions && optType === "object" && !Array.isArray(descOrOptions)) {
          return { ...finalOpt, ...descOrOptions };
        }
        return finalOpt;
      }
      function parseWatchOptions(forEffect, options) {
        let deps = f$2;
        let immediate = false;
        if (w$2(options)) {
          deps = options;
        } else if (E$2(options)) {
          deps = options.deps || f$2;
          immediate = options.immediate ?? false;
        }
        immediate = forEffect ? true : immediate;
        return { immediate, deps };
      }
      function parseBlockOptions(options) {
        if (!options) return {};
        if (typeof options === "boolean") {
          return { enableStatus: options };
        }
        if (E$2(options)) {
          return options;
        }
        return {};
      }
      function putSharedToDep(list) {
        if (Array.isArray(list)) {
          list.forEach((sharedState) => {
            const insCtx = INS_CTX.current(sharedState);
            const internal = getInternal(sharedState) || (insCtx == null ? void 0 : insCtx.internal);
            if (internal) {
              const { depKey, sharedKey } = getRootValDepKeyInfo(internal);
              recordFnDepKeys([depKey], { sharedKey });
            }
            if (insCtx) {
              insCtx.recordDep(getRootValDepKeyInfo(internal));
            }
          });
        }
      }
      function innerWatch(forEffect, watchFn, options) {
        const { deps, immediate } = parseWatchOptions(forEffect, options);
        const fnCtx = createWatchLogic(watchFn, { scopeType: SCOPE_TYPE.STATIC, deps, immediate });
        return {
          run: (throwErr) => runFn(fnCtx.fnKey, { throwErr }),
          unwatch: () => delFnDep(fnCtx)
        };
      }
      function createWatchLogic(watchFn, options) {
        const { scopeType, fnCtxBase, immediate, deps = f$2, label = "watch", sharedState, forBlock } = options;
        if (!w$2(watchFn)) {
          throw new Error(`ERR_NON_FN: pass an non-function to ${label}!`);
        }
        const fnCtx = registerFn(watchFn, { specificProps: { scopeType, fnType: WATCH, forBlock }, fnCtxBase });
        markFnStart(fnCtx.fnKey, getSharedKey(sharedState));
        const list = deps() || [];
        putSharedToDep(list);
        if (immediate) {
          watchFn({ isFirstCall: true });
        }
        markFnEnd();
        return fnCtx;
      }
      function watch(watchFn, options) {
        return innerWatch(false, watchFn, options);
      }
      function watchEffect(watchFn, options) {
        return innerWatch(true, watchFn, options);
      }
      var { HOOK: HOOK2 } = SCOPE_TYPE;
      function useFnCtxEffect2(useEffect2, fnCtx) {
        useEffect2(() => {
          var _a, _b;
          fnCtx.mountStatus = MOUNTED;
          recoverDep(fnCtx);
          (_b = (_a = fnCtx.extra).deferedWatch) == null ? void 0 : _b.call(_a);
          return () => {
            delFnCtx(fnCtx);
          };
        }, [fnCtx]);
      }
      function useWatchLogic(apiCtx, options) {
        const { useRef, useState: useState2, useMemo, useEffect: useEffect2 } = apiCtx.react;
        const { label, forEffect, watchFn, watchOptions } = options;
        const fnRef = useRef({ fn: watchFn, wrap: null, fnKey: "", isDeferMarked: false });
        const [fnCtx] = useState2(() => buildFnCtx());
        fnRef.current.fn = useMemo(() => watchFn, [watchFn]);
        if (!fnRef.current.wrap) {
          const { deps, immediate } = parseWatchOptions(forEffect, watchOptions);
          fnRef.current.wrap = (params) => {
            if (fnCtx.mountStatus === MOUNTED) {
              fnRef.current.fn(params);
              return;
            }
            fnCtx.extra.deferedWatch = () => {
              if (fnRef.current.isDeferMarked) {
                fnRef.current.fn(params);
                return;
              }
              fnRef.current.isDeferMarked = true;
              markFnStart(fnRef.current.fnKey, 0);
              fnRef.current.fn(params);
              markFnEnd();
            };
          };
          const { fnKey } = createWatchLogic(fnRef.current.wrap, { scopeType: HOOK2, fnCtxBase: fnCtx, deps, immediate, label });
          fnRef.current.fnKey = fnKey;
        }
        useFnCtxEffect2(useEffect2, fnCtx);
      }
      function useWatchSimpleLogic(apiCtx, watchFn, options) {
        const { useState: useState2, useEffect: useEffect2 } = apiCtx.react;
        const [fnCtx] = useState2(() => buildFnCtx());
        if (fnCtx.fn === f$2) {
          const { manualDepKeys = [] } = options;
          const deps = () => manualDepKeys.map((depKey) => {
            const { sharedKey, keyPath } = getDepKeyInfo(depKey);
            const state = getSharedState(sharedKey);
            return M$1(state, keyPath);
          });
          createWatchLogic(watchFn, { scopeType: HOOK2, fnCtxBase: fnCtx, deps, forBlock: true });
        }
        useFnCtxEffect2(useEffect2, fnCtx);
      }
      function useWatch(apiCtx, watchFn, watchOptions) {
        useWatchLogic(apiCtx, { label: "useWatch", forEffect: false, watchFn, watchOptions });
      }
      function useWatchEffect(apiCtx, watchFn, watchOptions) {
        useWatchLogic(apiCtx, { label: "useWatchEffect", forEffect: true, watchFn, watchOptions });
      }
      function addMiddleware(mid) {
        const { middlewares } = getRootCtx();
        middlewares.push(mid);
      }
      function runMiddlewares(internal, draftRoot, draft, sn) {
        const { middlewares } = getRootCtx();
        if (!middlewares.length) {
          return;
        }
        const data = {};
        const { sharedKey, moduleName, forAtom } = internal;
        const setData = (key, value) => data[key] = value;
        const midCtx = { forAtom, draftRoot, draft, sharedKey, moduleName, setData, data, idx: 0, sn };
        middlewares.forEach((fn, idx) => {
          fn({ ...midCtx, idx });
        });
      }
      function commitState(opts) {
        const { state, internal, mutateCtx } = opts;
        const { rawState, isDeep, ver, snap } = internal;
        if (isDeep) {
          internal.prevSnap = ver === 0 ? { ...snap } : snap;
          internal.snap = state;
          Object.assign(rawState, state);
        } else {
          internal.snap = { ...rawState };
        }
        internal.ver += 1;
        internal.sn = mutateCtx.sn;
        execDepFns(opts);
      }
      var { MUTATE: MUTATE3 } = FROM;
      function putId(keyIds, options) {
        const { writeKey, ids, internal, opParams } = options;
        const { snap } = internal;
        const { fullKeyPath, value } = opParams;
        Object.keys(keyIds).forEach((confKey) => {
          if (writeKey.startsWith(confKey) && M$1(snap, fullKeyPath) !== value) {
            keyIds[confKey].forEach((id) => n$2(ids, id));
          }
        });
      }
      function handleOperate(opParams, opts) {
        var _a;
        const { isChanged, fullKeyPath, keyPath, parentType, value } = opParams;
        const { internal, mutateCtx } = opts;
        const { arrKeyDict, isReactive, readKeys, from } = mutateCtx;
        const { sharedKey } = internal;
        const arrLike = isArrLike(parentType);
        const currReactive = REACTIVE_META.current();
        if (opParams.op === "get") {
          if (arrLike) {
            arrKeyDict[getDepKeyByPath(keyPath, sharedKey)] = 1;
          }
          const depKey = getDepKeyByPath(fullKeyPath, sharedKey);
          readKeys[depKey] = 1;
          if (mutateCtx.enableDep) {
            if (currReactive.onRead) {
              currReactive.onRead(opParams);
            } else {
              const runingFnCtx = getRunningFn().fnCtx;
              if (runingFnCtx) {
                recordFnDepKeys([depKey], { sharedKey });
              }
              if (isReactive) {
                recordBlockDepKey([depKey]);
                recordLastest(sharedKey, value, internal.sharedState, depKey, fullKeyPath);
              }
              (_a = internal.onRead) == null ? void 0 : _a.call(internal, opParams);
            }
          }
          return;
        }
        if (MUTATE3 === from) {
          const { delPathAoa, fnCtx } = getRunningFn();
          fnCtx && delPathAoa.push(keyPath);
        }
        if (!isChanged) {
          return;
        }
        const { moduleName, ruleConf, level1ArrKeys } = internal;
        const { writeKeyPathInfo, ids, globalIds, writeKeys } = mutateCtx;
        const writeKey = getDepKeyByPath(fullKeyPath, sharedKey);
        if (currReactive.key) {
          if (currReactive.isTop) {
            n$2(currReactive.writeKeys, writeKey);
          } else if (currReactive.from === MUTATE3) {
            n$2(getSafeFnCtx(currReactive.fnKey).subFnInfo.writeKeys || [], writeKey);
          }
        }
        if (arrLike) {
          const arrKey2 = getDepKeyByPath(keyPath, sharedKey);
          writeKeyPathInfo[arrKey2] = { sharedKey, moduleName, keyPath };
          writeKeys[arrKey2] = 1;
        }
        const { hasIds, hasGlobalIds, stopDepInfo } = ruleConf;
        writeKeyPathInfo[writeKey] = { sharedKey, moduleName, keyPath: fullKeyPath };
        const arrKey = D$1(arrKeyDict, writeKey);
        if (arrKey) {
          writeKeys[arrKey] = 1;
        }
        const depKeyInfo = { sharedKey, keyPath: fullKeyPath, depKey: writeKey };
        if (!cutDepKeyByStop(depKeyInfo, {
          stopDepInfo,
          level1ArrKeys,
          recordCb: (key) => {
            writeKeys[key] = 1;
          }
        })) {
          writeKeys[writeKey] = 1;
        }
        if (hasIds) {
          putId(ruleConf.idsDict, { ids, writeKey, internal, opParams });
        }
        if (hasGlobalIds) {
          putId(ruleConf.globalIdsDict, { ids: globalIds, writeKey, internal, opParams });
        }
        if (isReactive) {
          nextTickFlush(sharedKey);
        } else {
          markExpired(sharedKey);
        }
      }
      function handleDict(draftNode, dict) {
        Object.keys(dict).forEach((key) => {
          draftNode[key] = dict[key];
        });
      }
      function getStateNode(sharedState, forAtom) {
        if (!forAtom) {
          return sharedState;
        }
        markIgnore(true);
        const state = sharedState.val;
        markIgnore(false);
        return state;
      }
      function handlePartial(opts) {
        const { partial, forAtom, draftRoot, draftNode } = opts;
        if (!partial) {
          return;
        }
        if (!forAtom) {
          isDict(partial) && handleDict(draftNode, partial);
          return;
        }
        const val = partial.val;
        if (isDict(draftNode)) {
          if (isDict(val)) {
            handleDict(draftNode, val);
          } else {
            console.warn("dict atom deny to handle a non-dict returned value!");
          }
          return;
        }
        draftRoot.val = val;
      }
      function beforeCommit(opts, draftRoot, moduleName) {
        const { internal, mutateCtx } = opts;
        const draft = getStateNode(draftRoot, internal.forAtom);
        const { from, sn, desc } = mutateCtx;
        internal.lifecycle.beforeCommit({ from, draftRoot, draft, desc, sn, moduleName });
        runMiddlewares(internal, draftRoot, draft, sn);
      }
      function execFinish(commitOpts, draftRoot, draftNode, partial) {
        const { mutateCtx, internal } = commitOpts;
        const { writeKeys, writeKeyPathInfo, handleCbReturn, sn, desc, from } = mutateCtx;
        const { forAtom, moduleName, lifecycle } = internal;
        if (handleCbReturn) {
          handlePartial({ partial, forAtom, draftRoot, draftNode });
        }
        if (lifecycle.hasBeforeCommit) {
          beforeCommit(commitOpts, draftRoot, moduleName);
        }
        mutateCtx.depKeys = Object.keys(writeKeys);
        DRAFT_ROOT.del();
        const nextState = finishDraft(draftRoot);
        commitOpts.state = nextState;
        if (nextState === internal.rawState) {
          return;
        }
        mutateCtx.triggerReasons = Object.values(writeKeyPathInfo);
        commitState(commitOpts);
        emitDataChanged(internal, mutateCtx);
        internal.lifecycle.afterCommit({ state: nextState, moduleName, sn, desc, from });
      }
      function fillMutateCtx(mutateCtx, innerSetOptions) {
        const { ids, globalIds, from, desc, fnKey, payloadArgs } = innerSetOptions;
        if (ids) {
          ids.forEach((id) => n$2(mutateCtx.ids, id));
        }
        if (globalIds) {
          globalIds.forEach((id) => n$2(mutateCtx.globalIds, id));
        }
        from && (mutateCtx.from = from);
        desc && (mutateCtx.desc = desc);
        fnKey && (mutateCtx.fnKey = fnKey);
        if (payloadArgs !== void 0) {
          mutateCtx.payloadArgs = payloadArgs;
        }
      }
      function prepareDeepMutate(opts) {
        const { internal, setFactoryOpts } = opts;
        const { forAtom, rawState } = internal;
        const mutateCtx = newMutateCtx(setFactoryOpts);
        const draftRoot = createDraft(rawState, {
          // fix issue https://github.com/heluxjs/helux/issues/166
          autoRevoke: false,
          customKeys: OP_KEYS,
          onOperate: (opParams) => {
            if (opParams.isCustom) {
              return handleCustomKey(opParams, forAtom, internal.sharedKey);
            }
            handleOperate(opParams, { internal, mutateCtx });
          }
        });
        DRAFT_ROOT.set(draftRoot, forAtom);
        const draftNode = getStateNode(draftRoot, forAtom);
        if (forAtom) {
          mutateCtx.readKeys = {};
        }
        return {
          draftRoot,
          draftNode,
          finishMutate(partial, innerSetOptions = {}) {
            fillMutateCtx(mutateCtx, innerSetOptions);
            const commitOpts = { state: {}, mutateCtx, internal };
            execFinish(commitOpts, draftRoot, draftNode, partial);
          }
        };
      }
      var noopAny2 = () => {
      };
      var taskProm = /* @__PURE__ */ new Map();
      function getInput(internal, fnItem2) {
        const { forAtom, rawState } = internal;
        const { deps, extraBound: boundStateInfo } = fnItem2;
        if (forAtom) {
          return i$2(deps, rawState.val, boundStateInfo);
        }
        return i$2(deps, rawState, boundStateInfo);
      }
      function isTaskProm(task) {
        return taskProm.get(task) ?? false;
      }
      function callAsyncMutateFnLogic(targetState, options) {
        const { sn, getArgs = f$2, getPayloadArgs = f$2, from, throwErr, isFirstCall, fnItem: fnItem2, mergeReturn, extraArgs } = options;
        const { desc = "", depKeys, task = noopAny2, extraBound } = fnItem2;
        const internal = getInternal(targetState);
        const { sharedKey } = internal;
        const customOptions = { desc, sn, from };
        const statusKey = getStatusKey(from, desc);
        const payloadArgs = getPayloadArgs();
        const { draft, draftRoot } = buildReactive(internal, { desc, from, payloadArgs });
        const flush2 = (desc2) => {
          innerFlush(sharedKey, desc2);
        };
        const setState = (cb) => {
          flush2(desc);
          const { finish } = internal.setStateFactory(customOptions);
          return finish(cb);
        };
        const input = FROM.MUTATE === from ? getInput(internal, fnItem2) : [];
        const defaultParams = { isFirstCall, desc, setState, input, draft, draftRoot, flush: flush2, extraBound, extraArgs };
        const args = getArgs(defaultParams) || [defaultParams];
        const isProm = taskProm.get(task);
        const isUnconfirmedFn = isProm === void 0;
        const setStatus = (loading, err, ok) => {
          if (isUnconfirmedFn || isProm) {
            setLoadStatus(internal, statusKey, { loading, err, ok });
          }
        };
        setStatus(true, null, false);
        const handleErr = (err) => {
          FN_DEP_KEYS.del();
          setStatus(false, err, false);
          if (throwErr) {
            throw err;
          }
          return { snap: internal.snap, err, result: null };
        };
        const handlePartial2 = (partial) => {
          if (mergeReturn) {
            partial && setState(partial);
          }
          setStatus(false, null, true);
          flush2(desc);
          return { snap: internal.snap, err: null, result: partial };
        };
        try {
          const result = task(...args);
          const isProm2 = A$2(result);
          taskProm.set(task, isProm2);
          if (isProm2) {
            return Promise.resolve(result).then((result2) => {
              return handlePartial2(result2);
            }).catch(handleErr);
          }
          return handlePartial2(result);
        } catch (err) {
          return handleErr(err);
        }
      }
      function callMutateFnLogic(targetState, options) {
        const { sn, getArgs = f$2, getPayloadArgs = f$2, from, throwErr, isFirstCall = false, fnItem: fnItem2, extraArgs } = options;
        const { desc = "", watchKey, fn = noopAny2, extraBound } = fnItem2;
        const isMutate = FROM.MUTATE === from;
        isMutate && TRIGGERED_WATCH.set(watchKey);
        const internal = getInternal(targetState);
        const { setStateFactory, forAtom, sharedRoot } = internal;
        const enableDep = isMutate && isFirstCall;
        const setFactoryOpts = { desc, sn, from, isFirstCall, enableDep };
        const setState = (cb) => {
          const { finish: finish2 } = setStateFactory(setFactoryOpts);
          return finish2(cb, { from, desc, payloadArgs: getPayloadArgs() });
        };
        const state = getStateNode(sharedRoot, forAtom);
        const input = isMutate ? getInput(internal, fnItem2) : [];
        const { draftNode: draft, draftRoot, finish } = setStateFactory(setFactoryOpts);
        const args = getArgs({ draft, draftRoot, setState, desc, input, extraArgs }) || [
          draft,
          { input, state, draftRoot, isFirstCall, extraBound, extraArgs }
        ];
        try {
          const fnCtx = getSafeFnCtx(fnItem2.watchKey);
          if (fnCtx.dcErrorInfo.err) {
            alertDepKeyDeadCycleErr(internal, fnCtx.dcErrorInfo);
            return { snap: internal.snap, err: null, result: null };
          }
          const result = fn(...args);
          finish(result, { fnKey: fnCtx.fnKey });
          afterFnRun(internal, fnItem2, isFirstCall);
          return { snap: internal.snap, err: null, result: null };
        } catch (err) {
          afterFnRun(internal, fnItem2, isFirstCall);
          if (throwErr) {
            throw err;
          }
          return { snap: internal.snap, err, result: null };
        }
      }
      function afterFnRun(internal, fnItem2, isFirstCall) {
        if (isFirstCall && !fnItem2.onlyDeps) {
          const fnCtx = getRunningFn().fnCtx;
          if (fnCtx) {
            fnItem2.depKeys = markFnEnd();
          } else {
            fnItem2.depKeys = FN_DEP_KEYS.current();
          }
          FN_DEP_KEYS.del();
        }
        const rmeta = REACTIVE_META.current();
        if (rmeta.isTop && rmeta.fnKey === fnItem2.watchKey) {
          probeDepKeyDeadCycle(internal, getSafeFnCtx(fnItem2.watchKey), rmeta.writeKeys);
        }
        TRIGGERED_WATCH.del();
      }
      function initFnItem(internal, fnItem2) {
        flushActive();
        FN_DEP_KEYS.del();
        markIgnore(false);
        const fnCtx = getRunningFn().fnCtx;
        if (fnCtx) {
          fnCtx.subFnInfo = fnItem2;
          fnCtx.checkDeadCycle = fnItem2.checkDeadCycle ?? internal.checkDeadCycle;
          fnItem2.watchKey = fnCtx.fnKey;
        }
        if (fnItem2.onlyDeps) {
          fnItem2.depKeys = markFnEnd();
        }
      }
      function watchAndCallMutateDict(options) {
        const { target, dict } = options;
        const keys = Object.keys(dict);
        const watchFnCtxMap = {};
        if (!keys.length) return watchFnCtxMap;
        const internal = getInternal(target);
        const { mutateFnDict, usefulName, forAtom, sharedRoot } = internal;
        const emitErrToPlugin = (err) => emitErr(internal, err);
        keys.forEach((descKey) => {
          const item = mutateFnDict[descKey];
          watchFnCtxMap[descKey] = createWatchLogic(
            ({ sn, isFirstCall }) => {
              if (isFirstCall) {
                initFnItem(internal, item);
              }
              if (!internal.enableMutate) {
                return;
              }
              const { desc, fn, task, immediate } = item;
              const dc = inDeadCycle(usefulName, desc);
              try {
                if (dc.isIn) {
                  throw dcErr(usefulName, dc.cycle, desc);
                }
                const baseOpts = { sn, throwErr: true, isFirstCall, fnItem: item, from: FROM.MUTATE };
                if (fn && (isFirstCall || !task)) {
                  callMutateFnLogic(target, baseOpts);
                }
                if (task) {
                  isFirstCall && (item.depKeys = markFnEnd());
                  const canRunAtFirstCall = isFirstCall && (immediate ?? !fn);
                  if (!isFirstCall || canRunAtFirstCall) {
                    const ret = callAsyncMutateFnLogic(target, baseOpts);
                    ret.catch(emitErrToPlugin);
                  }
                }
                return item;
              } catch (err) {
                if (err.cause === "DeadCycle") {
                  analyzeErrLog(usefulName, err, internal.alertDeadCycleErr);
                }
                emitErrToPlugin(err);
              }
            },
            {
              deps: () => {
                if (!item.deps) return [];
                return item.deps(getStateNode(sharedRoot, forAtom), item.extraBound) || [];
              },
              sharedState: target,
              scopeType: SCOPE_TYPE.STATIC,
              immediate: true
            }
          );
        });
        return watchFnCtxMap;
      }
      var { ACTION: ACTION2 } = FROM;
      function innerCreate(state, options) {
        const { label, throwErr, desc = "", task, mergeReturn = true, isMultiPayload = false } = options;
        const outThrowErr = ensureBool(throwErr, false);
        const internal = checkSharedStrict(state, { label });
        const { forAtom } = internal;
        const action2 = (...args) => {
          let payloadArg = args[0];
          let payloadArgs = [payloadArg];
          let throwFnErr = args[1];
          if (isMultiPayload) {
            payloadArg = args;
            payloadArgs = args;
            throwFnErr = void 0;
          }
          const throwErrVar = ensureBool(throwFnErr, outThrowErr);
          const fnItem2 = newMutateFnItem({ desc, task, depKeys: [] });
          const dispatch = (task2, payload) => {
            if (!task2.__action) {
              return task2(payload);
            }
            return task2.__action(payload);
          };
          return callAsyncMutateFnLogic(state, {
            fnItem: fnItem2,
            from: ACTION2,
            mergeReturn,
            throwErr: throwErrVar,
            // action task 默认不抛错误
            getArgs: ({ draft, draftRoot, setState, desc: desc2, flush: flush2 }) => {
              const merge = (partial) => {
                handlePartial({ partial, forAtom, draftRoot, draftNode: draft });
              };
              const payload = payloadArg;
              return [{ draft, draftRoot, setState, desc: desc2, payload, payloadArgs, flush: flush2, merge, dispatch }];
            },
            getPayloadArgs: () => payloadArgs
          });
        };
        setLoadStatus(internal, getStatusKey(ACTION2, desc), { loading: false, ok: true, err: null });
        action2.__sharedKey = internal.sharedKey;
        action2.__fnName = desc;
        action2.__task = task;
        task.__action = action2;
        return action2;
      }
      function action(sharedState) {
        return (mergeReturn) => (task, desc = "", throwErr, isMultiPayload) => innerCreate(sharedState, { task, desc, label: "action", mergeReturn, throwErr, isMultiPayload });
      }
      var toMutateRet = (ret) => [ret.snap, ret.err];
      function runMutateFnItem(options) {
        const { target, desc: inputDesc = "", forTask = false, throwErr, extraArgs } = options;
        const { mutateFnDict, snap } = getInternal(target);
        const desc = inputDesc || SINGLE_MUTATE;
        const item = mutateFnDict[desc];
        if (!item) return { snap, err: new Error(`mutate fn ${desc} not defined`), result: null };
        if (forTask && !item.task) return { snap, err: new Error(`mutate task ${desc} not defined`), result: null };
        const throwErrVar = ensureBool(throwErr, false);
        const baseOpts = { sn: 0, fnItem: item, from: FROM.MUTATE, throwErr: throwErrVar, extraArgs };
        if (forTask) {
          return callAsyncMutateFnLogic(target, baseOpts);
        }
        return callMutateFnLogic(target, baseOpts);
      }
      function makeWitness(target, options) {
        const { desc, oriDesc, internal, watchFnCtx } = options;
        return {
          run: (throwErr) => {
            const ret = runMutateFnItem({ target, desc, throwErr });
            return toMutateRet(ret);
          },
          // 呼叫异步函数的句柄
          runTask: (throwErr) => Promise.resolve(runMutateFnItem({ target, desc, forTask: true, throwErr })).then(toMutateRet),
          cancel: () => {
            delFnDep(watchFnCtx);
            delete internal.mutateFnDict[desc];
          },
          desc,
          oriDesc,
          getSnap: () => internal.snap,
          snap: internal.snap,
          /** for initLoadingCtx */
          __sharedKey: internal.sharedKey
        };
      }
      function configureMutateFn(options) {
        const { target, fnItem: fnItem2, label, extraTarget } = options;
        const internal = checkSharedStrict(target, { label });
        const stdFnItem = parseMutateFn(fnItem2, "", internal.mutateFnDict);
        if (!stdFnItem) {
          throw new Error("not a fn or fnItem { fn }");
        }
        if (extraTarget) {
          stdFnItem.extraBound = getBoundStateInfo(extraTarget);
        }
        const { desc, oriDesc } = stdFnItem;
        internal.mutateFnDict[desc] = stdFnItem;
        stdFnItem.enabled = internal.enableMutate;
        const dict = { [desc]: stdFnItem };
        let watchFnCtx;
        if (internal.enableMutate) {
          const retMap = watchAndCallMutateDict({ target, dict });
          watchFnCtx = retMap[desc];
        }
        return makeWitness(target, { desc, oriDesc, internal, watchFnCtx });
      }
      function configureMutateDict(options) {
        const { target, fnDict, label } = options;
        const internal = checkSharedStrict(target, { label });
        const dict = parseMutate(fnDict, internal.mutateFnDict, internal.enableMutate);
        if (options.extraTarget) {
          const extraBound = getBoundStateInfo(options.extraTarget);
          Object.keys(dict).forEach((key) => dict[key].extraBound = extraBound);
        }
        let watchFnCtxMap = {};
        if (internal.enableMutate) {
          watchFnCtxMap = watchAndCallMutateDict({ target, dict });
        }
        const witnessDict = {};
        Object.keys(dict).forEach((desc) => {
          witnessDict[desc] = makeWitness(target, { desc, oriDesc: desc, internal, watchFnCtx: watchFnCtxMap[desc] });
        });
        return witnessDict;
      }
      function prepareParms(target, options) {
        const { label, descOrOptions, forTask = false } = options;
        const { desc, strict, throwErr, extraArgs } = parseCreateMutateOpt(descOrOptions);
        if (!desc) {
          return { ok: false, desc, forTask, throwErr, err: new Error("miss desc") };
        }
        const internal = checkShared(target, { label, strict });
        if (!internal) {
          return { ok: false, desc, forTask, throwErr, extraArgs, err: new Error("not a valid atom or shared result") };
        }
        return { ok: true, desc, forTask, throwErr, extraArgs, err: null };
      }
      function runMutateLogic(target, options) {
        const { ok, desc, forTask, err, throwErr, extraArgs } = prepareParms(target, options);
        if (!ok) {
          if (throwErr) {
            throw err;
          }
          return forTask ? Promise.resolve([target, err]) : [target, err];
        }
        const result = runMutateFnItem({ target, desc, forTask, throwErr, extraArgs });
        return forTask ? Promise.resolve(result).then(toMutateRet) : toMutateRet(result);
      }
      function runMutate(target, descOrOptions) {
        return runMutateLogic(target, { descOrOptions, label: "runMutate" });
      }
      function runMutateTask(target, descOrOptions) {
        return runMutateLogic(target, { descOrOptions, label: "runMutateTask", forTask: true });
      }
      function mutate(target, extraTarget) {
        return (fnItem2) => configureMutateFn({ target, extraTarget, fnItem: fnItem2, label: "mutate" });
      }
      function mutateDict(target, extraTarget) {
        return (fnDict) => configureMutateDict({ target, extraTarget, fnDict, label: "mutateDict" });
      }
      function defineMutateFnItem(fnItem2) {
        return fnItem2;
      }
      function prepareDowngradeMutate(opts) {
        const { internal, setFactoryOpts } = opts;
        const { rawState, forAtom, stopDepth, sharedKey } = internal;
        const mutateCtx = newMutateCtx(setFactoryOpts);
        const copied = { ...rawState };
        const handleValueChange = (target, key, value, parentKeyPath) => {
          const opParams = newOpParams(key, value, { parentType: getDataType(target), parentKeyPath });
          handleOperate(opParams, { internal, mutateCtx });
          P$1(copied, opParams.fullKeyPath, value);
        };
        const toShallowProxy = (obj, keyLevel, parentKeyPath) => createDpOb(obj, {
          set: (target, key, value) => {
            handleValueChange(target, key, value, parentKeyPath);
            return true;
          },
          get: (target, key) => {
            const value = target[key];
            if (OP_KEYS.includes(key)) {
              return handleHeluxKey(keyLevel === 1, forAtom, sharedKey, key, value);
            }
            const opParams = newOpParams(key, value, { isChanged: false, parentKeyPath, op: "get", parentType: getDataType(target) });
            if (keyLevel < stopDepth && isDict(value)) {
              return toShallowProxy(value, keyLevel + 1, opParams.fullKeyPath);
            }
            return M$1(copied, opParams.fullKeyPath);
          }
        });
        const downgradeDraft = toShallowProxy(copied, 1, []);
        DRAFT_ROOT.set(downgradeDraft, forAtom);
        const draftNode = forAtom ? downgradeDraft.val : downgradeDraft;
        return {
          draftRoot: downgradeDraft,
          draftNode,
          finishMutate(partial, innerSetOptions = {}) {
            fillMutateCtx(mutateCtx, innerSetOptions);
            const commitOpts = { state: {}, mutateCtx, ...opts };
            execFinish(commitOpts, downgradeDraft, draftNode, partial);
          }
        };
      }
      function getEventVal(e2) {
        let val = e2;
        if (e2) {
          if (e2.persist) e2.persist();
          const { currentTarget } = e2;
          if (currentTarget && e2.type) {
            if (currentTarget.tagName === "INPUT" && currentTarget.type === "checkbox") {
              val = currentTarget.checked;
            } else {
              val = currentTarget.value;
            }
          } else if (e2.nativeEvent && e2.target) {
            val = e2.target.value;
          }
        }
        return val;
      }
      function createTargetWrap(rawState) {
        let latestPath = [];
        const target = createImmut(rawState, ({ fullKeyPath }) => {
          latestPath = fullKeyPath;
        });
        return { target, getPath: () => latestPath };
      }
      function createSyncFn(innerSetState, path, before) {
        const syncFn = (evOrVal) => {
          let val = getEventVal(evOrVal);
          innerSetState(
            (draft) => {
              const { isAtom: isAtom2, draftRoot } = DRAFT_ROOT.current();
              const params = { draft, draftRoot, path, isAtom: isAtom2, UNDEFINED };
              const newVal = before == null ? void 0 : before(val, params);
              P$1(draftRoot, path, newVal !== void 0 ? newVal : val);
            },
            { from: FROM.SYNC }
          );
        };
        return syncFn;
      }
      function syncerFn(keyPath, internal) {
        const { sharedKey, innerSetState } = internal;
        let cacheKey = getDepKeyByPath(keyPath, sharedKey);
        let dataSyncer = dataSyncerCahce.get(cacheKey);
        if (!dataSyncer) {
          dataSyncer = createSyncFn(innerSetState, keyPath);
          dataSyncerCahce.set(cacheKey, dataSyncer);
        }
        return dataSyncer;
      }
      var dataSyncerCahce = /* @__PURE__ */ new Map();
      function createSyncerBuilder(internal) {
        const { forAtom, rawState } = internal;
        if (forAtom) {
          if (!v$1(rawState.val)) {
            return syncerFn(["val"], internal);
          }
          return createDpOb(rawState.val, {
            get: (target, key) => syncerFn(["val", key], internal)
          });
        }
        return createDpOb(rawState, {
          get: (target, key) => syncerFn([key], internal)
        });
      }
      var syncFnCahce = /* @__PURE__ */ new Map();
      function createSyncFnBuilder(internal) {
        const { forAtom, sharedKey, innerSetState, rawState } = internal;
        const targetWrap = createTargetWrap(rawState);
        return (pathOrRecorder, before) => {
          let path = [];
          if (Array.isArray(pathOrRecorder)) {
            path = forAtom ? ["val", ...pathOrRecorder] : pathOrRecorder;
          } else {
            const { target, getPath } = targetWrap;
            pathOrRecorder(forAtom ? target.val : target);
            path = getPath();
          }
          let cacheKey = getDepKeyByPath(path, sharedKey);
          if (before) {
            cacheKey += `${before.toString()}`;
          }
          let syncFn = syncFnCahce.get(cacheKey);
          if (!syncFn) {
            syncFn = createSyncFn(innerSetState, path, before);
            syncFnCahce.set(cacheKey, syncFn);
          }
          return syncFn;
        };
      }
      function mapSharedToInternal(sharedRoot, sharedState, options) {
        const { deep, forAtom, sharedKey } = options;
        const ruleConf = parseRules(options);
        const isDeep = G$1(deep);
        const setStateImpl = (setFactoryOpts = {}) => {
          const mutateOptions = { internal, setFactoryOpts };
          const { finishMutate, draftRoot, draftNode } = isDeep ? prepareDeepMutate(mutateOptions) : prepareDowngradeMutate(mutateOptions);
          return {
            // 注意非 deep 模式的 finish(setState) 只支持一层依赖收集
            finish: (partialState, options2 = {}) => {
              const snap = internal.snap;
              if (partialState === snap) {
                return snap;
              }
              const partial = runPartialCb(forAtom, partialState, draftNode);
              finishMutate(partial, options2);
              return internal.snap;
            },
            draftRoot,
            draftNode
          };
        };
        const setStateFactory = (options2 = {}) => {
          return setStateImpl(options2);
        };
        const innerSetState = (partialState, options2 = {}) => {
          return setStateImpl().finish(partialState, options2);
        };
        const callSetState = (partialState, optArr) => {
          const [handleCbReturn, enableDep, setOptions] = optArr;
          flush(sharedRoot, REACTIVE_DESC.current(sharedKey));
          const ret = setStateImpl({ handleCbReturn, enableDep });
          return ret.finish(partialState, pureSetOptions(setOptions));
        };
        const setState = (partialState, options2) => callSetState(partialState, [true, true, options2]);
        const setDraft = (partialState, options2) => callSetState(partialState, [false, true, options2]);
        const insSetState = (partialState, options2) => callSetState(partialState, [true, false, options2]);
        const insSetDraft = (partialState, options2) => callSetState(partialState, [false, false, options2]);
        const internal = buildInternal(options, {
          sharedRoot,
          sharedState,
          setState,
          setDraft,
          insSetState,
          insSetDraft,
          setStateFactory,
          innerSetState,
          ruleConf,
          isDeep
        });
        internal.sync = createSyncFnBuilder(internal);
        internal.syncer = createSyncerBuilder(internal);
        setInternal(sharedRoot, internal);
        return internal;
      }
      function buildSharedObject(innerOptions, createOptions) {
        const parsedOptions = parseOptions(innerOptions, createOptions);
        const { sharedRoot, sharedState } = buildSharedState(parsedOptions);
        const internal = mapSharedToInternal(sharedRoot, sharedState, parsedOptions);
        recordMod(sharedRoot, parsedOptions);
        ensureHMRRunWell();
        watchAndCallMutateDict({ target: sharedRoot, dict: parsedOptions.mutateFnDict });
        const { draft, draftRoot } = buildReactive(internal, { from: "Reactive", desc: "" });
        internal.reactive = draft;
        internal.reactiveRoot = draftRoot;
        clearInternal(parsedOptions.moduleName, internal.loc);
        clearDcLog(internal.usefulName);
        emitShareCreated(internal);
        return { sharedRoot, sharedState, internal, parsedOptions };
      }
      var lifecycleFnNames = ["willMount", "mounted", "willUnmount", "beforeCommit", "afterCommit"];
      function defineLifecycle(lifecycleFns, internal) {
        if (!lifecycleFns) return;
        const validFns = {};
        lifecycleFnNames.forEach((name) => {
          const fn = lifecycleFns[name];
          if (!w$2(fn)) {
            return;
          }
          validFns[name] = fn;
          if (name === "beforeCommit") {
            internal.lifecycle.hasBeforeCommit = true;
          }
        });
        Object.assign(internal.lifecycle, validFns);
      }
      var { USER_STATE: USER_STATE2 } = STATE_TYPE;
      var { MUTATE: MUTATE4, ACTION: ACTION3 } = FROM;
      function ensureGlobal(apiCtx, inputStateType) {
        const stateType = inputStateType || USER_STATE2;
        if (USER_STATE2 === stateType && !getGlobalEmpty()) {
          initGlobalEmpty(apiCtx, createSharedLogic);
          initGlobalLoading(apiCtx, createSharedLogic);
        }
      }
      function defineActions(options, throwErr) {
        const { createFn, ldAction, actionDict, actionCreator, internal, apiCtx, forTp = false, isMultiPayload = false } = options;
        getLoadingInfo(createFn, { internal, from: ACTION3, apiCtx });
        const actions = {};
        const eActions = {};
        Object.keys(actionDict).forEach((key) => {
          const actionOrFnDef = actionDict[key];
          const actionTask = forTp ? actionOrFnDef.__task : actionOrFnDef;
          const eActionFn = actionCreator(false)(actionTask, key, throwErr, isMultiPayload);
          eActionFn.__fnName = key;
          eActions[key] = eActionFn;
          const actionFn = (...args) => {
            const ret = eActionFn(...args);
            if (isTaskProm(actionTask)) {
              return Promise.resolve(ret).then((data) => data.result);
            }
            return ret.result;
          };
          actionFn.__fnName = key;
          actions[key] = actionFn;
        });
        return {
          actions,
          eActions,
          getLoading: () => ldAction.getLoading(actions),
          useLoading: () => ldAction.useLoading(actions)[0],
          useLoadingInfo: () => ldAction.useLoading(actions)
        };
      }
      function ensureDict(common, dict, extra) {
        const { state, stateRoot, isAtom: isAtom2 } = common;
        const extraBound = getBoundStateInfo(extra);
        return w$2(dict) ? dict({ state, stateRoot, isAtom: isAtom2, extraBound }) : dict;
      }
      function defineMutate(options) {
        const { common, ldMutate, mutateFnDict, extra } = options;
        const dict = ensureDict(common, mutateFnDict, extra);
        const witnessDict = mutateDict(common.stateRoot, extra)(dict);
        return {
          witnessDict,
          getLoading: () => ldMutate.getLoading(witnessDict),
          useLoading: () => ldMutate.useLoading(witnessDict)[0],
          useLoadingInfo: () => ldMutate.useLoading(witnessDict)
        };
      }
      function defineMutateDerive(options) {
        const { common, ldMutate, inital, mutateFnDict, shareOptions } = options;
        const { stateRoot, useState: useState2, state, isAtom: isAtom2 } = sharex(common.apiCtx, inital, shareOptions);
        const initialCommon = { ...common, stateRoot, state, isAtom: isAtom2, internal: getInternal(stateRoot) };
        const result = defineMutate({ common: initialCommon, ldMutate, mutateFnDict, extra: common.stateRoot });
        return { derivedState: stateRoot, useDerivedState: useState2, ...result };
      }
      function defineFullDerive(options) {
        const { common, deriveFnDict, throwErr } = options;
        const dict = ensureDict(common, deriveFnDict);
        const { apiCtx, stateRoot } = common;
        const derivedResult = {};
        const helper = {};
        Object.keys(dict).forEach((key) => {
          const result2 = derive(dict[key], stateRoot);
          derivedResult[key] = result2;
          helper[key] = {
            runDerive: (te2) => innerRunDerive(result2, te2 ?? throwErr),
            runDeriveTask: (te2) => innerRunDeriveTask(result2, te2 ?? throwErr),
            useDerived: (options2) => useDerived(apiCtx, result2, options2)[0],
            useDerivedInfo: (options2) => useDerived(apiCtx, result2, options2)
          };
        });
        const result = new Proxy(derivedResult, {
          get: (t2, k2) => derivedResult[k2].val
        });
        return { result, helper };
      }
      function setEnableMutate(enabled, internal) {
        internal.enableMutate = enabled;
        if (enabled) {
          const { mutateFnDict } = internal;
          const teBeRunFns = {};
          Object.keys(mutateFnDict).forEach((key) => {
            const fnItem2 = mutateFnDict[key];
            if (!fnItem2.enabled) {
              fnItem2.enabled = true;
              teBeRunFns[key] = fnItem2;
            }
          });
          mutateDict(internal.sharedState)(teBeRunFns);
        }
      }
      function getOptions(internal) {
        const { moduleName, deep, recordLoading, stopDepth, stopArrDep, alertDeadCycleErr, checkDeadCycle, enableMutate } = internal;
        return { moduleName, deep, recordLoading, stopDepth, stopArrDep, alertDeadCycleErr, checkDeadCycle, enableMutate };
      }
      function createSharedLogic(innerOptions, createOptions) {
        const { stateType, apiCtx } = innerOptions;
        ensureGlobal(apiCtx, stateType);
        const { sharedRoot: stateRoot, sharedState: state, internal } = buildSharedObject(innerOptions, createOptions);
        const { syncer: syncer2, sync: sync2, forAtom, setState, setDraft, sharedKey, sharedKeyStr, rootValKey, reactive, reactiveRoot } = internal;
        const actionCreator = action(stateRoot);
        const actionTaskCreator = actionCreator();
        const opt = { internal, from: MUTATE4, apiCtx };
        const createFn = createSharedLogic;
        const ldAction = initLoadingCtx(createFn, { ...opt, from: ACTION3 });
        const ldMutate = initLoadingCtx(createFn, opt);
        const common = { createFn, internal, apiCtx, state, stateRoot, isAtom: forAtom };
        const acCommon = { ...common, ldAction, actionCreator };
        return {
          state,
          // atom 的 state 指向拆箱后的值，share 的 state 指向根值
          stateVal: state,
          stateRoot,
          // 指向 root
          setState,
          setDraft,
          setEnableMutate: (enabled) => setEnableMutate(enabled, internal),
          getOptions: () => getOptions(internal),
          defineActions: (throwErr, isMultiPayload) => (actionDict) => defineActions({ ...acCommon, actionDict, isMultiPayload }, throwErr),
          defineTpActions: (throwErr) => (actionDict) => defineActions({ ...acCommon, actionDict, forTp: true }, throwErr),
          defineMutateDerive: (inital, shareOptions) => (mutateFnDict) => defineMutateDerive({ common, ldMutate, inital, mutateFnDict, shareOptions }),
          defineMutateSelf: () => (mutateFnDict) => defineMutate({ common, ldMutate, mutateFnDict }),
          defineFullDerive: (throwErr) => (deriveFnDict) => defineFullDerive({ common, deriveFnDict, throwErr }),
          defineLifecycle: (lifecycle) => defineLifecycle(lifecycle, internal),
          mutate: mutate(stateRoot),
          runMutate: (descOrOptions) => runMutate(stateRoot, descOrOptions),
          runMutateTask: (descOrOptions) => runMutateTask(stateRoot, descOrOptions),
          action: actionCreator,
          call: (fn, payload, desc, throwErr) => actionTaskCreator(fn, desc, throwErr)(payload),
          useState: (options) => useAtom(apiCtx, stateRoot, options),
          useStateX: (options) => useAtomX(apiCtx, stateRoot, options),
          useForceUpdate: (presetDeps) => useGlobalForceUpdate(apiCtx, stateRoot, presetDeps),
          useLocalState: (initialState) => useMutable(apiCtx, initialState),
          useLocalForceUpdate: () => useLocalForceUpdate(apiCtx),
          getMutateLoading: ldMutate.getLoading,
          useMutateLoading: ldMutate.useLoading,
          getActionLoading: ldAction.getLoading,
          useActionLoading: ldAction.useLoading,
          getSnap: (isPrev) => getSnap(stateRoot, isPrev),
          sync: sync2,
          syncer: syncer2,
          sharedKey,
          sharedKeyStr,
          rootValKey,
          reactive,
          reactiveRoot,
          reactiveDesc: (desc) => reactiveDesc(stateRoot, desc),
          useReactive: (options) => useReactive(apiCtx, stateRoot, options),
          useReactiveX: (options) => useReactiveX(apiCtx, stateRoot, options),
          flush: (desc) => flush(stateRoot, desc),
          isAtom: forAtom
        };
      }
      function share(apiCtx, rawState, options) {
        const ctx2 = createSharedLogic({ apiCtx, rawState }, options);
        return [ctx2.stateRoot, ctx2.setState, ctx2];
      }
      function sharex(apiCtx, rawState, options) {
        return createSharedLogic({ apiCtx, rawState }, options);
      }
      function atom(apiCtx, rawState, options) {
        const ctx2 = createSharedLogic({ apiCtx, rawState, forAtom: true }, options);
        return [ctx2.stateRoot, ctx2.setState, ctx2];
      }
      function atomx(apiCtx, rawState, options) {
        return createSharedLogic({ apiCtx, rawState, forAtom: true }, options);
      }
      var dAtomCtx;
      function getDefaultAtom(apiCtx) {
        if (!dAtomCtx) {
          dAtomCtx = atomx(apiCtx, { tip: "default atom" }, { moduleName: "DefaultClassAtom" });
        }
        return dAtomCtx;
      }
      function getDefaultHX() {
        return { atom: {}, atoms: {}, deriveds: {} };
      }
      var RH = null;
      function getRH(apiCtx) {
        const { Component } = apiCtx.react;
        if (RH) {
          return RH;
        }
        RH = class RebuildHelper extends Component {
          constructor() {
            super(...arguments);
            __publicField(this, "state", {});
          }
          static getDerivedStateFromError() {
            return { hasError: true };
          }
          componentDidCatch(error, errorInfo) {
            this.props.onError(error, errorInfo);
          }
          render() {
            return this.state.hasError ? null : this.props.children;
          }
        };
        return RH;
      }
      function renderFallback(apiCtx, err, info) {
        if (info) {
          console.error(info);
        }
        return apiCtx.react.createElement("span", {}, `HeluxAtomComp render error: ${(err == null ? void 0 : err.message) || "error occurred"}`);
      }
      function ClassRenderer(props) {
        return props.renderUI();
      }
      function mergeAtoms(apiCtx, options) {
        const dAtomCtx2 = getDefaultAtom(apiCtx);
        const { atom: atom2 = dAtomCtx2.state, atomOptions, atoms = {}, atomsOptions = {} } = options || {};
        let atomKey = CLASS_ATOM;
        let singleAtom = atom2;
        Object.keys(atoms).forEach((key) => {
          if (atoms[key] === atom2) {
            atomKey = key;
            singleAtom = atoms[key];
          }
        });
        const targetAtoms = Object.assign({ [atomKey]: singleAtom, ...atoms });
        const targetAtomsOptions = Object.assign({ [atomKey]: atomOptions, ...atomsOptions });
        const atomKeys = Object.keys(atoms);
        if (!atomKeys.includes(atomKey)) {
          atomKeys.push(atomKey);
        }
        return { atoms: targetAtoms, atomsOptions: targetAtomsOptions, atomKeys, atomKey };
      }
      function makeAtomFnComp(apiCtx, UIComp, options) {
        const {
          atomKey,
          atomKeys,
          atoms = {},
          atomsOptions = {},
          deriveds = {},
          derivedsOptions = {},
          // 透传的 hx 可让类组件上的 props.hx 是一个稳定引用
          hx: outHX,
          rebuild,
          onError = f$2,
          fallback = (err, info) => renderFallback(apiCtx, err, info),
          forClass
        } = options;
        const { react, hookImpl } = apiCtx;
        const { createElement, useRef } = react;
        const { useForceUpdate, useIsStrict } = hookImpl;
        const cdata = { fc: false, rc: 0 };
        const mayClearErr = (cdata2, isStrict, data) => {
          if (!cdata2.fc) {
            return;
          }
          if (isStrict) {
            cdata2.rc += 1;
            if (cdata2.rc % 2 === 0) {
              data.err = null;
            }
          } else {
            data.err = null;
          }
        };
        return function AtomComp(props) {
          const dataRef = useRef({ hx: outHX || getDefaultHX(), err: null, key: Date.now(), isStrict: false });
          const forceUpdate = useForceUpdate();
          useIsStrict((isStrict2) => dataRef.current.isStrict = isStrict2);
          const { hx, key, err, isStrict } = dataRef.current;
          const handleError = (error, info) => {
            dataRef.current.key = Date.now();
            dataRef.current.err = { error, info };
            if (rebuild) {
              cdata.fc = true;
              forceUpdate();
            } else {
              onError(error, info);
            }
          };
          atomKeys.forEach((key2) => {
            const atom2 = atoms[key2];
            const atomCtx = useAtomX(apiCtx, atom2, atomsOptions[key2]);
            if (atomKey === key2) {
              Object.assign(hx.atom, atomCtx);
            }
            hx.atoms[key2] = atomCtx;
          });
          Object.keys(deriveds).forEach((key2) => {
            const result = deriveds[key2];
            const options2 = { ...derivedsOptions[key2] || {} };
            const resultTuple = useDerived(apiCtx, result, options2);
            hx.deriveds[key2] = resultTuple;
          });
          const passProps = forClass ? props : { ...props, hx };
          let ui = createElement(UIComp, passProps);
          if (rebuild) {
            const RebuildHeper = getRH(apiCtx);
            if (err) {
              ui = fallback(err.error, err.info);
            }
            mayClearErr(cdata, isStrict, dataRef.current);
            return createElement(RebuildHeper, { key, onError: handleError }, ui);
          }
          return ui;
        };
      }
      function assignThisHX(thisRef) {
        return thisRef.props.hx || {};
      }
      function getHX(props, context) {
        const hx = props.hx || context.hx || {};
        const { atom: atom2 = {}, atoms = {} } = hx;
        if (!atom2.state && atoms[CLASS_ATOM]) {
          hx.atom = atoms[CLASS_ATOM];
        }
        return hx;
      }
      function makeWithAtomOptions(options) {
        return options;
      }
      function bindAtom(apiCtx, ClassComp, options) {
        const { hx, memo, propsAreEqual, ...rest } = options || {};
        const { atoms, atomsOptions, atomKeys, atomKey } = mergeAtoms(apiCtx, options);
        const FnComp = makeAtomFnComp(apiCtx, ClassComp, { ...rest, atomKey, atomKeys, atoms, atomsOptions });
        return memo ? apiCtx.react.memo(FnComp, propsAreEqual) : FnComp;
      }
      function withAtom(apiCtx, ClassComp, options) {
        const { react } = apiCtx;
        const { createElement, PureComponent, Fragment } = react;
        const {
          deriveds = {},
          derivedsOptions,
          memo = true,
          propsAreEqual,
          isPropsProxy = false,
          fallback = (err, info) => renderFallback(apiCtx, err, info),
          rebuild
        } = options || {};
        const { atoms, atomsOptions, atomKeys, atomKey } = mergeAtoms(apiCtx, options);
        const ToBeExtendedClass = isPropsProxy === false ? ClassComp : PureComponent;
        class HeluxClass extends ToBeExtendedClass {
          constructor(props, context) {
            const hx = { atom: {}, atoms: {}, deriveds: {} };
            atomKeys.forEach((key) => {
              const atom2 = atoms[key];
              const internal = getInternal(atom2);
              if (!internal) {
                throw new Error("not an atom!");
              }
              hx.atoms[key] = {
                state: internal.sharedState,
                setState: internal.setState,
                time: Date.now(),
                isAtom: internal.forAtom,
                setDraft: internal.setDraft,
                insKey: 0,
                sn: 0,
                getDeps: () => [],
                getPrevDeps: () => []
              };
            });
            Object.keys(deriveds).forEach((key) => {
              const derived = deriveds[key];
              if (!isDerivedResult(derived)) {
                throw new Error("not a derived atom!");
              }
              const val = isDerivedAtom(derived) ? derived.val : derived;
              hx.deriveds[key] = [val, { loading: false, err: null, ok: true }, { time: 0, insKey: 0, sn: 0, getDeps: () => [] }];
            });
            super(props, { ...context, hx });
            __publicField(this, "AtomComp");
            /** hx is short for helux class component atom ctx */
            __publicField(this, "hx", { atom: {}, atoms: {}, deriveds: {} });
            __publicField(this, "state", { [CLASS_ERROR]: null, [CLASS_ERROR_INFO]: null });
            Object.assign(this.hx, hx);
            const AtomComp = makeAtomFnComp(apiCtx, ClassRenderer, {
              atomKey,
              atomKeys,
              atoms,
              atomsOptions,
              deriveds,
              derivedsOptions,
              hx: this.hx,
              rebuild,
              // 注意此处不能直接传递句柄，否则可能造成this丢失然后报错
              // Uncaught TypeError: this.setState is not a function
              onError: (err, info) => this.onError(err, info),
              fallback,
              forClass: true
            });
            this.AtomComp = AtomComp;
          }
          // 这一行不能注释掉，否则 isPropsProxy=true 且 rebuild=false 时，错误将不能被捕捉到
          static getDerivedStateFromError(err) {
            var _a;
            (_a = super.getDerivedStateFromError) == null ? void 0 : _a.call(this, err);
            return { [CLASS_ERROR]: err };
          }
          componentDidCatch(error, errorInfo) {
            var _a;
            (_a = super.componentDidCatch) == null ? void 0 : _a.call(this, error, errorInfo);
          }
          componentDidMount() {
            var _a;
            (_a = super.componentDidMount) == null ? void 0 : _a.call(this);
          }
          componentDidUpdate(prevProps, prevState, snapshot) {
            var _a;
            (_a = super.componentDidUpdate) == null ? void 0 : _a.call(this, prevProps, prevState, snapshot);
          }
          componentWillUnmount() {
            var _a;
            (_a = super.componentWillUnmount) == null ? void 0 : _a.call(this);
          }
          onError(error, info) {
            this.setState({ [CLASS_ERROR]: error, [CLASS_ERROR_INFO]: info });
            this.forceUpdate();
          }
          getError() {
            const { [CLASS_ERROR]: error, [CLASS_ERROR_INFO]: info } = this.state;
            return { error, info };
          }
          render() {
            const { error, info } = this.getError();
            if (error) {
              return fallback(error, info);
            }
            let renderUI;
            if (isPropsProxy === false) {
              renderUI = () => createElement(Fragment, {}, super.render());
            } else {
              renderUI = () => createElement(ClassComp, { ...this.props, hx: this.hx });
            }
            return createElement(this.AtomComp, { renderUI });
          }
        }
        HeluxClass.displayName = "HeluxClass";
        return memo ? react.memo(HeluxClass, propsAreEqual) : HeluxClass;
      }
      function defineStore(apiCtx) {
        return (options) => {
          const { stateOptions, derivedOptions, moduleName, lifecycle = {} } = options;
          const ctx2 = sharex(apiCtx, options.state, { moduleName, ...stateOptions || {} });
          const { state, reactive } = ctx2;
          ctx2.defineLifecycle(lifecycle);
          const derivedDef = options.derived || {};
          const mutateDeriveInput = {};
          const derivedStateInit = {};
          const getDerived = () => dm.derivedState;
          Object.keys(derivedDef).forEach((key) => {
            derivedStateInit[key] = void 0;
            mutateDeriveInput[key] = (draft) => {
              draft[key] = derivedDef[key]({ state, getDerived });
            };
          });
          const dm = ctx2.defineMutateDerive(derivedStateInit, derivedOptions)(mutateDeriveInput);
          const actionsDef = options.actions || {};
          const actionsInput = {};
          Object.keys(actionsDef).forEach((key) => {
            actionsInput[key] = ({ draft, payload }) => {
              return options.actions[key]({ state: draft, payload, derived: dm.derivedState });
            };
          });
          const { actions, useLoading, getLoading } = ctx2.defineActions()(actionsInput);
          return {
            useState: () => {
              const tuple = ctx2.useState();
              return tuple;
            },
            useDerived: () => {
              const [derived] = dm.useDerivedState();
              return derived;
            },
            useLoading,
            actions,
            state,
            reactive,
            derived: dm.derivedState,
            getLoading,
            // 提供给 class 组件绑定 store 之用
            withStore: (ClassComp, options2) => withAtom(ClassComp, { ...options2 || {}, atom: state, derivedAtom: dm.derivedState })
          };
        };
      }
      function innerCreate2(target, options) {
        const { label, isSyncer } = options;
        const internal = checkSharedStrict(target, { label });
        const fn = isSyncer ? createSyncerBuilder : createSyncFnBuilder;
        return fn(internal);
      }
      function sync(target) {
        return innerCreate2(target, { label: "sync" });
      }
      function syncer(target) {
        return innerCreate2(target, { label: "syncer", isSyncer: true });
      }
      var SIZE_LIMIT2 = 100;
      var EXPIRE_LIMIT = 5e3;
      function newBlockCtx(key, enableStatus) {
        return {
          key,
          results: [],
          depKeys: [],
          enableStatus,
          collected: false,
          mounted: false,
          renderAtomOnce: false,
          time: 0,
          status: { loading: false, err: null, ok: true }
        };
      }
      function initBlockCtx(isDynamic, enableStatus = false) {
        const blockScope = getBlockScope();
        if (isDynamic) {
          blockScope.initCount += 1;
        }
        const blockKey = genBlockKey();
        const blockCtx = newBlockCtx(blockKey, enableStatus);
        if (!RUN_AT_SERVER) {
          getBlockCtxMap(isDynamic).set(blockKey, blockCtx);
        }
        return blockCtx;
      }
      function markBlockMounted(blockCtx) {
        const blockScope = getBlockScope();
        blockCtx.mounted = true;
        blockCtx.time = Date.now();
        blockScope.mountedCount += 1;
      }
      function delBlockCtx(blockBey, isDynamic) {
        const blockScope = getBlockScope();
        const map = getBlockCtxMap(isDynamic);
        map.delete(blockBey);
        if (isDynamic && map.size === SIZE_LIMIT2 && blockScope.initCount - blockScope.mountedCount > 2) {
          blockScope.initCount = 0;
          blockScope.mountedCount = 0;
          const now = Date.now();
          map.forEach((item, key) => {
            if (!item.mounted && now - item.time > EXPIRE_LIMIT) {
              map.delete(key);
            }
          });
        }
      }
      function markBlockFnStart(blockCtx, isDynamic) {
        const blockScope = getBlockScope();
        blockScope.runningKey = blockCtx.key;
        blockScope.isDynamic = isDynamic;
      }
      function markBlockFnEnd(blockCtx) {
        const blockScope = getBlockScope();
        blockScope.runningKey = "";
        blockScope.isDynamic = false;
        blockCtx.collected = true;
      }
      function useStateDep(apiCtx, blockCtx, forceUpdate) {
        useWatchSimpleLogic(apiCtx, forceUpdate, { manualDepKeys: blockCtx.depKeys });
      }
      function useDep(apiCtx, blockCtx, forceUpdate) {
        let status = { loading: false, err: null, ok: true };
        useStateDep(apiCtx, blockCtx, forceUpdate);
        blockCtx.results.forEach((result) => {
          const fnCtx = useDerivedSimpleLogic(apiCtx, { result, forAtom: isDerivedAtom(result), showLoading: blockCtx.enableStatus });
          if (!fnCtx.status.ok) {
            status = fnCtx.status;
          }
        });
        return status;
      }
      function useDelBlockCtxEffect(apiCtx, blockCtx, isDynamic) {
        apiCtx.react.useEffect(() => {
          if (!blockCtx.mounted) {
            markBlockMounted(blockCtx);
          }
          return () => {
            delBlockCtx(blockCtx.key, isDynamic);
          };
        }, [blockCtx]);
      }
      var alwaysEqual = () => true;
      var noopVal = (val) => val;
      function getAllPath(keyPath) {
        const paths = [];
        for (let i2 = 1; i2 <= keyPath.length; i2++) {
          paths.push(keyPath.slice(0, i2));
        }
        return paths;
      }
      function wrapComp(apiCtx, Comp, displayName, needMemo, compare) {
        const CompVar = Comp;
        CompVar.displayName = displayName;
        return apiCtx.react.memo(CompVar, compare);
      }
      function wrapSignalComp(apiCtx, options) {
        const { sharedState, depKey, keyPath, compare, sharedKey, format = noopVal } = options;
        const Comp = function() {
          const insCtx = useAtomSimpleLogic(apiCtx, sharedState, { arrDep: true });
          if (insCtx.isFirstRender) {
            if (keyPath.length >= 2) {
              const paths = getAllPath(keyPath);
              paths.forEach((keyPath2) => {
                insCtx.recordDep(
                  {
                    sharedKey,
                    depKey: getDepKeyByPath(keyPath2, sharedKey),
                    keyPath: keyPath2,
                    parentKeyPath: keyPath2.slice(0, keyPath2.length - 1)
                  },
                  DICT
                );
              });
            } else {
              insCtx.recordDep({ sharedKey, depKey, keyPath });
            }
          }
          const val = M$1(insCtx.internal.rawState, keyPath);
          return format(val);
        };
        return wrapComp(apiCtx, Comp, "HeluxSignal", true, compare);
      }
      function wrapDerivedAtomSignalComp(apiCtx, options) {
        const Comp = function() {
          const { result, format = noopVal } = options;
          const fnCtx = useDerivedSimpleLogic(apiCtx, { result, forAtom: true });
          return format(fnCtx.proxyResult.val);
        };
        return wrapComp(apiCtx, Comp, "HeluxDerivedAtomSignal", true, options.compare);
      }
      function wrapDerivedSignalComp(apiCtx, options) {
        const Comp = function() {
          const { result, keyPath, format = noopVal } = options;
          useDerivedSimpleLogic(apiCtx, { result, forAtom: false });
          return format(M$1(result, keyPath));
        };
        return wrapComp(apiCtx, Comp, "HeluxDerivedSignal", true, options.compare);
      }
      function markBlockAndRunCb(blockCtx, options) {
        const { isDynamic, cb, props, ref } = options;
        const { collected, status } = blockCtx;
        if (!collected) {
          markBlockFnStart(blockCtx, isDynamic);
        }
        const blockParams = { props, status, read: l$2, ref };
        const result = cb(props, blockParams) || "";
        if (!collected) {
          markBlockFnEnd(blockCtx);
        }
        return result;
      }
      function renderResult(apiCtx, blockCtx, result) {
        const isDerivedAtomResult = isDerivedAtom(result);
        if (blockCtx.renderAtomOnce && !isDerivedAtomResult) {
          throw new Error("block cb once returned derived atom but not keep to return it in new render period!");
        }
        if (isDerivedAtomResult) {
          blockCtx.renderAtomOnce = true;
          const Comp = wrapDerivedAtomSignalComp(apiCtx, { result });
          return apiCtx.react.createElement(Comp, { status: { loading: false, err: null, ok: true } });
        }
        return getAtom(result);
      }
      function makeBlockComp(apiCtx, blockCtx, factory, options) {
        const { memo = true, compare } = options || {};
        const { key } = blockCtx;
        const { react } = apiCtx;
        const forwardRef = react.forwardRef || f$2;
        const Comp = factory();
        let RefComp = forwardRef(Comp);
        if (g$1()) {
          Comp.displayName = "HeluxKeyedBlockForHMR";
          RefComp = forwardRef((props, ref) => {
            if (ref && _$1(ref, "current")) {
              blockCtx.ref = ref;
            }
            return react.createElement(Comp, { ...props, key });
          });
        }
        const Block = memo ? react.memo(RefComp, compare) : RefComp;
        Block.displayName = "HeluxBlock";
        Block[IS_BLOCK] = true;
        return Block;
      }
      function blockNormalLogic(innerOptions, options) {
        const { cb, isDynamic, apiCtx, blockCtx } = innerOptions;
        const { useForceUpdate } = apiCtx.hookImpl;
        const useDelCtxEffect = isDynamic ? useDelBlockCtxEffect : f$2;
        return makeBlockComp(
          apiCtx,
          blockCtx,
          () => {
            return (props, inputRef) => {
              const ref = blockCtx.ref || inputRef;
              const result = markBlockAndRunCb(blockCtx, { isDynamic, cb, props, ref });
              const forceUpdate = useForceUpdate();
              useDep(apiCtx, blockCtx, forceUpdate);
              useDelCtxEffect(apiCtx, blockCtx, isDynamic);
              return renderResult(apiCtx, blockCtx, result);
            };
          },
          options
        );
      }
      function blockStatusLogic(innerOptions, options) {
        const { cb, isDynamic, apiCtx, blockCtx } = innerOptions;
        const useDelCtxEffect = isDynamic ? useDelBlockCtxEffect : f$2;
        const { useForceUpdate } = apiCtx.hookImpl;
        const { useEffect: useEffect2 } = apiCtx.react;
        return makeBlockComp(
          apiCtx,
          blockCtx,
          () => {
            return (props, inputRef) => {
              const ref = blockCtx.ref || inputRef;
              const result = markBlockAndRunCb(blockCtx, { isDynamic, cb, props, ref });
              const forceUpdate = useForceUpdate();
              const status = useDep(apiCtx, blockCtx, forceUpdate);
              useDelCtxEffect(apiCtx, blockCtx, isDynamic);
              const prevLoading = blockCtx.status.loading;
              const currLoading = status.loading;
              useEffect2(() => {
                if (prevLoading !== currLoading) {
                  forceUpdate();
                }
              }, [prevLoading, currLoading]);
              blockCtx.status = status;
              return renderResult(apiCtx, blockCtx, result);
            };
          },
          options
        );
      }
      function blockLogic(innerOptions, blockOptions) {
        const stdOptions = parseBlockOptions(blockOptions);
        const { enableStatus } = stdOptions;
        const logicOpts = { ...innerOptions, blockCtx: initBlockCtx(innerOptions.isDynamic, enableStatus) };
        if (!enableStatus) {
          return blockNormalLogic(logicOpts, stdOptions);
        }
        return blockStatusLogic(logicOpts, stdOptions);
      }
      function block(apiCtx, cb, options) {
        const Block = blockLogic({ apiCtx, isDynamic: false, cb }, options);
        return Block;
      }
      function dynamicBlock(apiCtx, cb, options) {
        const Block = blockLogic({ apiCtx, isDynamic: true, cb }, options);
        return Block;
      }
      function signal(apiCtx, input, format) {
        const { react } = apiCtx;
        if (input && input[IS_BLOCK]) {
          return react.createElement(input);
        }
        const compare = alwaysEqual;
        if (w$2(input)) {
          const Comp = dynamicBlock(apiCtx, input, { compare });
          return react.createElement(Comp);
        }
        if (isDerivedAtom(input)) {
          const Comp = wrapDerivedAtomSignalComp(apiCtx, { result: input, compare, format });
          return react.createElement(Comp);
        }
        if (isAtom(input)) {
          const sharedKey2 = getSharedKey(input);
          const depKey2 = B$1("val", sharedKey2);
          const options = { sharedKey: sharedKey2, sharedState: input, depKey: depKey2, keyPath: ["val"], compare, format };
          const Comp = wrapSignalComp(apiCtx, options);
          return react.createElement(Comp);
        }
        const readedInfo = getLastest();
        const { sharedKey, val, stateOrResult, depKey, keyPath, isDerivedResult: isDerivedResult2 } = readedInfo;
        if (input === val && stateOrResult) {
          if (readedInfo.isDerivedAtom) {
            const Comp2 = wrapDerivedAtomSignalComp(apiCtx, { result: stateOrResult, compare, format });
            return react.createElement(Comp2);
          }
          if (isDerivedResult2) {
            const Comp2 = wrapDerivedSignalComp(apiCtx, { result: stateOrResult, keyPath, compare, format });
            return react.createElement(Comp2);
          }
          const Comp = wrapSignalComp(apiCtx, { sharedKey, sharedState: stateOrResult, depKey, keyPath, compare, format });
          return react.createElement(Comp);
        }
        return input;
      }
      var { shallowCompare, isDiff, isDraft } = limuUtils;
      var createShared = share;
      var $$1 = signal;
      var cst = {
        EVENT_NAME,
        RECORD_LOADING,
        VER,
        LIMU_VER
      };
      function createModelLogic(baseApi, cb, extra) {
        return cb(baseApi, extra);
      }
      function model(baseApi, cb) {
        return createModelLogic(baseApi, cb);
      }
      function modelFactory(baseApi, factory) {
        return {
          build: (extra) => {
            return createModelLogic(baseApi, factory, extra);
          }
        };
      }
      var needApiCtxFns = [
        "atom",
        "atomx",
        "share",
        "sharex",
        "defineStore",
        "bindAtom",
        "withAtom",
        "getMutateLoading",
        "getActionLoading",
        "$",
        "signal",
        "block",
        "blockStatus",
        "dynamicBlock",
        "dynamicBlockStatus"
      ];
      function shouldInjectApiCtx(key) {
        return key.startsWith("use") || needApiCtxFns.includes(key);
      }
      function to18(react) {
        return Object.assign({ useSyncExternalStore: f$2 }, react);
      }
      function buildHeluxApi(react, act) {
        const hookImpl = S$1(react);
        const baseApi = { ...hookImpl };
        const apiCtx = { react: to18(react), hookImpl, act };
        if (act) {
          hookImpl.useForceUpdate = () => {
            const [, set] = react.useState({});
            return () => act(() => set({}));
          };
        }
        const apiVar = api_exports;
        Object.keys(apiVar).forEach((key) => {
          const val = apiVar[key];
          if (shouldInjectApiCtx(key)) {
            baseApi[key] = val.bind(null, apiCtx);
          } else {
            baseApi[key] = val;
          }
        });
        const allApi = {
          model: (cb) => model(baseApi, cb),
          modelFactory: (cb) => modelFactory(baseApi, cb)
        };
        return Object.assign(allApi, baseApi);
      }
      function initHeluxContext(options) {
        const { inited: inited2, API: API2 } = getRootData();
        if (inited2) return API2;
        const { heluxCtxKey, standalone, transfer, reactLib, act } = options;
        const existedRoot = u$3[heluxCtxKey];
        const done = (key, root) => {
          const ROOT2 = root || createRoot();
          if (!ROOT2.modMap) {
            ROOT2.modMap = /* @__PURE__ */ new Map();
          }
          const api = buildHeluxApi(reactLib, act);
          setRootData({ ROOT: ROOT2, inited: true, api });
          u$3[key] = ROOT2;
          return api;
        };
        if (!existedRoot) {
          return done(heluxCtxKey);
        }
        if (standalone) {
          return done(`${String(heluxCtxKey)}_${Date.now()}`);
        }
        if (transfer) {
          const ROOT2 = createRoot();
          setRootData({ ROOT: ROOT2, inited: true });
          transfer(existedRoot, ROOT2);
        }
        return done(heluxCtxKey, existedRoot);
      }
      var a$1 = initHeluxContext({ heluxCtxKey: "__HELUX__", reactLib: require$$0__default__namespace });
      a$1.share;
      var { atom: s, atomx: o$1, share: r, sharex: u$1, defineStore: c$1, derive: n, deriveDict: d, defineDeriveTask: m, defineDeriveFnItem: l, runDerive: f, runDeriveTask: v, watch: g, watchEffect: h, useAtom: D, useAtomX: A$1, useReactive: p, useReactiveX: L, useDerived: b, useWatch: S, useWatchEffect: k, useGlobalId: w, useService: M, useOnEvent: x, useMutable: y, useMutateLoading: E, useActionLoading: F, useEffect: R, useLayoutEffect: X, useStable: T, useObject: _, useLocalForceUpdate: H, useGlobalForceUpdate: I, bindAtom: O, withAtom: U, assignThisHX: W, getHX: C, makeWithAtomOptions: G, action: j, signal: B, block: K, dynamicBlock: P, $, mutate: q, mutateDict: z, runMutate: J, runMutateTask: N, defineMutateFnItem: Q, sync: V, syncer: Y, model: Z, modelFactory: ee, emit: te, on: ae, init: ie, reactiveDesc: se, flush: oe, isAtom: re, isSharedState: ue, isDerivedAtom: ce, isDerivedResult: ne, isDraft: de, storeSrv: me, shallowCompare: le, markRaw: fe, isDiff: ve, produce: ge, getMutateLoading: he, getActionLoading: De, getDeriveLoading: Ae, getRawState: pe, getSnap: Le, getAtom: be, addMiddleware: Se, addPlugin: ke, cst: we } = a$1;
      function i(e2, t2) {
        const { state: r2, getters: s2 = {}, actions: n2 = {}, lifecycle: i2 = {} } = t2;
        let c2 = r2;
        "function" != typeof r2 && (c2 = () => r2);
        const o2 = c2(), a2 = s2, u2 = n2, d2 = i2;
        {
          const e3 = (f2 = o2, Object.keys(f2)).concat(a2).concat(u2).concat(d2), t3 = Array.from(new Set(e3));
          if (e3.length > t3.length) throw new Error("[defineStore error]: found duplicate keys in state, getters, actions, lifecycle!");
          Object.keys(a2).forEach((e4) => {
            o2[e4] = void 0;
          });
        }
        var f2;
        return { stateFn: c2, firstVerState: o2, userGetters: a2, userActions: u2, lifecycle: i2 };
      }
      function c(e2, t2, r2) {
        const { userGetters: s2, derived: n2, userActions: i2, wrapActions: c2 } = t2;
        return new Proxy({}, { get(t3, o2) {
          if (r2 && "state" === o2) return e2;
          if (o2 in e2) return e2[o2];
          if (o2 in s2) return n2[o2];
          if (o2 in i2) {
            return c2[o2];
          }
          return t3[o2];
        }, set: (t3, r3, s3) => r3 in e2 ? (e2[r3] = s3, true) : (console.warn("can not set"), false) });
      }
      function o(e2, t2, r2) {
        const { userActions: s2, userGetters: n2, derived: i2 } = t2, o2 = {};
        let a2 = {};
        Object.keys(s2).forEach((e3) => {
          o2[e3] = ({ draft: t3, payload: o3 }) => {
            const u3 = c(t3, { userGetters: n2, derived: i2, userActions: s2, wrapActions: a2 }, r2);
            return s2[e3].bind(u3).apply(null, o3);
          };
        });
        const { actions: u2, getLoading: d2, useLoading: f2 } = e2.defineActions(false, true)(o2);
        return a2 = u2, { wrapActions: u2, getLoading: d2, useLoading: f2 };
      }
      function a(e2, t2, r2) {
        const { userGetters: s2, userActions: n2 } = t2, { state: i2 } = e2, a2 = {};
        return Object.keys(s2).forEach((e3) => {
          a2[e3] = (t3) => {
            const r3 = c(t3, { userGetters: s2, derived: t3, userActions: n2, wrapActions: {} }), i3 = s2[e3].bind(r3);
            t3[e3] = i3(t3);
          };
        }), e2.defineMutateSelf()(a2), { derivedState: i2, useDerivedState: () => {
        } };
      }
      function u(e2, t2, r2) {
        const { userGetters: s2, userActions: n2, wrapActions: i2, isLayered: o2, derived: a2 } = r2, { reactive: u2 } = e2, d2 = t2, f2 = {};
        Object.keys(t2).forEach((e3) => {
          f2[e3] = (t3) => {
            const r3 = c(u2, { userGetters: s2, derived: a2, userActions: n2, wrapActions: i2 }, o2);
            d2[e3].bind(r3)(t3);
          };
        }), e2.defineLifecycle(f2);
      }
      function A(e2, t2) {
        const { firstVerState: r2, lifecycle: s2, userGetters: n2, userActions: d2, stateFn: A2 } = i(false, t2), g2 = u$1(r2, { moduleName: e2 }), { state: S2 } = g2, { derivedState: l2 } = a(g2, { userGetters: n2, userActions: d2 }), { wrapActions: p2, getLoading: G2, useLoading: y2 } = o(g2, { userGetters: n2, derived: l2, userActions: d2 });
        return u(g2, s2, { userGetters: n2, userActions: d2, wrapActions: p2 }), { getStore: () => c(g2.reactive, { userGetters: n2, derived: g2.reactive, userActions: d2, wrapActions: p2 }), useStore: (e3) => {
          const [t3] = g2.useReactive(e3);
          return c(t3, { userGetters: n2, derived: t3, userActions: d2, wrapActions: p2 });
        }, getLoading: G2, useLoading: y2, reset: () => {
          g2.setState(A2());
        }, getSnap: (e3 = true) => Le(S2, !e3), getGettersSnap: (e3 = true) => Le(S2, !e3), state: S2, reactive: g2.reactive, getters: S2, actions: p2, reactiveDesc: g2.reactiveDesc };
      }
      var _GM_getValue = /* @__PURE__ */ (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_notification = /* @__PURE__ */ (() => typeof GM_notification != "undefined" ? GM_notification : void 0)();
      var _GM_setValue = /* @__PURE__ */ (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      function showNotification(message, duration = 3e3) {
        const existingNotification = document.querySelector(
          ".yapi-helper-notification"
        );
        if (existingNotification) {
          existingNotification.remove();
        }
        const notification = document.createElement("div");
        notification.className = "yapi-helper-notification";
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => {
          notification.classList.add("show");
        }, 10);
        setTimeout(() => {
          notification.classList.remove("show");
          setTimeout(() => {
            notification.remove();
          }, 300);
        }, duration);
      }
      function sendSystemNotification(title, message) {
        try {
          if (typeof _GM_notification === "function") {
            _GM_notification({
              text: message,
              title,
              timeout: 5e3,
              onclick: function() {
                console.log("用户点击了通知");
              }
            });
          } else if ("Notification" in window && Notification.permission === "granted") {
            new Notification(title, {
              body: message
            });
          } else if ("Notification" in window && Notification.permission !== "denied") {
            Notification.requestPermission().then((permission) => {
              if (permission === "granted") {
                new Notification(title, {
                  body: message
                });
              }
            });
          }
        } catch (e2) {
          console.warn("系统通知不可用:", e2);
        }
      }
      (function(f2) {
        if (typeof exports === "object" && typeof module !== "undefined") {
          module.exports = f2();
        } else if (typeof define === "function" && define.amd) {
          define([], f2);
        } else {
          var g2;
          if (typeof window !== "undefined") {
            g2 = window;
          } else if (typeof global !== "undefined") {
            g2 = global;
          } else if (typeof self !== "undefined") {
            g2 = self;
          } else {
            g2 = this;
          }
          g2.jstt = f2();
        }
      })(function() {
        return (/* @__PURE__ */ function() {
          function r2(e2, n2, t2) {
            function o2(i22, f2) {
              if (!n2[i22]) {
                if (!e2[i22]) {
                  var c2 = "function" == typeof require && require;
                  if (!f2 && c2) return c2(i22, true);
                  if (u2) return u2(i22, true);
                  var a2 = new Error("Cannot find module '" + i22 + "'");
                  throw a2.code = "MODULE_NOT_FOUND", a2;
                }
                var p2 = n2[i22] = { exports: {} };
                e2[i22][0].call(p2.exports, function(r22) {
                  var n22 = e2[i22][1][r22];
                  return o2(n22 || r22);
                }, p2, p2.exports, r2, e2, n2, t2);
              }
              return n2[i22].exports;
            }
            for (var u2 = "function" == typeof require && require, i2 = 0; i2 < t2.length; i2++) o2(t2[i2]);
            return o2;
          }
          return r2;
        }())({ 1: [function(require2, module3, exports3) {
          const $Ref = require2("./ref");
          const Pointer = require2("./pointer");
          const url = require2("./util/url");
          module3.exports = bundle;
          function bundle(parser, options) {
            let inventory = [];
            crawl(parser, "schema", parser.$refs._root$Ref.path + "#", "#", 0, inventory, parser.$refs, options);
            remap(inventory);
          }
          function crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {
            let obj = key === null ? parent : parent[key];
            if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj)) {
              if ($Ref.isAllowed$Ref(obj)) {
                inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);
              } else {
                let keys = Object.keys(obj).sort((a2, b2) => {
                  if (a2 === "definitions") {
                    return -1;
                  } else if (b2 === "definitions") {
                    return 1;
                  } else {
                    return a2.length - b2.length;
                  }
                });
                for (let key2 of keys) {
                  let keyPath = Pointer.join(path, key2);
                  let keyPathFromRoot = Pointer.join(pathFromRoot, key2);
                  let value = obj[key2];
                  if ($Ref.isAllowed$Ref(value)) {
                    inventory$Ref(obj, key2, path, keyPathFromRoot, indirections, inventory, $refs, options);
                  } else {
                    crawl(obj, key2, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);
                  }
                }
              }
            }
          }
          function inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {
            let $ref = $refKey === null ? $refParent : $refParent[$refKey];
            let $refPath = url.resolve(path, $ref.$ref);
            let pointer = $refs._resolve($refPath, pathFromRoot, options);
            if (pointer === null) {
              return;
            }
            let depth = Pointer.parse(pathFromRoot).length;
            let file = url.stripHash(pointer.path);
            let hash = url.getHash(pointer.path);
            let external = file !== $refs._root$Ref.path;
            let extended = $Ref.isExtended$Ref($ref);
            indirections += pointer.indirections;
            let existingEntry = findInInventory(inventory, $refParent, $refKey);
            if (existingEntry) {
              if (depth < existingEntry.depth || indirections < existingEntry.indirections) {
                removeFromInventory(inventory, existingEntry);
              } else {
                return;
              }
            }
            inventory.push({
              $ref,
              // The JSON Reference (e.g. {$ref: string})
              parent: $refParent,
              // The object that contains this $ref pointer
              key: $refKey,
              // The key in `parent` that is the $ref pointer
              pathFromRoot,
              // The path to the $ref pointer, from the JSON Schema root
              depth,
              // How far from the JSON Schema root is this $ref pointer?
              file,
              // The file that the $ref pointer resolves to
              hash,
              // The hash within `file` that the $ref pointer resolves to
              value: pointer.value,
              // The resolved value of the $ref pointer
              circular: pointer.circular,
              // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
              extended,
              // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
              external,
              // Does this $ref pointer point to a file other than the main JSON Schema file?
              indirections
              // The number of indirect references that were traversed to resolve the value
            });
            if (!existingEntry) {
              crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);
            }
          }
          function remap(inventory) {
            inventory.sort((a2, b2) => {
              if (a2.file !== b2.file) {
                return a2.file < b2.file ? -1 : 1;
              } else if (a2.hash !== b2.hash) {
                return a2.hash < b2.hash ? -1 : 1;
              } else if (a2.circular !== b2.circular) {
                return a2.circular ? -1 : 1;
              } else if (a2.extended !== b2.extended) {
                return a2.extended ? 1 : -1;
              } else if (a2.indirections !== b2.indirections) {
                return a2.indirections - b2.indirections;
              } else if (a2.depth !== b2.depth) {
                return a2.depth - b2.depth;
              } else {
                let aDefinitionsIndex = a2.pathFromRoot.lastIndexOf("/definitions");
                let bDefinitionsIndex = b2.pathFromRoot.lastIndexOf("/definitions");
                if (aDefinitionsIndex !== bDefinitionsIndex) {
                  return bDefinitionsIndex - aDefinitionsIndex;
                } else {
                  return a2.pathFromRoot.length - b2.pathFromRoot.length;
                }
              }
            });
            let file, hash, pathFromRoot;
            for (let entry of inventory) {
              if (!entry.external) {
                entry.$ref.$ref = entry.hash;
              } else if (entry.file === file && entry.hash === hash) {
                entry.$ref.$ref = pathFromRoot;
              } else if (entry.file === file && entry.hash.indexOf(hash + "/") === 0) {
                entry.$ref.$ref = Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, "#")));
              } else {
                file = entry.file;
                hash = entry.hash;
                pathFromRoot = entry.pathFromRoot;
                entry.$ref = entry.parent[entry.key] = $Ref.dereference(entry.$ref, entry.value);
                if (entry.circular) {
                  entry.$ref.$ref = entry.pathFromRoot;
                }
              }
            }
          }
          function findInInventory(inventory, $refParent, $refKey) {
            for (let i2 = 0; i2 < inventory.length; i2++) {
              let existingEntry = inventory[i2];
              if (existingEntry.parent === $refParent && existingEntry.key === $refKey) {
                return existingEntry;
              }
            }
          }
          function removeFromInventory(inventory, entry) {
            let index = inventory.indexOf(entry);
            inventory.splice(index, 1);
          }
        }, { "./pointer": 11, "./ref": 12, "./util/url": 19 }], 2: [function(require2, module3, exports3) {
          const $Ref = require2("./ref");
          const Pointer = require2("./pointer");
          const { ono } = require2("@jsdevtools/ono");
          const url = require2("./util/url");
          module3.exports = dereference;
          function dereference(parser, options) {
            let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, "#", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Map(), parser.$refs, options);
            parser.$refs.circular = dereferenced.circular;
            parser.schema = dereferenced.value;
          }
          function crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
            let dereferenced;
            let result = {
              value: obj,
              circular: false
            };
            let isExcludedPath = options.dereference.excludedPathMatcher;
            if (options.dereference.circular === "ignore" || !processedObjects.has(obj)) {
              if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {
                parents.add(obj);
                processedObjects.add(obj);
                if ($Ref.isAllowed$Ref(obj, options)) {
                  dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
                  result.circular = dereferenced.circular;
                  result.value = dereferenced.value;
                } else {
                  for (const key of Object.keys(obj)) {
                    let keyPath = Pointer.join(path, key);
                    let keyPathFromRoot = Pointer.join(pathFromRoot, key);
                    if (isExcludedPath(keyPathFromRoot)) {
                      continue;
                    }
                    let value = obj[key];
                    let circular = false;
                    if ($Ref.isAllowed$Ref(value, options)) {
                      dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
                      circular = dereferenced.circular;
                      if (obj[key] !== dereferenced.value) {
                        obj[key] = dereferenced.value;
                        if (options.dereference.onDereference) {
                          options.dereference.onDereference(value.$ref, obj[key]);
                        }
                      }
                    } else {
                      if (!parents.has(value)) {
                        dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
                        circular = dereferenced.circular;
                        if (obj[key] !== dereferenced.value) {
                          obj[key] = dereferenced.value;
                        }
                      } else {
                        circular = foundCircularReference(keyPath, $refs, options);
                      }
                    }
                    result.circular = result.circular || circular;
                  }
                }
                parents.delete(obj);
              }
            }
            return result;
          }
          function dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options) {
            let $refPath = url.resolve(path, $ref.$ref);
            const cache = dereferencedCache.get($refPath);
            if (cache) {
              const refKeys = Object.keys($ref);
              if (refKeys.length > 1) {
                const extraKeys = {};
                for (let key of refKeys) {
                  if (key !== "$ref" && !(key in cache.value)) {
                    extraKeys[key] = $ref[key];
                  }
                }
                return {
                  circular: cache.circular,
                  value: Object.assign({}, cache.value, extraKeys)
                };
              }
              return cache;
            }
            let pointer = $refs._resolve($refPath, path, options);
            if (pointer === null) {
              return {
                circular: false,
                value: null
              };
            }
            let directCircular = pointer.circular;
            let circular = directCircular || parents.has(pointer.value);
            circular && foundCircularReference(path, $refs, options);
            let dereferencedValue = $Ref.dereference($ref, pointer.value);
            if (!circular) {
              let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options);
              circular = dereferenced.circular;
              dereferencedValue = dereferenced.value;
            }
            if (circular && !directCircular && options.dereference.circular === "ignore") {
              dereferencedValue = $ref;
            }
            if (directCircular) {
              dereferencedValue.$ref = pathFromRoot;
            }
            const dereferencedObject = {
              circular,
              value: dereferencedValue
            };
            if (Object.keys($ref).length === 1) {
              dereferencedCache.set($refPath, dereferencedObject);
            }
            return dereferencedObject;
          }
          function foundCircularReference(keyPath, $refs, options) {
            $refs.circular = true;
            if (!options.dereference.circular) {
              throw ono.reference(`Circular $ref pointer found at ${keyPath}`);
            }
            return true;
          }
        }, { "./pointer": 11, "./ref": 12, "./util/url": 19, "@jsdevtools/ono": 22 }], 3: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              const $Refs = require2("./refs");
              const _parse = require2("./parse");
              const normalizeArgs = require2("./normalize-args");
              const resolveExternal = require2("./resolve-external");
              const _bundle = require2("./bundle");
              const _dereference = require2("./dereference");
              const url = require2("./util/url");
              const { JSONParserError, InvalidPointerError, MissingPointerError, ResolverError, ParserError, UnmatchedParserError, UnmatchedResolverError, isHandledError, JSONParserErrorGroup } = require2("./util/errors");
              const maybe = require2("call-me-maybe");
              const { ono } = require2("@jsdevtools/ono");
              module3.exports = $RefParser;
              module3.exports.default = $RefParser;
              module3.exports.JSONParserError = JSONParserError;
              module3.exports.InvalidPointerError = InvalidPointerError;
              module3.exports.MissingPointerError = MissingPointerError;
              module3.exports.ResolverError = ResolverError;
              module3.exports.ParserError = ParserError;
              module3.exports.UnmatchedParserError = UnmatchedParserError;
              module3.exports.UnmatchedResolverError = UnmatchedResolverError;
              function $RefParser() {
                this.schema = null;
                this.$refs = new $Refs();
              }
              $RefParser.parse = function parse(path, schema, options, callback) {
                let Class = this;
                let instance = new Class();
                return instance.parse.apply(instance, arguments);
              };
              $RefParser.prototype.parse = async function parse(path, schema, options, callback) {
                let args = normalizeArgs(arguments);
                let promise;
                if (!args.path && !args.schema) {
                  let err = ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);
                  return maybe(args.callback, Promise.reject(err));
                }
                this.schema = null;
                this.$refs = new $Refs();
                let pathType = "http";
                if (url.isFileSystemPath(args.path)) {
                  args.path = url.fromFileSystemPath(args.path);
                  pathType = "file";
                }
                args.path = url.resolve(url.cwd(), args.path);
                if (args.schema && typeof args.schema === "object") {
                  let $ref = this.$refs._add(args.path);
                  $ref.value = args.schema;
                  $ref.pathType = pathType;
                  promise = Promise.resolve(args.schema);
                } else {
                  promise = _parse(args.path, this.$refs, args.options);
                }
                let me2 = this;
                try {
                  let result = await promise;
                  if (result !== null && typeof result === "object" && !Buffer2.isBuffer(result)) {
                    me2.schema = result;
                    return maybe(args.callback, Promise.resolve(me2.schema));
                  } else if (args.options.continueOnError) {
                    me2.schema = null;
                    return maybe(args.callback, Promise.resolve(me2.schema));
                  } else {
                    throw ono.syntax(`"${me2.$refs._root$Ref.path || result}" is not a valid JSON Schema`);
                  }
                } catch (err) {
                  if (!args.options.continueOnError || !isHandledError(err)) {
                    return maybe(args.callback, Promise.reject(err));
                  }
                  if (this.$refs._$refs[url.stripHash(args.path)]) {
                    this.$refs._$refs[url.stripHash(args.path)].addError(err);
                  }
                  return maybe(args.callback, Promise.resolve(null));
                }
              };
              $RefParser.resolve = function resolve(path, schema, options, callback) {
                let Class = this;
                let instance = new Class();
                return instance.resolve.apply(instance, arguments);
              };
              $RefParser.prototype.resolve = async function resolve(path, schema, options, callback) {
                let me2 = this;
                let args = normalizeArgs(arguments);
                try {
                  await this.parse(args.path, args.schema, args.options);
                  await resolveExternal(me2, args.options);
                  finalize(me2);
                  return maybe(args.callback, Promise.resolve(me2.$refs));
                } catch (err) {
                  return maybe(args.callback, Promise.reject(err));
                }
              };
              $RefParser.bundle = function bundle(path, schema, options, callback) {
                let Class = this;
                let instance = new Class();
                return instance.bundle.apply(instance, arguments);
              };
              $RefParser.prototype.bundle = async function bundle(path, schema, options, callback) {
                let me2 = this;
                let args = normalizeArgs(arguments);
                try {
                  await this.resolve(args.path, args.schema, args.options);
                  _bundle(me2, args.options);
                  finalize(me2);
                  return maybe(args.callback, Promise.resolve(me2.schema));
                } catch (err) {
                  return maybe(args.callback, Promise.reject(err));
                }
              };
              $RefParser.dereference = function dereference(path, schema, options, callback) {
                let Class = this;
                let instance = new Class();
                return instance.dereference.apply(instance, arguments);
              };
              $RefParser.prototype.dereference = async function dereference(path, schema, options, callback) {
                let me2 = this;
                let args = normalizeArgs(arguments);
                try {
                  await this.resolve(args.path, args.schema, args.options);
                  _dereference(me2, args.options);
                  finalize(me2);
                  return maybe(args.callback, Promise.resolve(me2.schema));
                } catch (err) {
                  return maybe(args.callback, Promise.reject(err));
                }
              };
              function finalize(parser) {
                const errors = JSONParserErrorGroup.getParserErrors(parser);
                if (errors.length > 0) {
                  throw new JSONParserErrorGroup(parser);
                }
              }
            }).call(this);
          }).call(this, { "isBuffer": require2("../../../is-buffer/index.js") });
        }, { "../../../is-buffer/index.js": 197, "./bundle": 1, "./dereference": 2, "./normalize-args": 4, "./parse": 6, "./refs": 13, "./resolve-external": 14, "./util/errors": 17, "./util/url": 19, "@jsdevtools/ono": 22, "call-me-maybe": 38 }], 4: [function(require2, module3, exports3) {
          const Options = require2("./options");
          module3.exports = normalizeArgs;
          function normalizeArgs(args) {
            let path, schema, options, callback;
            args = Array.prototype.slice.call(args);
            if (typeof args[args.length - 1] === "function") {
              callback = args.pop();
            }
            if (typeof args[0] === "string") {
              path = args[0];
              if (typeof args[2] === "object") {
                schema = args[1];
                options = args[2];
              } else {
                schema = void 0;
                options = args[1];
              }
            } else {
              path = "";
              schema = args[0];
              options = args[1];
            }
            if (!(options instanceof Options)) {
              options = new Options(options);
            }
            return {
              path,
              schema,
              options,
              callback
            };
          }
        }, { "./options": 5 }], 5: [function(require2, module3, exports3) {
          const jsonParser = require2("./parsers/json");
          const yamlParser = require2("./parsers/yaml");
          const textParser = require2("./parsers/text");
          const binaryParser = require2("./parsers/binary");
          const fileResolver = require2("./resolvers/file");
          const httpResolver = require2("./resolvers/http");
          module3.exports = $RefParserOptions;
          function $RefParserOptions(options) {
            merge(this, $RefParserOptions.defaults);
            merge(this, options);
          }
          $RefParserOptions.defaults = {
            /**
             * Determines how different types of files will be parsed.
             *
             * You can add additional parsers of your own, replace an existing one with
             * your own implementation, or disable any parser by setting it to false.
             */
            parse: {
              json: jsonParser,
              yaml: yamlParser,
              text: textParser,
              binary: binaryParser
            },
            /**
             * Determines how JSON References will be resolved.
             *
             * You can add additional resolvers of your own, replace an existing one with
             * your own implementation, or disable any resolver by setting it to false.
             */
            resolve: {
              file: fileResolver,
              http: httpResolver,
              /**
               * Determines whether external $ref pointers will be resolved.
               * If this option is disabled, then none of above resolvers will be called.
               * Instead, external $ref pointers will simply be ignored.
               *
               * @type {boolean}
               */
              external: true
            },
            /**
             * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
             * causes it to keep processing as much as possible and then throw a single error that contains all errors
             * that were encountered.
            */
            continueOnError: false,
            /**
             * Determines the types of JSON references that are allowed.
             */
            dereference: {
              /**
               * Dereference circular (recursive) JSON references?
               * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
               * If "ignore", then circular references will not be dereferenced.
               *
               * @type {boolean|string}
               */
              circular: true,
              /**
               * A function, called for each path, which can return true to stop this path and all
               * subpaths from being dereferenced further. This is useful in schemas where some
               * subpaths contain literal $ref keys that should not be dereferenced.
               *
               * @type {function}
               */
              excludedPathMatcher: () => false
            }
          };
          function merge(target, source) {
            if (isMergeable(source)) {
              let keys = Object.keys(source);
              for (let i2 = 0; i2 < keys.length; i2++) {
                let key = keys[i2];
                let sourceSetting = source[key];
                let targetSetting = target[key];
                if (isMergeable(sourceSetting)) {
                  target[key] = merge(targetSetting || {}, sourceSetting);
                } else if (sourceSetting !== void 0) {
                  target[key] = sourceSetting;
                }
              }
            }
            return target;
          }
          function isMergeable(val) {
            return val && typeof val === "object" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);
          }
        }, { "./parsers/binary": 7, "./parsers/json": 8, "./parsers/text": 9, "./parsers/yaml": 10, "./resolvers/file": 15, "./resolvers/http": 16 }], 6: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              const { ono } = require2("@jsdevtools/ono");
              const url = require2("./util/url");
              const plugins = require2("./util/plugins");
              const { ResolverError, ParserError, UnmatchedParserError, UnmatchedResolverError, isHandledError } = require2("./util/errors");
              module3.exports = parse;
              async function parse(path, $refs, options) {
                path = url.stripHash(path);
                let $ref = $refs._add(path);
                let file = {
                  url: path,
                  extension: url.getExtension(path)
                };
                try {
                  const resolver = await readFile(file, options, $refs);
                  $ref.pathType = resolver.plugin.name;
                  file.data = resolver.result;
                  const parser = await parseFile(file, options, $refs);
                  $ref.value = parser.result;
                  return parser.result;
                } catch (err) {
                  if (isHandledError(err)) {
                    $ref.value = err;
                  }
                  throw err;
                }
              }
              function readFile(file, options, $refs) {
                return new Promise((resolve, reject) => {
                  let resolvers = plugins.all(options.resolve);
                  resolvers = plugins.filter(resolvers, "canRead", file);
                  plugins.sort(resolvers);
                  plugins.run(resolvers, "read", file, $refs).then(resolve, onError);
                  function onError(err) {
                    if (!err && options.continueOnError) {
                      reject(new UnmatchedResolverError(file.url));
                    } else if (!err || !("error" in err)) {
                      reject(ono.syntax(`Unable to resolve $ref pointer "${file.url}"`));
                    } else if (err.error instanceof ResolverError) {
                      reject(err.error);
                    } else {
                      reject(new ResolverError(err, file.url));
                    }
                  }
                });
              }
              function parseFile(file, options, $refs) {
                return new Promise((resolve, reject) => {
                  let allParsers = plugins.all(options.parse);
                  let filteredParsers = plugins.filter(allParsers, "canParse", file);
                  let parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;
                  plugins.sort(parsers);
                  plugins.run(parsers, "parse", file, $refs).then(onParsed, onError);
                  function onParsed(parser) {
                    if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {
                      reject(ono.syntax(`Error parsing "${file.url}" as ${parser.plugin.name}. 
Parsed value is empty`));
                    } else {
                      resolve(parser);
                    }
                  }
                  function onError(err) {
                    if (!err && options.continueOnError) {
                      reject(new UnmatchedParserError(file.url));
                    } else if (!err || !("error" in err)) {
                      reject(ono.syntax(`Unable to parse ${file.url}`));
                    } else if (err.error instanceof ParserError) {
                      reject(err.error);
                    } else {
                      reject(new ParserError(err.error.message, file.url));
                    }
                  }
                });
              }
              function isEmpty(value) {
                return value === void 0 || typeof value === "object" && Object.keys(value).length === 0 || typeof value === "string" && value.trim().length === 0 || Buffer2.isBuffer(value) && value.length === 0;
              }
            }).call(this);
          }).call(this, { "isBuffer": require2("../../../is-buffer/index.js") });
        }, { "../../../is-buffer/index.js": 197, "./util/errors": 17, "./util/plugins": 18, "./util/url": 19, "@jsdevtools/ono": 22 }], 7: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              let BINARY_REGEXP = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
              module3.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */
                order: 400,
                /**
                 * Whether to allow "empty" files (zero bytes).
                 *
                 * @type {boolean}
                 */
                allowEmpty: true,
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that return true will be tried, in order, until one successfully parses the file.
                 * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
                 * every parser will be tried.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {boolean}
                 */
                canParse(file) {
                  return Buffer2.isBuffer(file.data) && BINARY_REGEXP.test(file.url);
                },
                /**
                 * Parses the given data as a Buffer (byte array).
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {Buffer}
                 */
                parse(file) {
                  if (Buffer2.isBuffer(file.data)) {
                    return file.data;
                  } else {
                    return Buffer2.from(file.data);
                  }
                }
              };
            }).call(this);
          }).call(this, require2("buffer").Buffer);
        }, { "buffer": 34 }], 8: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              const { ParserError } = require2("../util/errors");
              module3.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */
                order: 100,
                /**
                 * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
                 *
                 * @type {boolean}
                 */
                allowEmpty: true,
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that match will be tried, in order, until one successfully parses the file.
                 * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
                 * every parser will be tried.
                 *
                 * @type {RegExp|string|string[]|function}
                 */
                canParse: ".json",
                /**
                 * Parses the given file as JSON
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {Promise}
                 */
                async parse(file) {
                  let data = file.data;
                  if (Buffer2.isBuffer(data)) {
                    data = data.toString();
                  }
                  if (typeof data === "string") {
                    if (data.trim().length === 0) {
                      return;
                    } else {
                      try {
                        return JSON.parse(data);
                      } catch (e2) {
                        throw new ParserError(e2.message, file.url);
                      }
                    }
                  } else {
                    return data;
                  }
                }
              };
            }).call(this);
          }).call(this, { "isBuffer": require2("../../../../is-buffer/index.js") });
        }, { "../../../../is-buffer/index.js": 197, "../util/errors": 17 }], 9: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              const { ParserError } = require2("../util/errors");
              let TEXT_REGEXP = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
              module3.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */
                order: 300,
                /**
                 * Whether to allow "empty" files (zero bytes).
                 *
                 * @type {boolean}
                 */
                allowEmpty: true,
                /**
                 * The encoding that the text is expected to be in.
                 *
                 * @type {string}
                 */
                encoding: "utf8",
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that return true will be tried, in order, until one successfully parses the file.
                 * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
                 * every parser will be tried.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {boolean}
                 */
                canParse(file) {
                  return (typeof file.data === "string" || Buffer2.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);
                },
                /**
                 * Parses the given file as text
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {string}
                 */
                parse(file) {
                  if (typeof file.data === "string") {
                    return file.data;
                  } else if (Buffer2.isBuffer(file.data)) {
                    return file.data.toString(this.encoding);
                  } else {
                    throw new ParserError("data is not text", file.url);
                  }
                }
              };
            }).call(this);
          }).call(this, { "isBuffer": require2("../../../../is-buffer/index.js") });
        }, { "../../../../is-buffer/index.js": 197, "../util/errors": 17 }], 10: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              const { ParserError } = require2("../util/errors");
              const yaml = require2("js-yaml");
              const { JSON_SCHEMA } = require2("js-yaml");
              module3.exports = {
                /**
                 * The order that this parser will run, in relation to other parsers.
                 *
                 * @type {number}
                 */
                order: 200,
                /**
                 * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
                 *
                 * @type {boolean}
                 */
                allowEmpty: true,
                /**
                 * Determines whether this parser can parse a given file reference.
                 * Parsers that match will be tried, in order, until one successfully parses the file.
                 * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
                 * every parser will be tried.
                 *
                 * @type {RegExp|string[]|function}
                 */
                canParse: [".yaml", ".yml", ".json"],
                // JSON is valid YAML
                /**
                 * Parses the given file as YAML
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver
                 * @returns {Promise}
                 */
                async parse(file) {
                  let data = file.data;
                  if (Buffer2.isBuffer(data)) {
                    data = data.toString();
                  }
                  if (typeof data === "string") {
                    try {
                      return yaml.load(data, { schema: JSON_SCHEMA });
                    } catch (e2) {
                      throw new ParserError(e2.message, file.url);
                    }
                  } else {
                    return data;
                  }
                }
              };
            }).call(this);
          }).call(this, { "isBuffer": require2("../../../../is-buffer/index.js") });
        }, { "../../../../is-buffer/index.js": 197, "../util/errors": 17, "js-yaml": 201 }], 11: [function(require2, module3, exports3) {
          module3.exports = Pointer;
          const $Ref = require2("./ref");
          const url = require2("./util/url");
          const { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } = require2("./util/errors");
          const slashes = /\//g;
          const tildes = /~/g;
          const escapedSlash = /~1/g;
          const escapedTilde = /~0/g;
          function Pointer($ref, path, friendlyPath) {
            this.$ref = $ref;
            this.path = path;
            this.originalPath = friendlyPath || path;
            this.value = void 0;
            this.circular = false;
            this.indirections = 0;
          }
          Pointer.prototype.resolve = function(obj, options, pathFromRoot) {
            let tokens = Pointer.parse(this.path, this.originalPath);
            this.value = unwrapOrThrow(obj);
            for (let i2 = 0; i2 < tokens.length; i2++) {
              if (resolveIf$Ref(this, options)) {
                this.path = Pointer.join(this.path, tokens.slice(i2));
              }
              if (typeof this.value === "object" && this.value !== null && "$ref" in this.value) {
                return this;
              }
              let token = tokens[i2];
              if (this.value[token] === void 0 || this.value[token] === null) {
                this.value = null;
                throw new MissingPointerError(token, decodeURI(this.originalPath));
              } else {
                this.value = this.value[token];
              }
            }
            if (!this.value || this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot) {
              resolveIf$Ref(this, options);
            }
            return this;
          };
          Pointer.prototype.set = function(obj, value, options) {
            let tokens = Pointer.parse(this.path);
            let token;
            if (tokens.length === 0) {
              this.value = value;
              return value;
            }
            this.value = unwrapOrThrow(obj);
            for (let i2 = 0; i2 < tokens.length - 1; i2++) {
              resolveIf$Ref(this, options);
              token = tokens[i2];
              if (this.value && this.value[token] !== void 0) {
                this.value = this.value[token];
              } else {
                this.value = setValue(this, token, {});
              }
            }
            resolveIf$Ref(this, options);
            token = tokens[tokens.length - 1];
            setValue(this, token, value);
            return obj;
          };
          Pointer.parse = function(path, originalPath) {
            let pointer = url.getHash(path).substr(1);
            if (!pointer) {
              return [];
            }
            pointer = pointer.split("/");
            for (let i2 = 0; i2 < pointer.length; i2++) {
              pointer[i2] = decodeURIComponent(pointer[i2].replace(escapedSlash, "/").replace(escapedTilde, "~"));
            }
            if (pointer[0] !== "") {
              throw new InvalidPointerError(pointer, originalPath === void 0 ? path : originalPath);
            }
            return pointer.slice(1);
          };
          Pointer.join = function(base, tokens) {
            if (base.indexOf("#") === -1) {
              base += "#";
            }
            tokens = Array.isArray(tokens) ? tokens : [tokens];
            for (let i2 = 0; i2 < tokens.length; i2++) {
              let token = tokens[i2];
              base += "/" + encodeURIComponent(token.replace(tildes, "~0").replace(slashes, "~1"));
            }
            return base;
          };
          function resolveIf$Ref(pointer, options) {
            if ($Ref.isAllowed$Ref(pointer.value, options)) {
              let $refPath = url.resolve(pointer.path, pointer.value.$ref);
              if ($refPath === pointer.path) {
                pointer.circular = true;
              } else {
                let resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);
                if (resolved === null) {
                  return false;
                }
                pointer.indirections += resolved.indirections + 1;
                if ($Ref.isExtended$Ref(pointer.value)) {
                  pointer.value = $Ref.dereference(pointer.value, resolved.value);
                  return false;
                } else {
                  pointer.$ref = resolved.$ref;
                  pointer.path = resolved.path;
                  pointer.value = resolved.value;
                }
                return true;
              }
            }
          }
          function setValue(pointer, token, value) {
            if (pointer.value && typeof pointer.value === "object") {
              if (token === "-" && Array.isArray(pointer.value)) {
                pointer.value.push(value);
              } else {
                pointer.value[token] = value;
              }
            } else {
              throw new JSONParserError(`Error assigning $ref pointer "${pointer.path}". 
Cannot set "${token}" of a non-object.`);
            }
            return value;
          }
          function unwrapOrThrow(value) {
            if (isHandledError(value)) {
              throw value;
            }
            return value;
          }
        }, { "./ref": 12, "./util/errors": 17, "./util/url": 19 }], 12: [function(require2, module3, exports3) {
          module3.exports = $Ref;
          const Pointer = require2("./pointer");
          const { InvalidPointerError, isHandledError, normalizeError } = require2("./util/errors");
          const { safePointerToPath, stripHash, getHash } = require2("./util/url");
          function $Ref() {
            this.path = void 0;
            this.value = void 0;
            this.$refs = void 0;
            this.pathType = void 0;
            this.errors = void 0;
          }
          $Ref.prototype.addError = function(err) {
            if (this.errors === void 0) {
              this.errors = [];
            }
            const existingErrors = this.errors.map(({ footprint }) => footprint);
            if (Array.isArray(err.errors)) {
              this.errors.push(
                ...err.errors.map(normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint))
              );
            } else if (!existingErrors.includes(err.footprint)) {
              this.errors.push(normalizeError(err));
            }
          };
          $Ref.prototype.exists = function(path, options) {
            try {
              this.resolve(path, options);
              return true;
            } catch (e2) {
              return false;
            }
          };
          $Ref.prototype.get = function(path, options) {
            return this.resolve(path, options).value;
          };
          $Ref.prototype.resolve = function(path, options, friendlyPath, pathFromRoot) {
            let pointer = new Pointer(this, path, friendlyPath);
            try {
              return pointer.resolve(this.value, options, pathFromRoot);
            } catch (err) {
              if (!options || !options.continueOnError || !isHandledError(err)) {
                throw err;
              }
              if (err.path === null) {
                err.path = safePointerToPath(getHash(pathFromRoot));
              }
              if (err instanceof InvalidPointerError) {
                err.source = decodeURI(stripHash(pathFromRoot));
              }
              this.addError(err);
              return null;
            }
          };
          $Ref.prototype.set = function(path, value) {
            let pointer = new Pointer(this, path);
            this.value = pointer.set(this.value, value);
          };
          $Ref.is$Ref = function(value) {
            return value && typeof value === "object" && typeof value.$ref === "string" && value.$ref.length > 0;
          };
          $Ref.isExternal$Ref = function(value) {
            return $Ref.is$Ref(value) && value.$ref[0] !== "#";
          };
          $Ref.isAllowed$Ref = function(value, options) {
            if ($Ref.is$Ref(value)) {
              if (value.$ref.substr(0, 2) === "#/" || value.$ref === "#") {
                return true;
              } else if (value.$ref[0] !== "#" && (!options || options.resolve.external)) {
                return true;
              }
            }
          };
          $Ref.isExtended$Ref = function(value) {
            return $Ref.is$Ref(value) && Object.keys(value).length > 1;
          };
          $Ref.dereference = function($ref, resolvedValue) {
            if (resolvedValue && typeof resolvedValue === "object" && $Ref.isExtended$Ref($ref)) {
              let merged = {};
              for (let key of Object.keys($ref)) {
                if (key !== "$ref") {
                  merged[key] = $ref[key];
                }
              }
              for (let key of Object.keys(resolvedValue)) {
                if (!(key in merged)) {
                  merged[key] = resolvedValue[key];
                }
              }
              return merged;
            } else {
              return resolvedValue;
            }
          };
        }, { "./pointer": 11, "./util/errors": 17, "./util/url": 19 }], 13: [function(require2, module3, exports3) {
          const { ono } = require2("@jsdevtools/ono");
          const $Ref = require2("./ref");
          const url = require2("./util/url");
          module3.exports = $Refs;
          function $Refs() {
            this.circular = false;
            this._$refs = {};
            this._root$Ref = null;
          }
          $Refs.prototype.paths = function(types) {
            let paths = getPaths(this._$refs, arguments);
            return paths.map((path) => {
              return path.decoded;
            });
          };
          $Refs.prototype.values = function(types) {
            let $refs = this._$refs;
            let paths = getPaths($refs, arguments);
            return paths.reduce((obj, path) => {
              obj[path.decoded] = $refs[path.encoded].value;
              return obj;
            }, {});
          };
          $Refs.prototype.toJSON = $Refs.prototype.values;
          $Refs.prototype.exists = function(path, options) {
            try {
              this._resolve(path, "", options);
              return true;
            } catch (e2) {
              return false;
            }
          };
          $Refs.prototype.get = function(path, options) {
            return this._resolve(path, "", options).value;
          };
          $Refs.prototype.set = function(path, value) {
            let absPath = url.resolve(this._root$Ref.path, path);
            let withoutHash = url.stripHash(absPath);
            let $ref = this._$refs[withoutHash];
            if (!$ref) {
              throw ono(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
            }
            $ref.set(absPath, value);
          };
          $Refs.prototype._add = function(path) {
            let withoutHash = url.stripHash(path);
            let $ref = new $Ref();
            $ref.path = withoutHash;
            $ref.$refs = this;
            this._$refs[withoutHash] = $ref;
            this._root$Ref = this._root$Ref || $ref;
            return $ref;
          };
          $Refs.prototype._resolve = function(path, pathFromRoot, options) {
            let absPath = url.resolve(this._root$Ref.path, path);
            let withoutHash = url.stripHash(absPath);
            let $ref = this._$refs[withoutHash];
            if (!$ref) {
              throw ono(`Error resolving $ref pointer "${path}". 
"${withoutHash}" not found.`);
            }
            return $ref.resolve(absPath, options, path, pathFromRoot);
          };
          $Refs.prototype._get$Ref = function(path) {
            path = url.resolve(this._root$Ref.path, path);
            let withoutHash = url.stripHash(path);
            return this._$refs[withoutHash];
          };
          function getPaths($refs, types) {
            let paths = Object.keys($refs);
            types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);
            if (types.length > 0 && types[0]) {
              paths = paths.filter((key) => {
                return types.indexOf($refs[key].pathType) !== -1;
              });
            }
            return paths.map((path) => {
              return {
                encoded: path,
                decoded: $refs[path].pathType === "file" ? url.toFileSystemPath(path, true) : path
              };
            });
          }
        }, { "./ref": 12, "./util/url": 19, "@jsdevtools/ono": 22 }], 14: [function(require2, module3, exports3) {
          const $Ref = require2("./ref");
          const Pointer = require2("./pointer");
          const parse = require2("./parse");
          const url = require2("./util/url");
          const { isHandledError } = require2("./util/errors");
          module3.exports = resolveExternal;
          function resolveExternal(parser, options) {
            if (!options.resolve.external) {
              return Promise.resolve();
            }
            try {
              let promises = crawl(parser.schema, parser.$refs._root$Ref.path + "#", parser.$refs, options);
              return Promise.all(promises);
            } catch (e2) {
              return Promise.reject(e2);
            }
          }
          function crawl(obj, path, $refs, options, seen) {
            seen = seen || /* @__PURE__ */ new Set();
            let promises = [];
            if (obj && typeof obj === "object" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {
              seen.add(obj);
              if ($Ref.isExternal$Ref(obj)) {
                promises.push(resolve$Ref(obj, path, $refs, options));
              } else {
                for (let key of Object.keys(obj)) {
                  let keyPath = Pointer.join(path, key);
                  let value = obj[key];
                  if ($Ref.isExternal$Ref(value)) {
                    promises.push(resolve$Ref(value, keyPath, $refs, options));
                  } else {
                    promises = promises.concat(crawl(value, keyPath, $refs, options, seen));
                  }
                }
              }
            }
            return promises;
          }
          async function resolve$Ref($ref, path, $refs, options) {
            let resolvedPath = url.resolve(path, $ref.$ref);
            let withoutHash = url.stripHash(resolvedPath);
            $ref = $refs._$refs[withoutHash];
            if ($ref) {
              return Promise.resolve($ref.value);
            }
            try {
              const result = await parse(resolvedPath, $refs, options);
              let promises = crawl(result, withoutHash + "#", $refs, options);
              return Promise.all(promises);
            } catch (err) {
              if (!options.continueOnError || !isHandledError(err)) {
                throw err;
              }
              if ($refs._$refs[withoutHash]) {
                err.source = decodeURI(url.stripHash(path));
                err.path = url.safePointerToPath(url.getHash(path));
              }
              return [];
            }
          }
        }, { "./parse": 6, "./pointer": 11, "./ref": 12, "./util/errors": 17, "./util/url": 19 }], 15: [function(require2, module3, exports3) {
          const fs = require2("fs");
          const { ono } = require2("@jsdevtools/ono");
          const url = require2("../util/url");
          const { ResolverError } = require2("../util/errors");
          module3.exports = {
            /**
             * The order that this resolver will run, in relation to other resolvers.
             *
             * @type {number}
             */
            order: 100,
            /**
             * Determines whether this resolver can read a given file reference.
             * Resolvers that return true will be tried, in order, until one successfully resolves the file.
             * Resolvers that return false will not be given a chance to resolve the file.
             *
             * @param {object} file           - An object containing information about the referenced file
             * @param {string} file.url       - The full URL of the referenced file
             * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
             * @returns {boolean}
             */
            canRead(file) {
              return url.isFileSystemPath(file.url);
            },
            /**
             * Reads the given file and returns its raw contents as a Buffer.
             *
             * @param {object} file           - An object containing information about the referenced file
             * @param {string} file.url       - The full URL of the referenced file
             * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
             * @returns {Promise<Buffer>}
             */
            read(file) {
              return new Promise((resolve, reject) => {
                let path;
                try {
                  path = url.toFileSystemPath(file.url);
                } catch (err) {
                  reject(new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url));
                }
                try {
                  fs.readFile(path, (err, data) => {
                    if (err) {
                      reject(new ResolverError(ono(err, `Error opening file "${path}"`), path));
                    } else {
                      resolve(data);
                    }
                  });
                } catch (err) {
                  reject(new ResolverError(ono(err, `Error opening file "${path}"`), path));
                }
              });
            }
          };
        }, { "../util/errors": 17, "../util/url": 19, "@jsdevtools/ono": 22, "fs": 32 }], 16: [function(require2, module3, exports3) {
          (function(process, Buffer2) {
            (function() {
              const http = require2("http");
              const https = require2("https");
              const { ono } = require2("@jsdevtools/ono");
              const url = require2("../util/url");
              const { ResolverError } = require2("../util/errors");
              module3.exports = {
                /**
                 * The order that this resolver will run, in relation to other resolvers.
                 *
                 * @type {number}
                 */
                order: 200,
                /**
                 * HTTP headers to send when downloading files.
                 *
                 * @example:
                 * {
                 *   "User-Agent": "JSON Schema $Ref Parser",
                 *   Accept: "application/json"
                 * }
                 *
                 * @type {object}
                 */
                headers: null,
                /**
                 * HTTP request timeout (in milliseconds).
                 *
                 * @type {number}
                 */
                timeout: 5e3,
                // 5 seconds
                /**
                 * The maximum number of HTTP redirects to follow.
                 * To disable automatic following of redirects, set this to zero.
                 *
                 * @type {number}
                 */
                redirects: 5,
                /**
                 * The `withCredentials` option of XMLHttpRequest.
                 * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
                 *
                 * @type {boolean}
                 */
                withCredentials: false,
                /**
                 * Determines whether this resolver can read a given file reference.
                 * Resolvers that return true will be tried in order, until one successfully resolves the file.
                 * Resolvers that return false will not be given a chance to resolve the file.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @returns {boolean}
                 */
                canRead(file) {
                  return url.isHttp(file.url);
                },
                /**
                 * Reads the given URL and returns its raw contents as a Buffer.
                 *
                 * @param {object} file           - An object containing information about the referenced file
                 * @param {string} file.url       - The full URL of the referenced file
                 * @param {string} file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
                 * @returns {Promise<Buffer>}
                 */
                read(file) {
                  let u2 = url.parse(file.url);
                  if (process.browser && !u2.protocol) {
                    u2.protocol = url.parse(location.href).protocol;
                  }
                  return download(u2, this);
                }
              };
              function download(u2, httpOptions, redirects) {
                return new Promise((resolve, reject) => {
                  u2 = url.parse(u2);
                  redirects = redirects || [];
                  redirects.push(u2.href);
                  get2(u2, httpOptions).then((res) => {
                    if (res.statusCode >= 400) {
                      throw ono({ status: res.statusCode }, `HTTP ERROR ${res.statusCode}`);
                    } else if (res.statusCode >= 300) {
                      if (redirects.length > httpOptions.redirects) {
                        reject(new ResolverError(ono(
                          { status: res.statusCode },
                          `Error downloading ${redirects[0]}. 
Too many redirects: 
  ${redirects.join(" \n  ")}`
                        )));
                      } else if (!res.headers.location) {
                        throw ono({ status: res.statusCode }, `HTTP ${res.statusCode} redirect with no location header`);
                      } else {
                        let redirectTo = url.resolve(u2, res.headers.location);
                        download(redirectTo, httpOptions, redirects).then(resolve, reject);
                      }
                    } else {
                      resolve(res.body || Buffer2.alloc(0));
                    }
                  }).catch((err) => {
                    reject(new ResolverError(ono(err, `Error downloading ${u2.href}`), u2.href));
                  });
                });
              }
              function get2(u2, httpOptions) {
                return new Promise((resolve, reject) => {
                  let protocol = u2.protocol === "https:" ? https : http;
                  let req = protocol.get({
                    hostname: u2.hostname,
                    port: u2.port,
                    path: u2.path,
                    auth: u2.auth,
                    protocol: u2.protocol,
                    headers: httpOptions.headers || {},
                    withCredentials: httpOptions.withCredentials
                  });
                  if (typeof req.setTimeout === "function") {
                    req.setTimeout(httpOptions.timeout);
                  }
                  req.on("timeout", () => {
                    req.abort();
                  });
                  req.on("error", reject);
                  req.once("response", (res) => {
                    res.body = Buffer2.alloc(0);
                    res.on("data", (data) => {
                      res.body = Buffer2.concat([res.body, Buffer2.from(data)]);
                    });
                    res.on("error", reject);
                    res.on("end", () => {
                      resolve(res);
                    });
                  });
                });
              }
            }).call(this);
          }).call(this, require2("_process"), require2("buffer").Buffer);
        }, { "../util/errors": 17, "../util/url": 19, "@jsdevtools/ono": 22, "_process": 263, "buffer": 34, "http": 268, "https": 193 }], 17: [function(require2, module3, exports3) {
          const { Ono } = require2("@jsdevtools/ono");
          const { stripHash, toFileSystemPath } = require2("./url");
          const JSONParserError = exports3.JSONParserError = class JSONParserError extends Error {
            constructor(message, source) {
              super();
              this.code = "EUNKNOWN";
              this.message = message;
              this.source = source;
              this.path = null;
              Ono.extend(this);
            }
            get footprint() {
              return `${this.path}+${this.source}+${this.code}+${this.message}`;
            }
          };
          setErrorName(JSONParserError);
          const JSONParserErrorGroup = exports3.JSONParserErrorGroup = class JSONParserErrorGroup2 extends Error {
            constructor(parser) {
              super();
              this.files = parser;
              this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${toFileSystemPath(parser.$refs._root$Ref.path)}'`;
              Ono.extend(this);
            }
            static getParserErrors(parser) {
              const errors = [];
              for (const $ref of Object.values(parser.$refs._$refs)) {
                if ($ref.errors) {
                  errors.push(...$ref.errors);
                }
              }
              return errors;
            }
            get errors() {
              return JSONParserErrorGroup2.getParserErrors(this.files);
            }
          };
          setErrorName(JSONParserErrorGroup);
          const ParserError = exports3.ParserError = class ParserError extends JSONParserError {
            constructor(message, source) {
              super(`Error parsing ${source}: ${message}`, source);
              this.code = "EPARSER";
            }
          };
          setErrorName(ParserError);
          const UnmatchedParserError = exports3.UnmatchedParserError = class UnmatchedParserError extends JSONParserError {
            constructor(source) {
              super(`Could not find parser for "${source}"`, source);
              this.code = "EUNMATCHEDPARSER";
            }
          };
          setErrorName(UnmatchedParserError);
          const ResolverError = exports3.ResolverError = class ResolverError extends JSONParserError {
            constructor(ex, source) {
              super(ex.message || `Error reading file "${source}"`, source);
              this.code = "ERESOLVER";
              if ("code" in ex) {
                this.ioErrorCode = String(ex.code);
              }
            }
          };
          setErrorName(ResolverError);
          const UnmatchedResolverError = exports3.UnmatchedResolverError = class UnmatchedResolverError extends JSONParserError {
            constructor(source) {
              super(`Could not find resolver for "${source}"`, source);
              this.code = "EUNMATCHEDRESOLVER";
            }
          };
          setErrorName(UnmatchedResolverError);
          const MissingPointerError = exports3.MissingPointerError = class MissingPointerError extends JSONParserError {
            constructor(token, path) {
              super(`Token "${token}" does not exist.`, stripHash(path));
              this.code = "EMISSINGPOINTER";
            }
          };
          setErrorName(MissingPointerError);
          const InvalidPointerError = exports3.InvalidPointerError = class InvalidPointerError extends JSONParserError {
            constructor(pointer, path) {
              super(`Invalid $ref pointer "${pointer}". Pointers must begin with "#/"`, stripHash(path));
              this.code = "EINVALIDPOINTER";
            }
          };
          setErrorName(InvalidPointerError);
          function setErrorName(err) {
            Object.defineProperty(err.prototype, "name", {
              value: err.name,
              enumerable: true
            });
          }
          exports3.isHandledError = function(err) {
            return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;
          };
          exports3.normalizeError = function(err) {
            if (err.path === null) {
              err.path = [];
            }
            return err;
          };
        }, { "./url": 19, "@jsdevtools/ono": 22 }], 18: [function(require2, module3, exports3) {
          exports3.all = function(plugins) {
            return Object.keys(plugins).filter((key) => {
              return typeof plugins[key] === "object";
            }).map((key) => {
              plugins[key].name = key;
              return plugins[key];
            });
          };
          exports3.filter = function(plugins, method, file) {
            return plugins.filter((plugin) => {
              return !!getResult(plugin, method, file);
            });
          };
          exports3.sort = function(plugins) {
            for (let plugin of plugins) {
              plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;
            }
            return plugins.sort((a2, b2) => {
              return a2.order - b2.order;
            });
          };
          exports3.run = function(plugins, method, file, $refs) {
            let plugin, lastError, index = 0;
            return new Promise((resolve, reject) => {
              runNextPlugin();
              function runNextPlugin() {
                plugin = plugins[index++];
                if (!plugin) {
                  return reject(lastError);
                }
                try {
                  let result = getResult(plugin, method, file, callback, $refs);
                  if (result && typeof result.then === "function") {
                    result.then(onSuccess, onError);
                  } else if (result !== void 0) {
                    onSuccess(result);
                  } else if (index === plugins.length) {
                    throw new Error("No promise has been returned or callback has been called.");
                  }
                } catch (e2) {
                  onError(e2);
                }
              }
              function callback(err, result) {
                if (err) {
                  onError(err);
                } else {
                  onSuccess(result);
                }
              }
              function onSuccess(result) {
                resolve({
                  plugin,
                  result
                });
              }
              function onError(error) {
                lastError = {
                  plugin,
                  error
                };
                runNextPlugin();
              }
            });
          };
          function getResult(obj, prop, file, callback, $refs) {
            let value = obj[prop];
            if (typeof value === "function") {
              return value.apply(obj, [file, callback, $refs]);
            }
            if (!callback) {
              if (value instanceof RegExp) {
                return value.test(file.url);
              } else if (typeof value === "string") {
                return value === file.extension;
              } else if (Array.isArray(value)) {
                return value.indexOf(file.extension) !== -1;
              }
            }
            return value;
          }
        }, {}], 19: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              let isWindows = /^win/.test(process.platform), forwardSlashPattern = /\//g, protocolPattern = /^(\w{2,}):\/\//i, url = module3.exports, jsonPointerSlash = /~1/g, jsonPointerTilde = /~0/g;
              let urlEncodePatterns = [
                /\?/g,
                "%3F",
                /\#/g,
                "%23"
              ];
              let urlDecodePatterns = [
                /\%23/g,
                "#",
                /\%24/g,
                "$",
                /\%26/g,
                "&",
                /\%2C/g,
                ",",
                /\%40/g,
                "@"
              ];
              exports3.parse = require2("url").parse;
              exports3.resolve = require2("url").resolve;
              exports3.cwd = function cwd() {
                if (process.browser) {
                  return location.href;
                }
                let path = process.cwd();
                let lastChar = path.slice(-1);
                if (lastChar === "/" || lastChar === "\\") {
                  return path;
                } else {
                  return path + "/";
                }
              };
              exports3.getProtocol = function getProtocol(path) {
                let match = protocolPattern.exec(path);
                if (match) {
                  return match[1].toLowerCase();
                }
              };
              exports3.getExtension = function getExtension(path) {
                let lastDot = path.lastIndexOf(".");
                if (lastDot >= 0) {
                  return url.stripQuery(path.substr(lastDot).toLowerCase());
                }
                return "";
              };
              exports3.stripQuery = function stripQuery(path) {
                let queryIndex = path.indexOf("?");
                if (queryIndex >= 0) {
                  path = path.substr(0, queryIndex);
                }
                return path;
              };
              exports3.getHash = function getHash(path) {
                let hashIndex = path.indexOf("#");
                if (hashIndex >= 0) {
                  return path.substr(hashIndex);
                }
                return "#";
              };
              exports3.stripHash = function stripHash(path) {
                let hashIndex = path.indexOf("#");
                if (hashIndex >= 0) {
                  path = path.substr(0, hashIndex);
                }
                return path;
              };
              exports3.isHttp = function isHttp(path) {
                let protocol = url.getProtocol(path);
                if (protocol === "http" || protocol === "https") {
                  return true;
                } else if (protocol === void 0) {
                  return process.browser;
                } else {
                  return false;
                }
              };
              exports3.isFileSystemPath = function isFileSystemPath(path) {
                if (process.browser) {
                  return false;
                }
                let protocol = url.getProtocol(path);
                return protocol === void 0 || protocol === "file";
              };
              exports3.fromFileSystemPath = function fromFileSystemPath(path) {
                if (isWindows) {
                  path = path.replace(/\\/g, "/");
                }
                path = encodeURI(path);
                for (let i2 = 0; i2 < urlEncodePatterns.length; i2 += 2) {
                  path = path.replace(urlEncodePatterns[i2], urlEncodePatterns[i2 + 1]);
                }
                return path;
              };
              exports3.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {
                path = decodeURI(path);
                for (let i2 = 0; i2 < urlDecodePatterns.length; i2 += 2) {
                  path = path.replace(urlDecodePatterns[i2], urlDecodePatterns[i2 + 1]);
                }
                let isFileUrl = path.substr(0, 7).toLowerCase() === "file://";
                if (isFileUrl) {
                  path = path[7] === "/" ? path.substr(8) : path.substr(7);
                  if (isWindows && path[1] === "/") {
                    path = path[0] + ":" + path.substr(1);
                  }
                  if (keepFileProtocol) {
                    path = "file:///" + path;
                  } else {
                    isFileUrl = false;
                    path = isWindows ? path : "/" + path;
                  }
                }
                if (isWindows && !isFileUrl) {
                  path = path.replace(forwardSlashPattern, "\\");
                  if (path.substr(1, 2) === ":\\") {
                    path = path[0].toUpperCase() + path.substr(1);
                  }
                }
                return path;
              };
              exports3.safePointerToPath = function safePointerToPath(pointer) {
                if (pointer.length <= 1 || pointer[0] !== "#" || pointer[1] !== "/") {
                  return [];
                }
                return pointer.slice(2).split("/").map((value) => {
                  return decodeURIComponent(value).replace(jsonPointerSlash, "/").replace(jsonPointerTilde, "~");
                });
              };
            }).call(this);
          }).call(this, require2("_process"));
        }, { "_process": 263, "url": 303 }], 20: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.Ono = void 0;
          const extend_error_1 = require2("./extend-error");
          const normalize_1 = require2("./normalize");
          const to_json_1 = require2("./to-json");
          const constructor = Ono;
          exports3.Ono = constructor;
          function Ono(ErrorConstructor, options) {
            options = normalize_1.normalizeOptions(options);
            function ono(...args) {
              let { originalError, props, message } = normalize_1.normalizeArgs(args, options);
              let newError = new ErrorConstructor(message);
              return extend_error_1.extendError(newError, originalError, props);
            }
            ono[Symbol.species] = ErrorConstructor;
            return ono;
          }
          Ono.toJSON = function toJSON(error) {
            return to_json_1.toJSON.call(error);
          };
          Ono.extend = function extend(error, originalError, props) {
            if (props || originalError instanceof Error) {
              return extend_error_1.extendError(error, originalError, props);
            } else if (originalError) {
              return extend_error_1.extendError(error, void 0, originalError);
            } else {
              return extend_error_1.extendError(error);
            }
          };
        }, { "./extend-error": 21, "./normalize": 24, "./to-json": 27 }], 21: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.extendError = void 0;
          const isomorphic_node_1 = require2("./isomorphic.node");
          const stack_1 = require2("./stack");
          const to_json_1 = require2("./to-json");
          const protectedProps = ["name", "message", "stack"];
          function extendError(error, originalError, props) {
            let onoError = error;
            extendStack(onoError, originalError);
            if (originalError && typeof originalError === "object") {
              mergeErrors(onoError, originalError);
            }
            onoError.toJSON = to_json_1.toJSON;
            if (isomorphic_node_1.addInspectMethod) {
              isomorphic_node_1.addInspectMethod(onoError);
            }
            if (props && typeof props === "object") {
              Object.assign(onoError, props);
            }
            return onoError;
          }
          exports3.extendError = extendError;
          function extendStack(newError, originalError) {
            let stackProp = Object.getOwnPropertyDescriptor(newError, "stack");
            if (stack_1.isLazyStack(stackProp)) {
              stack_1.lazyJoinStacks(stackProp, newError, originalError);
            } else if (stack_1.isWritableStack(stackProp)) {
              newError.stack = stack_1.joinStacks(newError, originalError);
            }
          }
          function mergeErrors(newError, originalError) {
            let keys = to_json_1.getDeepKeys(originalError, protectedProps);
            let _newError = newError;
            let _originalError = originalError;
            for (let key of keys) {
              if (_newError[key] === void 0) {
                try {
                  _newError[key] = _originalError[key];
                } catch (e2) {
                }
              }
            }
          }
        }, { "./isomorphic.node": 23, "./stack": 26, "./to-json": 27 }], 22: [function(require2, module3, exports3) {
          var __createBinding = this && this.__createBinding || (Object.create ? function(o2, m2, k2, k22) {
            if (k22 === void 0) k22 = k2;
            Object.defineProperty(o2, k22, { enumerable: true, get: function() {
              return m2[k2];
            } });
          } : function(o2, m2, k2, k22) {
            if (k22 === void 0) k22 = k2;
            o2[k22] = m2[k2];
          });
          var __exportStar = this && this.__exportStar || function(m2, exports4) {
            for (var p2 in m2) if (p2 !== "default" && !exports4.hasOwnProperty(p2)) __createBinding(exports4, m2, p2);
          };
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.ono = void 0;
          const singleton_1 = require2("./singleton");
          Object.defineProperty(exports3, "ono", { enumerable: true, get: function() {
            return singleton_1.ono;
          } });
          var constructor_1 = require2("./constructor");
          Object.defineProperty(exports3, "Ono", { enumerable: true, get: function() {
            return constructor_1.Ono;
          } });
          __exportStar(require2("./types"), exports3);
          exports3.default = singleton_1.ono;
          if (typeof module3 === "object" && typeof module3.exports === "object") {
            module3.exports = Object.assign(module3.exports.default, module3.exports);
          }
        }, { "./constructor": 20, "./singleton": 25, "./types": 28 }], 23: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.addInspectMethod = exports3.format = void 0;
          exports3.format = false;
          exports3.addInspectMethod = false;
        }, {}], 24: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.normalizeArgs = exports3.normalizeOptions = void 0;
          const isomorphic_node_1 = require2("./isomorphic.node");
          function normalizeOptions(options) {
            options = options || {};
            return {
              concatMessages: options.concatMessages === void 0 ? true : Boolean(options.concatMessages),
              format: options.format === void 0 ? isomorphic_node_1.format : typeof options.format === "function" ? options.format : false
            };
          }
          exports3.normalizeOptions = normalizeOptions;
          function normalizeArgs(args, options) {
            let originalError;
            let props;
            let formatArgs;
            let message = "";
            if (typeof args[0] === "string") {
              formatArgs = args;
            } else if (typeof args[1] === "string") {
              if (args[0] instanceof Error) {
                originalError = args[0];
              } else {
                props = args[0];
              }
              formatArgs = args.slice(1);
            } else {
              originalError = args[0];
              props = args[1];
              formatArgs = args.slice(2);
            }
            if (formatArgs.length > 0) {
              if (options.format) {
                message = options.format.apply(void 0, formatArgs);
              } else {
                message = formatArgs.join(" ");
              }
            }
            if (options.concatMessages && originalError && originalError.message) {
              message += (message ? " \n" : "") + originalError.message;
            }
            return { originalError, props, message };
          }
          exports3.normalizeArgs = normalizeArgs;
        }, { "./isomorphic.node": 23 }], 25: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.ono = void 0;
          const constructor_1 = require2("./constructor");
          const singleton = ono;
          exports3.ono = singleton;
          ono.error = new constructor_1.Ono(Error);
          ono.eval = new constructor_1.Ono(EvalError);
          ono.range = new constructor_1.Ono(RangeError);
          ono.reference = new constructor_1.Ono(ReferenceError);
          ono.syntax = new constructor_1.Ono(SyntaxError);
          ono.type = new constructor_1.Ono(TypeError);
          ono.uri = new constructor_1.Ono(URIError);
          const onoMap = ono;
          function ono(...args) {
            let originalError = args[0];
            if (typeof originalError === "object" && typeof originalError.name === "string") {
              for (let typedOno of Object.values(onoMap)) {
                if (typeof typedOno === "function" && typedOno.name === "ono") {
                  let species = typedOno[Symbol.species];
                  if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {
                    return typedOno.apply(void 0, args);
                  }
                }
              }
            }
            return ono.error.apply(void 0, args);
          }
        }, { "./constructor": 20 }], 26: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.lazyJoinStacks = exports3.joinStacks = exports3.isWritableStack = exports3.isLazyStack = void 0;
          const newline = /\r?\n/;
          const onoCall = /\bono[ @]/;
          function isLazyStack(stackProp) {
            return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === "function");
          }
          exports3.isLazyStack = isLazyStack;
          function isWritableStack(stackProp) {
            return Boolean(
              // If there is no stack property, then it's writable, since assigning it will create it
              !stackProp || stackProp.writable || typeof stackProp.set === "function"
            );
          }
          exports3.isWritableStack = isWritableStack;
          function joinStacks(newError, originalError) {
            let newStack = popStack(newError.stack);
            let originalStack = originalError ? originalError.stack : void 0;
            if (newStack && originalStack) {
              return newStack + "\n\n" + originalStack;
            } else {
              return newStack || originalStack;
            }
          }
          exports3.joinStacks = joinStacks;
          function lazyJoinStacks(lazyStack, newError, originalError) {
            if (originalError) {
              Object.defineProperty(newError, "stack", {
                get: () => {
                  let newStack = lazyStack.get.apply(newError);
                  return joinStacks({ stack: newStack }, originalError);
                },
                enumerable: false,
                configurable: true
              });
            } else {
              lazyPopStack(newError, lazyStack);
            }
          }
          exports3.lazyJoinStacks = lazyJoinStacks;
          function popStack(stack) {
            if (stack) {
              let lines = stack.split(newline);
              let onoStart;
              for (let i2 = 0; i2 < lines.length; i2++) {
                let line = lines[i2];
                if (onoCall.test(line)) {
                  if (onoStart === void 0) {
                    onoStart = i2;
                  }
                } else if (onoStart !== void 0) {
                  lines.splice(onoStart, i2 - onoStart);
                  break;
                }
              }
              if (lines.length > 0) {
                return lines.join("\n");
              }
            }
            return stack;
          }
          function lazyPopStack(error, lazyStack) {
            Object.defineProperty(error, "stack", {
              get: () => popStack(lazyStack.get.apply(error)),
              enumerable: false,
              configurable: true
            });
          }
        }, {}], 27: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.getDeepKeys = exports3.toJSON = void 0;
          const nonJsonTypes = ["function", "symbol", "undefined"];
          const protectedProps = ["constructor", "prototype", "__proto__"];
          const objectPrototype = Object.getPrototypeOf({});
          function toJSON() {
            let pojo = {};
            let error = this;
            for (let key of getDeepKeys(error)) {
              if (typeof key === "string") {
                let value = error[key];
                let type = typeof value;
                if (!nonJsonTypes.includes(type)) {
                  pojo[key] = value;
                }
              }
            }
            return pojo;
          }
          exports3.toJSON = toJSON;
          function getDeepKeys(obj, omit = []) {
            let keys = [];
            while (obj && obj !== objectPrototype) {
              keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));
              obj = Object.getPrototypeOf(obj);
            }
            let uniqueKeys = new Set(keys);
            for (let key of omit.concat(protectedProps)) {
              uniqueKeys.delete(key);
            }
            return uniqueKeys;
          }
          exports3.getDeepKeys = getDeepKeys;
        }, {}], 28: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          require2("util");
        }, { "util": 308 }], 29: [function(require2, module3, exports3) {
          module3.exports = function(arr, fn, self2) {
            if (arr.filter) return arr.filter(fn, self2);
            if (void 0 === arr || null === arr) throw new TypeError();
            if ("function" != typeof fn) throw new TypeError();
            var ret = [];
            for (var i2 = 0; i2 < arr.length; i2++) {
              if (!hasOwn.call(arr, i2)) continue;
              var val = arr[i2];
              if (fn.call(self2, val, i2, arr)) ret.push(val);
            }
            return ret;
          };
          var hasOwn = Object.prototype.hasOwnProperty;
        }, {}], 30: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var filter = require2("array-filter");
              module3.exports = function availableTypedArrays() {
                return filter([
                  "BigInt64Array",
                  "BigUint64Array",
                  "Float32Array",
                  "Float64Array",
                  "Int16Array",
                  "Int32Array",
                  "Int8Array",
                  "Uint16Array",
                  "Uint32Array",
                  "Uint8Array",
                  "Uint8ClampedArray"
                ], function(typedArray) {
                  return typeof global2[typedArray] === "function";
                });
              };
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "array-filter": 29 }], 31: [function(require2, module3, exports3) {
          exports3.byteLength = byteLength;
          exports3.toByteArray = toByteArray;
          exports3.fromByteArray = fromByteArray;
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i2 = 0, len = code.length; i2 < len; ++i2) {
            lookup[i2] = code[i2];
            revLookup[code.charCodeAt(i2)] = i2;
          }
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
          function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
              throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [validLen, placeHoldersLen];
          }
          function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i22;
            for (i22 = 0; i22 < len2; i22 += 4) {
              tmp = revLookup[b64.charCodeAt(i22)] << 18 | revLookup[b64.charCodeAt(i22 + 1)] << 12 | revLookup[b64.charCodeAt(i22 + 2)] << 6 | revLookup[b64.charCodeAt(i22 + 3)];
              arr[curByte++] = tmp >> 16 & 255;
              arr[curByte++] = tmp >> 8 & 255;
              arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
              tmp = revLookup[b64.charCodeAt(i22)] << 2 | revLookup[b64.charCodeAt(i22 + 1)] >> 4;
              arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
              tmp = revLookup[b64.charCodeAt(i22)] << 10 | revLookup[b64.charCodeAt(i22 + 1)] << 4 | revLookup[b64.charCodeAt(i22 + 2)] >> 2;
              arr[curByte++] = tmp >> 8 & 255;
              arr[curByte++] = tmp & 255;
            }
            return arr;
          }
          function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
          }
          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i22 = start; i22 < end; i22 += 3) {
              tmp = (uint8[i22] << 16 & 16711680) + (uint8[i22 + 1] << 8 & 65280) + (uint8[i22 + 2] & 255);
              output.push(tripletToBase64(tmp));
            }
            return output.join("");
          }
          function fromByteArray(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for (var i22 = 0, len22 = len2 - extraBytes; i22 < len22; i22 += maxChunkLength) {
              parts.push(encodeChunk(uint8, i22, i22 + maxChunkLength > len22 ? len22 : i22 + maxChunkLength));
            }
            if (extraBytes === 1) {
              tmp = uint8[len2 - 1];
              parts.push(
                lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
              );
            } else if (extraBytes === 2) {
              tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
              parts.push(
                lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
              );
            }
            return parts.join("");
          }
        }, {}], 32: [function(require2, module3, exports3) {
        }, {}], 33: [function(require2, module3, exports3) {
          arguments[4][32][0].apply(exports3, arguments);
        }, { "dup": 32 }], 34: [function(require2, module3, exports3) {
          (function(Buffer2) {
            (function() {
              var base64 = require2("base64-js");
              var ieee754 = require2("ieee754");
              exports3.Buffer = Buffer22;
              exports3.SlowBuffer = SlowBuffer;
              exports3.INSPECT_MAX_BYTES = 50;
              var K_MAX_LENGTH = 2147483647;
              exports3.kMaxLength = K_MAX_LENGTH;
              Buffer22.TYPED_ARRAY_SUPPORT = typedArraySupport();
              if (!Buffer22.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error(
                  "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
                );
              }
              function typedArraySupport() {
                try {
                  var arr = new Uint8Array(1);
                  arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                    return 42;
                  } };
                  return arr.foo() === 42;
                } catch (e2) {
                  return false;
                }
              }
              Object.defineProperty(Buffer22.prototype, "parent", {
                enumerable: true,
                get: function() {
                  if (!Buffer22.isBuffer(this)) return void 0;
                  return this.buffer;
                }
              });
              Object.defineProperty(Buffer22.prototype, "offset", {
                enumerable: true,
                get: function() {
                  if (!Buffer22.isBuffer(this)) return void 0;
                  return this.byteOffset;
                }
              });
              function createBuffer(length) {
                if (length > K_MAX_LENGTH) {
                  throw new RangeError('The value "' + length + '" is invalid for option "size"');
                }
                var buf = new Uint8Array(length);
                buf.__proto__ = Buffer22.prototype;
                return buf;
              }
              function Buffer22(arg, encodingOrOffset, length) {
                if (typeof arg === "number") {
                  if (typeof encodingOrOffset === "string") {
                    throw new TypeError(
                      'The "string" argument must be of type string. Received type number'
                    );
                  }
                  return allocUnsafe(arg);
                }
                return from(arg, encodingOrOffset, length);
              }
              if (typeof Symbol !== "undefined" && Symbol.species != null && Buffer22[Symbol.species] === Buffer22) {
                Object.defineProperty(Buffer22, Symbol.species, {
                  value: null,
                  configurable: true,
                  enumerable: false,
                  writable: false
                });
              }
              Buffer22.poolSize = 8192;
              function from(value, encodingOrOffset, length) {
                if (typeof value === "string") {
                  return fromString(value, encodingOrOffset);
                }
                if (ArrayBuffer.isView(value)) {
                  return fromArrayLike(value);
                }
                if (value == null) {
                  throw TypeError(
                    "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                  );
                }
                if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
                  return fromArrayBuffer(value, encodingOrOffset, length);
                }
                if (typeof value === "number") {
                  throw new TypeError(
                    'The "value" argument must not be of type number. Received type number'
                  );
                }
                var valueOf = value.valueOf && value.valueOf();
                if (valueOf != null && valueOf !== value) {
                  return Buffer22.from(valueOf, encodingOrOffset, length);
                }
                var b2 = fromObject(value);
                if (b2) return b2;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
                  return Buffer22.from(
                    value[Symbol.toPrimitive]("string"),
                    encodingOrOffset,
                    length
                  );
                }
                throw new TypeError(
                  "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
                );
              }
              Buffer22.from = function(value, encodingOrOffset, length) {
                return from(value, encodingOrOffset, length);
              };
              Buffer22.prototype.__proto__ = Uint8Array.prototype;
              Buffer22.__proto__ = Uint8Array;
              function assertSize(size) {
                if (typeof size !== "number") {
                  throw new TypeError('"size" argument must be of type number');
                } else if (size < 0) {
                  throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
              }
              function alloc(size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                  return createBuffer(size);
                }
                if (fill !== void 0) {
                  return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
                }
                return createBuffer(size);
              }
              Buffer22.alloc = function(size, fill, encoding) {
                return alloc(size, fill, encoding);
              };
              function allocUnsafe(size) {
                assertSize(size);
                return createBuffer(size < 0 ? 0 : checked(size) | 0);
              }
              Buffer22.allocUnsafe = function(size) {
                return allocUnsafe(size);
              };
              Buffer22.allocUnsafeSlow = function(size) {
                return allocUnsafe(size);
              };
              function fromString(string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                  encoding = "utf8";
                }
                if (!Buffer22.isEncoding(encoding)) {
                  throw new TypeError("Unknown encoding: " + encoding);
                }
                var length = byteLength(string, encoding) | 0;
                var buf = createBuffer(length);
                var actual = buf.write(string, encoding);
                if (actual !== length) {
                  buf = buf.slice(0, actual);
                }
                return buf;
              }
              function fromArrayLike(array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                var buf = createBuffer(length);
                for (var i2 = 0; i2 < length; i2 += 1) {
                  buf[i2] = array[i2] & 255;
                }
                return buf;
              }
              function fromArrayBuffer(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError('"length" is outside of buffer bounds');
                }
                var buf;
                if (byteOffset === void 0 && length === void 0) {
                  buf = new Uint8Array(array);
                } else if (length === void 0) {
                  buf = new Uint8Array(array, byteOffset);
                } else {
                  buf = new Uint8Array(array, byteOffset, length);
                }
                buf.__proto__ = Buffer22.prototype;
                return buf;
              }
              function fromObject(obj) {
                if (Buffer22.isBuffer(obj)) {
                  var len = checked(obj.length) | 0;
                  var buf = createBuffer(len);
                  if (buf.length === 0) {
                    return buf;
                  }
                  obj.copy(buf, 0, 0, len);
                  return buf;
                }
                if (obj.length !== void 0) {
                  if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
                    return createBuffer(0);
                  }
                  return fromArrayLike(obj);
                }
                if (obj.type === "Buffer" && Array.isArray(obj.data)) {
                  return fromArrayLike(obj.data);
                }
              }
              function checked(length) {
                if (length >= K_MAX_LENGTH) {
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
                }
                return length | 0;
              }
              function SlowBuffer(length) {
                if (+length != length) {
                  length = 0;
                }
                return Buffer22.alloc(+length);
              }
              Buffer22.isBuffer = function isBuffer(b2) {
                return b2 != null && b2._isBuffer === true && b2 !== Buffer22.prototype;
              };
              Buffer22.compare = function compare(a2, b2) {
                if (isInstance(a2, Uint8Array)) a2 = Buffer22.from(a2, a2.offset, a2.byteLength);
                if (isInstance(b2, Uint8Array)) b2 = Buffer22.from(b2, b2.offset, b2.byteLength);
                if (!Buffer22.isBuffer(a2) || !Buffer22.isBuffer(b2)) {
                  throw new TypeError(
                    'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
                  );
                }
                if (a2 === b2) return 0;
                var x2 = a2.length;
                var y2 = b2.length;
                for (var i2 = 0, len = Math.min(x2, y2); i2 < len; ++i2) {
                  if (a2[i2] !== b2[i2]) {
                    x2 = a2[i2];
                    y2 = b2[i2];
                    break;
                  }
                }
                if (x2 < y2) return -1;
                if (y2 < x2) return 1;
                return 0;
              };
              Buffer22.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              };
              Buffer22.concat = function concat(list, length) {
                if (!Array.isArray(list)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                  return Buffer22.alloc(0);
                }
                var i2;
                if (length === void 0) {
                  length = 0;
                  for (i2 = 0; i2 < list.length; ++i2) {
                    length += list[i2].length;
                  }
                }
                var buffer = Buffer22.allocUnsafe(length);
                var pos = 0;
                for (i2 = 0; i2 < list.length; ++i2) {
                  var buf = list[i2];
                  if (isInstance(buf, Uint8Array)) {
                    buf = Buffer22.from(buf);
                  }
                  if (!Buffer22.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  buf.copy(buffer, pos);
                  pos += buf.length;
                }
                return buffer;
              };
              function byteLength(string, encoding) {
                if (Buffer22.isBuffer(string)) {
                  return string.length;
                }
                if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
                  return string.byteLength;
                }
                if (typeof string !== "string") {
                  throw new TypeError(
                    'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
                  );
                }
                var len = string.length;
                var mustMatch = arguments.length > 2 && arguments[2] === true;
                if (!mustMatch && len === 0) return 0;
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return len;
                    case "utf8":
                    case "utf-8":
                      return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return len * 2;
                    case "hex":
                      return len >>> 1;
                    case "base64":
                      return base64ToBytes(string).length;
                    default:
                      if (loweredCase) {
                        return mustMatch ? -1 : utf8ToBytes(string).length;
                      }
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer22.byteLength = byteLength;
              function slowToString(encoding, start, end) {
                var loweredCase = false;
                if (start === void 0 || start < 0) {
                  start = 0;
                }
                if (start > this.length) {
                  return "";
                }
                if (end === void 0 || end > this.length) {
                  end = this.length;
                }
                if (end <= 0) {
                  return "";
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                  return "";
                }
                if (!encoding) encoding = "utf8";
                while (true) {
                  switch (encoding) {
                    case "hex":
                      return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, start, end);
                    case "ascii":
                      return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, start, end);
                    case "base64":
                      return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, start, end);
                    default:
                      if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                      encoding = (encoding + "").toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer22.prototype._isBuffer = true;
              function swap(b2, n2, m2) {
                var i2 = b2[n2];
                b2[n2] = b2[m2];
                b2[m2] = i2;
              }
              Buffer22.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (var i2 = 0; i2 < len; i2 += 2) {
                  swap(this, i2, i2 + 1);
                }
                return this;
              };
              Buffer22.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (var i2 = 0; i2 < len; i2 += 4) {
                  swap(this, i2, i2 + 3);
                  swap(this, i2 + 1, i2 + 2);
                }
                return this;
              };
              Buffer22.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (var i2 = 0; i2 < len; i2 += 8) {
                  swap(this, i2, i2 + 7);
                  swap(this, i2 + 1, i2 + 6);
                  swap(this, i2 + 2, i2 + 5);
                  swap(this, i2 + 3, i2 + 4);
                }
                return this;
              };
              Buffer22.prototype.toString = function toString2() {
                var length = this.length;
                if (length === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
              };
              Buffer22.prototype.toLocaleString = Buffer22.prototype.toString;
              Buffer22.prototype.equals = function equals(b2) {
                if (!Buffer22.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
                if (this === b2) return true;
                return Buffer22.compare(this, b2) === 0;
              };
              Buffer22.prototype.inspect = function inspect() {
                var str = "";
                var max = exports3.INSPECT_MAX_BYTES;
                str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > max) str += " ... ";
                return "<Buffer " + str + ">";
              };
              Buffer22.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (isInstance(target, Uint8Array)) {
                  target = Buffer22.from(target, target.offset, target.byteLength);
                }
                if (!Buffer22.isBuffer(target)) {
                  throw new TypeError(
                    'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
                  );
                }
                if (start === void 0) {
                  start = 0;
                }
                if (end === void 0) {
                  end = target ? target.length : 0;
                }
                if (thisStart === void 0) {
                  thisStart = 0;
                }
                if (thisEnd === void 0) {
                  thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                  throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                  return 0;
                }
                if (thisStart >= thisEnd) {
                  return -1;
                }
                if (start >= end) {
                  return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target) return 0;
                var x2 = thisEnd - thisStart;
                var y2 = end - start;
                var len = Math.min(x2, y2);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i2 = 0; i2 < len; ++i2) {
                  if (thisCopy[i2] !== targetCopy[i2]) {
                    x2 = thisCopy[i2];
                    y2 = targetCopy[i2];
                    break;
                  }
                }
                if (x2 < y2) return -1;
                if (y2 < x2) return 1;
                return 0;
              };
              function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0) return -1;
                if (typeof byteOffset === "string") {
                  encoding = byteOffset;
                  byteOffset = 0;
                } else if (byteOffset > 2147483647) {
                  byteOffset = 2147483647;
                } else if (byteOffset < -2147483648) {
                  byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (numberIsNaN(byteOffset)) {
                  byteOffset = dir ? 0 : buffer.length - 1;
                }
                if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                  if (dir) return -1;
                  else byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                  if (dir) byteOffset = 0;
                  else return -1;
                }
                if (typeof val === "string") {
                  val = Buffer22.from(val, encoding);
                }
                if (Buffer22.isBuffer(val)) {
                  if (val.length === 0) {
                    return -1;
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                  val = val & 255;
                  if (typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
              }
              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== void 0) {
                  encoding = String(encoding).toLowerCase();
                  if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                      return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                  }
                }
                function read(buf, i22) {
                  if (indexSize === 1) {
                    return buf[i22];
                  } else {
                    return buf.readUInt16BE(i22 * indexSize);
                  }
                }
                var i2;
                if (dir) {
                  var foundIndex = -1;
                  for (i2 = byteOffset; i2 < arrLength; i2++) {
                    if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
                      if (foundIndex === -1) foundIndex = i2;
                      if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
                    } else {
                      if (foundIndex !== -1) i2 -= i2 - foundIndex;
                      foundIndex = -1;
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
                  for (i2 = byteOffset; i2 >= 0; i2--) {
                    var found = true;
                    for (var j2 = 0; j2 < valLength; j2++) {
                      if (read(arr, i2 + j2) !== read(val, j2)) {
                        found = false;
                        break;
                      }
                    }
                    if (found) return i2;
                  }
                }
                return -1;
              }
              Buffer22.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
              };
              Buffer22.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
              };
              Buffer22.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
              };
              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                  length = remaining;
                } else {
                  length = Number(length);
                  if (length > remaining) {
                    length = remaining;
                  }
                }
                var strLen = string.length;
                if (length > strLen / 2) {
                  length = strLen / 2;
                }
                for (var i2 = 0; i2 < length; ++i2) {
                  var parsed = parseInt(string.substr(i2 * 2, 2), 16);
                  if (numberIsNaN(parsed)) return i2;
                  buf[offset + i2] = parsed;
                }
                return i2;
              }
              function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
              }
              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
              }
              function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
              }
              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
              }
              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
              }
              Buffer22.prototype.write = function write(string, offset, length, encoding) {
                if (offset === void 0) {
                  encoding = "utf8";
                  length = this.length;
                  offset = 0;
                } else if (length === void 0 && typeof offset === "string") {
                  encoding = offset;
                  length = this.length;
                  offset = 0;
                } else if (isFinite(offset)) {
                  offset = offset >>> 0;
                  if (isFinite(length)) {
                    length = length >>> 0;
                    if (encoding === void 0) encoding = "utf8";
                  } else {
                    encoding = length;
                    length = void 0;
                  }
                } else {
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                }
                var remaining = this.length - offset;
                if (length === void 0 || length > remaining) length = remaining;
                if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                  throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding) encoding = "utf8";
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "hex":
                      return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, string, offset, length);
                    case "ascii":
                      return asciiWrite(this, string, offset, length);
                    case "latin1":
                    case "binary":
                      return latin1Write(this, string, offset, length);
                    case "base64":
                      return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, string, offset, length);
                    default:
                      if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              };
              Buffer22.prototype.toJSON = function toJSON() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf);
                } else {
                  return base64.fromByteArray(buf.slice(start, end));
                }
              }
              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i2 = start;
                while (i2 < end) {
                  var firstByte = buf[i2];
                  var codePoint = null;
                  var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                  if (i2 + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                          codePoint = firstByte;
                        }
                        break;
                      case 2:
                        secondByte = buf[i2 + 1];
                        if ((secondByte & 192) === 128) {
                          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                          if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 3:
                        secondByte = buf[i2 + 1];
                        thirdByte = buf[i2 + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 4:
                        secondByte = buf[i2 + 1];
                        thirdByte = buf[i2 + 2];
                        fourthByte = buf[i2 + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                          }
                        }
                    }
                  }
                  if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                  } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                  }
                  res.push(codePoint);
                  i2 += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
              }
              var MAX_ARGUMENTS_LENGTH = 4096;
              function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints);
                }
                var res = "";
                var i2 = 0;
                while (i2 < len) {
                  res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
                  );
                }
                return res;
              }
              function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i2 = start; i2 < end; ++i2) {
                  ret += String.fromCharCode(buf[i2] & 127);
                }
                return ret;
              }
              function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i2 = start; i2 < end; ++i2) {
                  ret += String.fromCharCode(buf[i2]);
                }
                return ret;
              }
              function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0) start = 0;
                if (!end || end < 0 || end > len) end = len;
                var out = "";
                for (var i2 = start; i2 < end; ++i2) {
                  out += toHex(buf[i2]);
                }
                return out;
              }
              function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i2 = 0; i2 < bytes.length; i2 += 2) {
                  res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
                }
                return res;
              }
              Buffer22.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === void 0 ? len : ~~end;
                if (start < 0) {
                  start += len;
                  if (start < 0) start = 0;
                } else if (start > len) {
                  start = len;
                }
                if (end < 0) {
                  end += len;
                  if (end < 0) end = 0;
                } else if (end > len) {
                  end = len;
                }
                if (end < start) end = start;
                var newBuf = this.subarray(start, end);
                newBuf.__proto__ = Buffer22.prototype;
                return newBuf;
              };
              function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
                if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
              }
              Buffer22.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i2 = 0;
                while (++i2 < byteLength2 && (mul *= 256)) {
                  val += this[offset + i2] * mul;
                }
                return val;
              };
              Buffer22.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) {
                  checkOffset(offset, byteLength2, this.length);
                }
                var val = this[offset + --byteLength2];
                var mul = 1;
                while (byteLength2 > 0 && (mul *= 256)) {
                  val += this[offset + --byteLength2] * mul;
                }
                return val;
              };
              Buffer22.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                return this[offset];
              };
              Buffer22.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] | this[offset + 1] << 8;
              };
              Buffer22.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                return this[offset] << 8 | this[offset + 1];
              };
              Buffer22.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
              };
              Buffer22.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
              };
              Buffer22.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i2 = 0;
                while (++i2 < byteLength2 && (mul *= 256)) {
                  val += this[offset + i2] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer22.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) checkOffset(offset, byteLength2, this.length);
                var i2 = byteLength2;
                var mul = 1;
                var val = this[offset + --i2];
                while (i2 > 0 && (mul *= 256)) {
                  val += this[offset + --i2] * mul;
                }
                mul *= 128;
                if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer22.prototype.readInt8 = function readInt8(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 1, this.length);
                if (!(this[offset] & 128)) return this[offset];
                return (255 - this[offset] + 1) * -1;
              };
              Buffer22.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset] | this[offset + 1] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer22.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | this[offset] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer22.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
              };
              Buffer22.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
              };
              Buffer22.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
              };
              Buffer22.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
              };
              Buffer22.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
              };
              Buffer22.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                offset = offset >>> 0;
                if (!noAssert) checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
              };
              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer22.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
              }
              Buffer22.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var mul = 1;
                var i2 = 0;
                this[offset] = value & 255;
                while (++i2 < byteLength2 && (mul *= 256)) {
                  this[offset + i2] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer22.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                byteLength2 = byteLength2 >>> 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var i2 = byteLength2 - 1;
                var mul = 1;
                this[offset + i2] = value & 255;
                while (--i2 >= 0 && (mul *= 256)) {
                  this[offset + i2] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer22.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer22.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                return offset + 2;
              };
              Buffer22.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
                return offset + 2;
              };
              Buffer22.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                this[offset + 3] = value >>> 24;
                this[offset + 2] = value >>> 16;
                this[offset + 1] = value >>> 8;
                this[offset] = value & 255;
                return offset + 4;
              };
              Buffer22.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
                return offset + 4;
              };
              Buffer22.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i2 = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 255;
                while (++i2 < byteLength2 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i2] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer22.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i2 = byteLength2 - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i2] = value & 255;
                while (--i2 >= 0 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i2] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer22.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
                if (value < 0) value = 255 + value + 1;
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer22.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                return offset + 2;
              };
              Buffer22.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
                this[offset] = value >>> 8;
                this[offset + 1] = value & 255;
                return offset + 2;
              };
              Buffer22.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                this[offset] = value & 255;
                this[offset + 1] = value >>> 8;
                this[offset + 2] = value >>> 16;
                this[offset + 3] = value >>> 24;
                return offset + 4;
              };
              Buffer22.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (value < 0) value = 4294967295 + value + 1;
                this[offset] = value >>> 24;
                this[offset + 1] = value >>> 16;
                this[offset + 2] = value >>> 8;
                this[offset + 3] = value & 255;
                return offset + 4;
              };
              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length) throw new RangeError("Index out of range");
                if (offset < 0) throw new RangeError("Index out of range");
              }
              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 4);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
              }
              Buffer22.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
              };
              Buffer22.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
              };
              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                value = +value;
                offset = offset >>> 0;
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 8);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
              }
              Buffer22.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
              };
              Buffer22.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
              };
              Buffer22.prototype.copy = function copy(target, targetStart, start, end) {
                if (!Buffer22.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                if (!start) start = 0;
                if (!end && end !== 0) end = this.length;
                if (targetStart >= target.length) targetStart = target.length;
                if (!targetStart) targetStart = 0;
                if (end > 0 && end < start) end = start;
                if (end === start) return 0;
                if (target.length === 0 || this.length === 0) return 0;
                if (targetStart < 0) {
                  throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                if (end < 0) throw new RangeError("sourceEnd out of bounds");
                if (end > this.length) end = this.length;
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start;
                }
                var len = end - start;
                if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
                  this.copyWithin(targetStart, start, end);
                } else if (this === target && start < targetStart && targetStart < end) {
                  for (var i2 = len - 1; i2 >= 0; --i2) {
                    target[i2 + targetStart] = this[i2 + start];
                  }
                } else {
                  Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, end),
                    targetStart
                  );
                }
                return len;
              };
              Buffer22.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === "string") {
                  if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                  } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                  }
                  if (encoding !== void 0 && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                  }
                  if (typeof encoding === "string" && !Buffer22.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                  if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                      val = code;
                    }
                  }
                } else if (typeof val === "number") {
                  val = val & 255;
                }
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError("Out of range index");
                }
                if (end <= start) {
                  return this;
                }
                start = start >>> 0;
                end = end === void 0 ? this.length : end >>> 0;
                if (!val) val = 0;
                var i2;
                if (typeof val === "number") {
                  for (i2 = start; i2 < end; ++i2) {
                    this[i2] = val;
                  }
                } else {
                  var bytes = Buffer22.isBuffer(val) ? val : Buffer22.from(val, encoding);
                  var len = bytes.length;
                  if (len === 0) {
                    throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                  }
                  for (i2 = 0; i2 < end - start; ++i2) {
                    this[i2 + start] = bytes[i2 % len];
                  }
                }
                return this;
              };
              var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
              function base64clean(str) {
                str = str.split("=")[0];
                str = str.trim().replace(INVALID_BASE64_RE, "");
                if (str.length < 2) return "";
                while (str.length % 4 !== 0) {
                  str = str + "=";
                }
                return str;
              }
              function toHex(n2) {
                if (n2 < 16) return "0" + n2.toString(16);
                return n2.toString(16);
              }
              function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i2 = 0; i2 < length; ++i2) {
                  codePoint = string.charCodeAt(i2);
                  if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                      if (codePoint > 56319) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        continue;
                      } else if (i2 + 1 === length) {
                        if ((units -= 3) > -1) bytes.push(239, 191, 189);
                        continue;
                      }
                      leadSurrogate = codePoint;
                      continue;
                    }
                    if (codePoint < 56320) {
                      if ((units -= 3) > -1) bytes.push(239, 191, 189);
                      leadSurrogate = codePoint;
                      continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                  } else if (leadSurrogate) {
                    if ((units -= 3) > -1) bytes.push(239, 191, 189);
                  }
                  leadSurrogate = null;
                  if (codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                  } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(
                      codePoint >> 6 | 192,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(
                      codePoint >> 12 | 224,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0) break;
                    bytes.push(
                      codePoint >> 18 | 240,
                      codePoint >> 12 & 63 | 128,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else {
                    throw new Error("Invalid code point");
                  }
                }
                return bytes;
              }
              function asciiToBytes(str) {
                var byteArray = [];
                for (var i2 = 0; i2 < str.length; ++i2) {
                  byteArray.push(str.charCodeAt(i2) & 255);
                }
                return byteArray;
              }
              function utf16leToBytes(str, units) {
                var c2, hi, lo;
                var byteArray = [];
                for (var i2 = 0; i2 < str.length; ++i2) {
                  if ((units -= 2) < 0) break;
                  c2 = str.charCodeAt(i2);
                  hi = c2 >> 8;
                  lo = c2 % 256;
                  byteArray.push(lo);
                  byteArray.push(hi);
                }
                return byteArray;
              }
              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
              }
              function blitBuffer(src, dst, offset, length) {
                for (var i2 = 0; i2 < length; ++i2) {
                  if (i2 + offset >= dst.length || i2 >= src.length) break;
                  dst[i2 + offset] = src[i2];
                }
                return i2;
              }
              function isInstance(obj, type) {
                return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
              }
              function numberIsNaN(obj) {
                return obj !== obj;
              }
            }).call(this);
          }).call(this, require2("buffer").Buffer);
        }, { "base64-js": 31, "buffer": 34, "ieee754": 194 }], 35: [function(require2, module3, exports3) {
          module3.exports = {
            "100": "Continue",
            "101": "Switching Protocols",
            "102": "Processing",
            "200": "OK",
            "201": "Created",
            "202": "Accepted",
            "203": "Non-Authoritative Information",
            "204": "No Content",
            "205": "Reset Content",
            "206": "Partial Content",
            "207": "Multi-Status",
            "208": "Already Reported",
            "226": "IM Used",
            "300": "Multiple Choices",
            "301": "Moved Permanently",
            "302": "Found",
            "303": "See Other",
            "304": "Not Modified",
            "305": "Use Proxy",
            "307": "Temporary Redirect",
            "308": "Permanent Redirect",
            "400": "Bad Request",
            "401": "Unauthorized",
            "402": "Payment Required",
            "403": "Forbidden",
            "404": "Not Found",
            "405": "Method Not Allowed",
            "406": "Not Acceptable",
            "407": "Proxy Authentication Required",
            "408": "Request Timeout",
            "409": "Conflict",
            "410": "Gone",
            "411": "Length Required",
            "412": "Precondition Failed",
            "413": "Payload Too Large",
            "414": "URI Too Long",
            "415": "Unsupported Media Type",
            "416": "Range Not Satisfiable",
            "417": "Expectation Failed",
            "418": "I'm a teapot",
            "421": "Misdirected Request",
            "422": "Unprocessable Entity",
            "423": "Locked",
            "424": "Failed Dependency",
            "425": "Unordered Collection",
            "426": "Upgrade Required",
            "428": "Precondition Required",
            "429": "Too Many Requests",
            "431": "Request Header Fields Too Large",
            "451": "Unavailable For Legal Reasons",
            "500": "Internal Server Error",
            "501": "Not Implemented",
            "502": "Bad Gateway",
            "503": "Service Unavailable",
            "504": "Gateway Timeout",
            "505": "HTTP Version Not Supported",
            "506": "Variant Also Negotiates",
            "507": "Insufficient Storage",
            "508": "Loop Detected",
            "509": "Bandwidth Limit Exceeded",
            "510": "Not Extended",
            "511": "Network Authentication Required"
          };
        }, {}], 36: [function(require2, module3, exports3) {
          var GetIntrinsic = require2("get-intrinsic");
          var callBind = require2("./");
          var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
          module3.exports = function callBoundIntrinsic(name, allowMissing) {
            var intrinsic = GetIntrinsic(name, !!allowMissing);
            if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
              return callBind(intrinsic);
            }
            return intrinsic;
          };
        }, { "./": 37, "get-intrinsic": 189 }], 37: [function(require2, module3, exports3) {
          var bind = require2("function-bind");
          var GetIntrinsic = require2("get-intrinsic");
          var $apply = GetIntrinsic("%Function.prototype.apply%");
          var $call = GetIntrinsic("%Function.prototype.call%");
          var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
          var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
          var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
          var $max = GetIntrinsic("%Math.max%");
          if ($defineProperty) {
            try {
              $defineProperty({}, "a", { value: 1 });
            } catch (e2) {
              $defineProperty = null;
            }
          }
          module3.exports = function callBind(originalFunction) {
            var func = $reflectApply(bind, $call, arguments);
            if ($gOPD && $defineProperty) {
              var desc = $gOPD(func, "length");
              if (desc.configurable) {
                $defineProperty(
                  func,
                  "length",
                  { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
                );
              }
            }
            return func;
          };
          var applyBind = function applyBind2() {
            return $reflectApply(bind, $apply, arguments);
          };
          if ($defineProperty) {
            $defineProperty(module3.exports, "apply", { value: applyBind });
          } else {
            module3.exports.apply = applyBind;
          }
        }, { "function-bind": 188, "get-intrinsic": 189 }], 38: [function(require2, module3, exports3) {
          (function(process, global2) {
            (function() {
              var next = global2.process && process.nextTick || global2.setImmediate || function(f2) {
                setTimeout(f2, 0);
              };
              module3.exports = function maybe(cb, promise) {
                if (cb) {
                  promise.then(function(result) {
                    next(function() {
                      cb(null, result);
                    });
                  }, function(err) {
                    next(function() {
                      cb(err);
                    });
                  });
                  return void 0;
                } else {
                  return promise;
                }
              };
            }).call(this);
          }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "_process": 263 }], 39: [function(require2, module3, exports3) {
          var object = require2("es5-ext/object/valid-object"), stringifiable = require2("es5-ext/object/validate-stringifiable-value"), forOf = require2("es6-iterator/for-of");
          module3.exports = function(text, style) {
            var result = "";
            text = stringifiable(text);
            object(style);
            forOf(text, function(char) {
              result += style[char] || char;
            });
            return result;
          };
        }, { "es5-ext/object/valid-object": 95, "es5-ext/object/validate-stringifiable-value": 97, "es6-iterator/for-of": 167 }], 40: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var d2 = require2("d"), assign = require2("es5-ext/object/assign"), forEach = require2("es5-ext/object/for-each"), map = require2("es5-ext/object/map"), primitiveSet = require2("es5-ext/object/primitive-set"), setPrototypeOf = require2("es5-ext/object/set-prototype-of"), memoize = require2("memoizee"), memoizeMethods = require2("memoizee/methods"), sgr = require2("./lib/sgr"), supportsColor = require2("./lib/supports-color");
              var mods = sgr.mods, join = Array.prototype.join, defineProperty = Object.defineProperty, max = Math.max, min = Math.min, variantModes = primitiveSet("_fg", "_bg"), xtermMatch = process.platform === "win32" ? require2("./lib/xterm-match") : null;
              var getFn;
              var memoized = memoize(function(scope, mod) {
                return defineProperty(getFn(), "_cliColorData", d2(assign({}, scope._cliColorData, mod)));
              });
              var proto = Object.create(
                Function.prototype,
                assign(
                  map(mods, function(mod) {
                    return d2.gs(function() {
                      return memoized(this, mod);
                    });
                  }),
                  memoizeMethods({
                    // xterm (255) color
                    xterm: d2(function(code) {
                      code = isNaN(code) ? 255 : min(max(code, 0), 255);
                      return defineProperty(
                        getFn(),
                        "_cliColorData",
                        d2(
                          assign({}, this._cliColorData, {
                            _fg: [xtermMatch ? xtermMatch[code] : "38;5;" + code, 39]
                          })
                        )
                      );
                    }),
                    bgXterm: d2(function(code) {
                      code = isNaN(code) ? 255 : min(max(code, 0), 255);
                      return defineProperty(
                        getFn(),
                        "_cliColorData",
                        d2(
                          assign({}, this._cliColorData, {
                            _bg: [xtermMatch ? xtermMatch[code] + 10 : "48;5;" + code, 49]
                          })
                        )
                      );
                    })
                  })
                )
              );
              var getEndRe = memoize(function(code) {
                return new RegExp("\x1B\\[" + code + "m", "g");
              }, {
                primitive: true
              });
              getFn = function() {
                return setPrototypeOf(
                  function self2() {
                    var start = "", end = "", msg = join.call(arguments, " "), conf2 = self2._cliColorData, hasAnsi = sgr.hasCSI(msg);
                    forEach(
                      conf2,
                      function(mod, key) {
                        end = sgr(mod[1]) + end;
                        start += sgr(mod[0]);
                        if (hasAnsi) {
                          msg = msg.replace(getEndRe(mod[1]), variantModes[key] ? sgr(mod[0]) : "");
                        }
                      },
                      null,
                      true
                    );
                    if (!supportsColor.isColorSupported()) return msg;
                    return start + msg + end;
                  },
                  proto
                );
              };
              module3.exports = Object.defineProperties(getFn(), {
                xtermSupported: d2(!xtermMatch),
                _cliColorData: d2("", {})
              });
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./lib/sgr": 46, "./lib/supports-color": 47, "./lib/xterm-match": 49, "_process": 263, "d": 113, "es5-ext/object/assign": 76, "es5-ext/object/for-each": 81, "es5-ext/object/map": 89, "es5-ext/object/primitive-set": 90, "es5-ext/object/set-prototype-of": 91, "memoizee": 247, "memoizee/methods": 254 }], 41: [function(require2, module3, exports3) {
          module3.exports = "\x07";
        }, {}], 42: [function(require2, module3, exports3) {
          var generate = require2("es5-ext/array/generate"), from = require2("es5-ext/array/from"), iterable = require2("es5-ext/iterable/validate-object"), isValue = require2("es5-ext/object/is-value"), stringifiable = require2("es5-ext/object/validate-stringifiable"), repeat = require2("es5-ext/string/#/repeat"), getStrippedLength = require2("./get-stripped-length");
          var push = Array.prototype.push;
          module3.exports = function(inputRows) {
            var options = Object(arguments[1]), colsMeta = [], colsOptions = options.columns || [], rows = [];
            from(iterable(inputRows), function(row) {
              var rowRows = [[]];
              from(iterable(row), function(cellStr, columnIndex) {
                var cellRows = stringifiable(cellStr).split("\n");
                while (cellRows.length > rowRows.length) rowRows.push(generate(columnIndex, ""));
                cellRows.forEach(function(cellRow, rowRowIndex) {
                  rowRows[rowRowIndex][columnIndex] = cellRow;
                });
              });
              push.apply(rows, rowRows);
            });
            return rows.map(function(row) {
              return from(iterable(row), function(str, index) {
                var col = colsMeta[index], strLength;
                if (!col) col = colsMeta[index] = { width: 0 };
                str = stringifiable(str);
                strLength = getStrippedLength(str);
                if (strLength > col.width) col.width = strLength;
                return { str, length: strLength };
              });
            }).map(function(row) {
              return row.map(function(item, index) {
                var pad, align = "left", colOptions = colsOptions && colsOptions[index];
                align = colOptions && colOptions.align === "right" ? "right" : "left";
                pad = repeat.call(" ", colsMeta[index].width - item.length);
                if (align === "left") return item.str + pad;
                return pad + item.str;
              }).join(isValue(options.sep) ? options.sep : " | ");
            }).join("\n") + "\n";
          };
        }, { "./get-stripped-length": 44, "es5-ext/array/from": 54, "es5-ext/array/generate": 57, "es5-ext/iterable/validate-object": 63, "es5-ext/object/is-value": 85, "es5-ext/object/validate-stringifiable": 98, "es5-ext/string/#/repeat": 102 }], 43: [function(require2, module3, exports3) {
          module3.exports = {
            screen: "\x1B[2J",
            screenLeft: "\x1B[1J",
            screenRight: "\x1B[J",
            line: "\x1B[2K",
            lineLeft: "\x1B[1K",
            lineRight: "\x1B[K"
          };
        }, {}], 44: [function(require2, module3, exports3) {
          var strip = require2("./strip");
          module3.exports = function(str) {
            return strip(str).length;
          };
        }, { "./strip": 109 }], 45: [function(require2, module3, exports3) {
          var d2 = require2("d");
          module3.exports = Object.defineProperties(require2("./bare"), {
            windowSize: d2(require2("./window-size")),
            erase: d2(require2("./erase")),
            move: d2(require2("./move")),
            beep: d2(require2("./beep")),
            columns: d2(require2("./columns")),
            strip: d2(require2("./strip")),
            getStrippedLength: d2(require2("./get-stripped-length")),
            slice: d2(require2("./slice")),
            throbber: d2(require2("./throbber")),
            reset: d2(require2("./reset")),
            art: d2(require2("./art"))
          });
        }, { "./art": 39, "./bare": 40, "./beep": 41, "./columns": 42, "./erase": 43, "./get-stripped-length": 44, "./move": 50, "./reset": 107, "./slice": 108, "./strip": 109, "./throbber": 110, "./window-size": 111, "d": 113 }], 46: [function(require2, module3, exports3) {
          var assign = require2("es5-ext/object/assign"), includes = require2("es5-ext/string/#/contains"), forOwn = require2("es5-ext/object/for-each"), onlyKey = require2("es5-ext/object/first-key"), forEachRight = require2("es5-ext/array/#/for-each-right"), uniq = require2("es5-ext/array/#/uniq.js");
          var CSI = "\x1B[";
          var sgr = function(code) {
            return CSI + code + "m";
          };
          sgr.CSI = CSI;
          var mods = assign(
            {
              // Style
              bold: { _bold: [1, 22] },
              italic: { _italic: [3, 23] },
              underline: { _underline: [4, 24] },
              blink: { _blink: [5, 25] },
              inverse: { _inverse: [7, 27] },
              strike: { _strike: [9, 29] }
              // Color
            },
            ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"].reduce(function(obj, color, index) {
              obj[color] = { _fg: [30 + index, 39] };
              obj[color + "Bright"] = { _fg: [90 + index, 39] };
              obj["bg" + color[0].toUpperCase() + color.slice(1)] = { _bg: [40 + index, 49] };
              obj["bg" + color[0].toUpperCase() + color.slice(1) + "Bright"] = { _bg: [100 + index, 49] };
              return obj;
            }, {})
          );
          sgr.mods = mods;
          sgr.openers = {};
          sgr.closers = {};
          forOwn(mods, function(mod) {
            var modPair = mod[onlyKey(mod)];
            sgr.openers[modPair[0]] = modPair;
            sgr.closers[modPair[1]] = modPair;
          });
          sgr.openStyle = function(openedMods, code) {
            openedMods.push(sgr.openers[code]);
          };
          sgr.closeStyle = function(openedMods, code) {
            forEachRight.call(openedMods, function(modPair, index) {
              if (modPair[1] === code) {
                openedMods.splice(index, 1);
              }
            });
          };
          sgr.prepend = function(currentMods) {
            return currentMods.map(function(modPair) {
              return sgr(modPair[0]);
            });
          };
          sgr.complete = function(openedMods, closerCodes) {
            closerCodes.forEach(function(code) {
              sgr.closeStyle(openedMods, code);
            });
            openedMods = openedMods.reverse();
            openedMods = openedMods.map(function(modPair) {
              return modPair[1];
            });
            openedMods = uniq.call(openedMods);
            return openedMods.map(sgr);
          };
          var hasCSI = function(str) {
            return includes.call(str, CSI);
          };
          sgr.hasCSI = hasCSI;
          var extractCode = function(csi) {
            var code = csi.slice(2, -1);
            code = Number(code);
            return code;
          };
          sgr.extractCode = extractCode;
          module3.exports = sgr;
        }, { "es5-ext/array/#/for-each-right": 52, "es5-ext/array/#/uniq.js": 53, "es5-ext/object/assign": 76, "es5-ext/object/first-key": 80, "es5-ext/object/for-each": 81, "es5-ext/string/#/contains": 99 }], 47: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var state = null;
              var enableColor = function() {
                state = true;
              };
              var disableColor = function() {
                state = false;
              };
              var autoDetectSupport = function() {
                state = null;
              };
              var isColorSupported = function() {
                return state === null ? !process.env.NO_COLOR : state;
              };
              module3.exports = {
                enableColor,
                disableColor,
                autoDetectSupport,
                isColorSupported
              };
            }).call(this);
          }).call(this, require2("_process"));
        }, { "_process": 263 }], 48: [function(require2, module3, exports3) {
          module3.exports = [
            "000000",
            "800000",
            "008000",
            "808000",
            "000080",
            "800080",
            "008080",
            "c0c0c0",
            "808080",
            "ff0000",
            "00ff00",
            "ffff00",
            "0000ff",
            "ff00ff",
            "00ffff",
            "ffffff",
            "000000",
            "00005f",
            "000087",
            "0000af",
            "0000d7",
            "0000ff",
            "005f00",
            "005f5f",
            "005f87",
            "005faf",
            "005fd7",
            "005fff",
            "008700",
            "00875f",
            "008787",
            "0087af",
            "0087d7",
            "0087ff",
            "00af00",
            "00af5f",
            "00af87",
            "00afaf",
            "00afd7",
            "00afff",
            "00d700",
            "00d75f",
            "00d787",
            "00d7af",
            "00d7d7",
            "00d7ff",
            "00ff00",
            "00ff5f",
            "00ff87",
            "00ffaf",
            "00ffd7",
            "00ffff",
            "5f0000",
            "5f005f",
            "5f0087",
            "5f00af",
            "5f00d7",
            "5f00ff",
            "5f5f00",
            "5f5f5f",
            "5f5f87",
            "5f5faf",
            "5f5fd7",
            "5f5fff",
            "5f8700",
            "5f875f",
            "5f8787",
            "5f87af",
            "5f87d7",
            "5f87ff",
            "5faf00",
            "5faf5f",
            "5faf87",
            "5fafaf",
            "5fafd7",
            "5fafff",
            "5fd700",
            "5fd75f",
            "5fd787",
            "5fd7af",
            "5fd7d7",
            "5fd7ff",
            "5fff00",
            "5fff5f",
            "5fff87",
            "5fffaf",
            "5fffd7",
            "5fffff",
            "870000",
            "87005f",
            "870087",
            "8700af",
            "8700d7",
            "8700ff",
            "875f00",
            "875f5f",
            "875f87",
            "875faf",
            "875fd7",
            "875fff",
            "878700",
            "87875f",
            "878787",
            "8787af",
            "8787d7",
            "8787ff",
            "87af00",
            "87af5f",
            "87af87",
            "87afaf",
            "87afd7",
            "87afff",
            "87d700",
            "87d75f",
            "87d787",
            "87d7af",
            "87d7d7",
            "87d7ff",
            "87ff00",
            "87ff5f",
            "87ff87",
            "87ffaf",
            "87ffd7",
            "87ffff",
            "af0000",
            "af005f",
            "af0087",
            "af00af",
            "af00d7",
            "af00ff",
            "af5f00",
            "af5f5f",
            "af5f87",
            "af5faf",
            "af5fd7",
            "af5fff",
            "af8700",
            "af875f",
            "af8787",
            "af87af",
            "af87d7",
            "af87ff",
            "afaf00",
            "afaf5f",
            "afaf87",
            "afafaf",
            "afafd7",
            "afafff",
            "afd700",
            "afd75f",
            "afd787",
            "afd7af",
            "afd7d7",
            "afd7ff",
            "afff00",
            "afff5f",
            "afff87",
            "afffaf",
            "afffd7",
            "afffff",
            "d70000",
            "d7005f",
            "d70087",
            "d700af",
            "d700d7",
            "d700ff",
            "d75f00",
            "d75f5f",
            "d75f87",
            "d75faf",
            "d75fd7",
            "d75fff",
            "d78700",
            "d7875f",
            "d78787",
            "d787af",
            "d787d7",
            "d787ff",
            "d7af00",
            "d7af5f",
            "d7af87",
            "d7afaf",
            "d7afd7",
            "d7afff",
            "d7d700",
            "d7d75f",
            "d7d787",
            "d7d7af",
            "d7d7d7",
            "d7d7ff",
            "d7ff00",
            "d7ff5f",
            "d7ff87",
            "d7ffaf",
            "d7ffd7",
            "d7ffff",
            "ff0000",
            "ff005f",
            "ff0087",
            "ff00af",
            "ff00d7",
            "ff00ff",
            "ff5f00",
            "ff5f5f",
            "ff5f87",
            "ff5faf",
            "ff5fd7",
            "ff5fff",
            "ff8700",
            "ff875f",
            "ff8787",
            "ff87af",
            "ff87d7",
            "ff87ff",
            "ffaf00",
            "ffaf5f",
            "ffaf87",
            "ffafaf",
            "ffafd7",
            "ffafff",
            "ffd700",
            "ffd75f",
            "ffd787",
            "ffd7af",
            "ffd7d7",
            "ffd7ff",
            "ffff00",
            "ffff5f",
            "ffff87",
            "ffffaf",
            "ffffd7",
            "ffffff",
            "080808",
            "121212",
            "1c1c1c",
            "262626",
            "303030",
            "3a3a3a",
            "444444",
            "4e4e4e",
            "585858",
            "626262",
            "6c6c6c",
            "767676",
            "808080",
            "8a8a8a",
            "949494",
            "9e9e9e",
            "a8a8a8",
            "b2b2b2",
            "bcbcbc",
            "c6c6c6",
            "d0d0d0",
            "dadada",
            "e4e4e4",
            "eeeeee"
          ];
        }, {}], 49: [function(require2, module3, exports3) {
          var push = Array.prototype.push, reduce = Array.prototype.reduce, abs = Math.abs, colors, match, result, i2;
          colors = require2("./xterm-colors").map(function(color) {
            return {
              r: parseInt(color.slice(0, 2), 16),
              g: parseInt(color.slice(2, 4), 16),
              b: parseInt(color.slice(4), 16)
            };
          });
          match = colors.slice(0, 16);
          module3.exports = result = [];
          i2 = 0;
          while (i2 < 8) {
            result.push(30 + i2++);
          }
          i2 = 0;
          while (i2 < 8) {
            result.push(90 + i2++);
          }
          push.apply(
            result,
            colors.slice(16).map(function(data) {
              var index, diff = Infinity;
              match.every(function(innerMatch, currentIndex) {
                var ndiff = reduce.call(
                  "rgb",
                  function(currentDiff, channel) {
                    currentDiff += abs(innerMatch[channel] - data[channel]);
                    return currentDiff;
                  },
                  0
                );
                if (ndiff < diff) {
                  index = currentIndex;
                  diff = ndiff;
                }
                return ndiff;
              });
              return result[index];
            })
          );
        }, { "./xterm-colors": 48 }], 50: [function(require2, module3, exports3) {
          var d2 = require2("d"), trunc = require2("es5-ext/math/trunc");
          var up, down, right, left, abs = Math.abs, floor = Math.floor, max = Math.max;
          var getMove = function(control) {
            return function(num) {
              num = isNaN(num) ? 0 : max(floor(num), 0);
              return num ? "\x1B[" + num + control : "";
            };
          };
          module3.exports = Object.defineProperties(
            function(x2, y2) {
              x2 = isNaN(x2) ? 0 : floor(x2);
              y2 = isNaN(y2) ? 0 : floor(y2);
              return (x2 > 0 ? right(x2) : left(-x2)) + (y2 > 0 ? down(y2) : up(-y2));
            },
            {
              up: d2(up = getMove("A")),
              down: d2(down = getMove("B")),
              right: d2(right = getMove("C")),
              left: d2(left = getMove("D")),
              to: d2(function(x2, y2) {
                x2 = isNaN(x2) ? 1 : max(floor(x2), 0) + 1;
                y2 = isNaN(y2) ? 1 : max(floor(y2), 0) + 1;
                return "\x1B[" + y2 + ";" + x2 + "H";
              }),
              lines: d2(function(n2) {
                var dir;
                n2 = trunc(n2) || 0;
                dir = n2 >= 0 ? "B" : "A";
                n2 = floor(abs(n2));
                return "\x1B[" + n2 + dir + "\x1B[1G";
              }),
              top: d2("\x1B[5000F"),
              bottom: d2("\x1B[5000B"),
              lineBegin: d2("\x1B[5000D"),
              lineEnd: d2("\x1B[5000C")
            }
          );
        }, { "d": 113, "es5-ext/math/trunc": 67 }], 51: [function(require2, module3, exports3) {
          var numberIsNaN = require2("../../number/is-nan"), toPosInt = require2("../../number/to-pos-integer"), value = require2("../../object/valid-value"), indexOf = Array.prototype.indexOf, objHasOwnProperty = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
          module3.exports = function(searchElement) {
            var i2, length, fromIndex, val;
            if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);
            length = toPosInt(value(this).length);
            fromIndex = arguments[1];
            if (isNaN(fromIndex)) fromIndex = 0;
            else if (fromIndex >= 0) fromIndex = floor(fromIndex);
            else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
            for (i2 = fromIndex; i2 < length; ++i2) {
              if (objHasOwnProperty.call(this, i2)) {
                val = this[i2];
                if (numberIsNaN(val)) return i2;
              }
            }
            return -1;
          };
        }, { "../../number/is-nan": 70, "../../number/to-pos-integer": 74, "../../object/valid-value": 96 }], 52: [function(require2, module3, exports3) {
          var toPosInt = require2("../../number/to-pos-integer"), callable = require2("../../object/valid-callable"), value = require2("../../object/valid-value"), objHasOwnProperty = Object.prototype.hasOwnProperty, call = Function.prototype.call;
          module3.exports = function(cb) {
            var i2, self2, thisArg;
            self2 = Object(value(this));
            callable(cb);
            thisArg = arguments[1];
            for (i2 = toPosInt(self2.length) - 1; i2 >= 0; --i2) {
              if (objHasOwnProperty.call(self2, i2)) call.call(cb, thisArg, self2[i2], i2, self2);
            }
          };
        }, { "../../number/to-pos-integer": 74, "../../object/valid-callable": 94, "../../object/valid-value": 96 }], 53: [function(require2, module3, exports3) {
          var indexOf = require2("./e-index-of"), filter = Array.prototype.filter, isFirst;
          isFirst = function(value, index) {
            return indexOf.call(this, value) === index;
          };
          module3.exports = function() {
            return filter.call(this, isFirst, this);
          };
        }, { "./e-index-of": 51 }], 54: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Array.from : require2("./shim");
        }, { "./is-implemented": 55, "./shim": 56 }], 55: [function(require2, module3, exports3) {
          module3.exports = function() {
            var from = Array.from, arr, result;
            if (typeof from !== "function") return false;
            arr = ["raz", "dwa"];
            result = from(arr);
            return Boolean(result && result !== arr && result[1] === "dwa");
          };
        }, {}], 56: [function(require2, module3, exports3) {
          var iteratorSymbol = require2("es6-symbol").iterator, isArguments = require2("../../function/is-arguments"), isFunction = require2("../../function/is-function"), toPosInt = require2("../../number/to-pos-integer"), callable = require2("../../object/valid-callable"), validValue = require2("../../object/valid-value"), isValue = require2("../../object/is-value"), isString = require2("../../string/is-string"), isArray = Array.isArray, call = Function.prototype.call, desc = { configurable: true, enumerable: true, writable: true, value: null }, defineProperty = Object.defineProperty;
          module3.exports = function(arrayLike) {
            var mapFn = arguments[1], thisArg = arguments[2], Context, i2, j2, arr, length, code, iterator, result, getIterator, value;
            arrayLike = Object(validValue(arrayLike));
            if (isValue(mapFn)) callable(mapFn);
            if (!this || this === Array || !isFunction(this)) {
              if (!mapFn) {
                if (isArguments(arrayLike)) {
                  length = arrayLike.length;
                  if (length !== 1) return Array.apply(null, arrayLike);
                  arr = new Array(1);
                  arr[0] = arrayLike[0];
                  return arr;
                }
                if (isArray(arrayLike)) {
                  arr = new Array(length = arrayLike.length);
                  for (i2 = 0; i2 < length; ++i2) arr[i2] = arrayLike[i2];
                  return arr;
                }
              }
              arr = [];
            } else {
              Context = this;
            }
            if (!isArray(arrayLike)) {
              if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
                iterator = callable(getIterator).call(arrayLike);
                if (Context) arr = new Context();
                result = iterator.next();
                i2 = 0;
                while (!result.done) {
                  value = mapFn ? call.call(mapFn, thisArg, result.value, i2) : result.value;
                  if (Context) {
                    desc.value = value;
                    defineProperty(arr, i2, desc);
                  } else {
                    arr[i2] = value;
                  }
                  result = iterator.next();
                  ++i2;
                }
                length = i2;
              } else if (isString(arrayLike)) {
                length = arrayLike.length;
                if (Context) arr = new Context();
                for (i2 = 0, j2 = 0; i2 < length; ++i2) {
                  value = arrayLike[i2];
                  if (i2 + 1 < length) {
                    code = value.charCodeAt(0);
                    if (code >= 55296 && code <= 56319) value += arrayLike[++i2];
                  }
                  value = mapFn ? call.call(mapFn, thisArg, value, j2) : value;
                  if (Context) {
                    desc.value = value;
                    defineProperty(arr, j2, desc);
                  } else {
                    arr[j2] = value;
                  }
                  ++j2;
                }
                length = j2;
              }
            }
            if (length === void 0) {
              length = toPosInt(arrayLike.length);
              if (Context) arr = new Context(length);
              for (i2 = 0; i2 < length; ++i2) {
                value = mapFn ? call.call(mapFn, thisArg, arrayLike[i2], i2) : arrayLike[i2];
                if (Context) {
                  desc.value = value;
                  defineProperty(arr, i2, desc);
                } else {
                  arr[i2] = value;
                }
              }
            }
            if (Context) {
              desc.value = null;
              arr.length = length;
            }
            return arr;
          };
        }, { "../../function/is-arguments": 59, "../../function/is-function": 60, "../../number/to-pos-integer": 74, "../../object/is-value": 85, "../../object/valid-callable": 94, "../../object/valid-value": 96, "../../string/is-string": 105, "es6-symbol": 173 }], 57: [function(require2, module3, exports3) {
          var toPosInt = require2("../number/to-pos-integer"), value = require2("../object/valid-value"), slice = Array.prototype.slice;
          module3.exports = function(length) {
            var arr, currentLength;
            length = toPosInt(value(length));
            if (length === 0) return [];
            arr = arguments.length < 2 ? [void 0] : slice.call(arguments, 1, 1 + length);
            while ((currentLength = arr.length) < length) {
              arr = arr.concat(arr.slice(0, length - currentLength));
            }
            return arr;
          };
        }, { "../number/to-pos-integer": 74, "../object/valid-value": 96 }], 58: [function(require2, module3, exports3) {
          var isValue = require2("../../object/is-value"), callable = require2("../../object/valid-callable"), aFrom = require2("../../array/from");
          var apply = Function.prototype.apply, call = Function.prototype.call, callFn = function(arg, fn) {
            return call.call(fn, this, arg);
          };
          module3.exports = function(fnIgnored) {
            var fns, first;
            var args = aFrom(arguments);
            fns = isValue(this) ? [this].concat(args) : args;
            fns.forEach(callable);
            fns = fns.reverse();
            first = fns[0];
            fns = fns.slice(1);
            return function(argIgnored) {
              return fns.reduce(callFn, apply.call(first, this, arguments));
            };
          };
        }, { "../../array/from": 54, "../../object/is-value": 85, "../../object/valid-callable": 94 }], 59: [function(require2, module3, exports3) {
          var objToString = Object.prototype.toString, id = objToString.call(/* @__PURE__ */ function() {
            return arguments;
          }());
          module3.exports = function(value) {
            return objToString.call(value) === id;
          };
        }, {}], 60: [function(require2, module3, exports3) {
          var objToString = Object.prototype.toString, isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
          module3.exports = function(value) {
            return typeof value === "function" && isFunctionStringTag(objToString.call(value));
          };
        }, {}], 61: [function(require2, module3, exports3) {
          module3.exports = function() {
          };
        }, {}], 62: [function(require2, module3, exports3) {
          var iteratorSymbol = require2("es6-symbol").iterator, isValue = require2("../object/is-value"), isArrayLike = require2("../object/is-array-like");
          module3.exports = function(value) {
            if (!isValue(value)) return false;
            if (typeof value[iteratorSymbol] === "function") return true;
            return isArrayLike(value);
          };
        }, { "../object/is-array-like": 82, "../object/is-value": 85, "es6-symbol": 173 }], 63: [function(require2, module3, exports3) {
          var isObject2 = require2("../object/is-object"), is = require2("./is");
          module3.exports = function(value) {
            if (is(value) && isObject2(value)) return value;
            throw new TypeError(value + " is not an iterable or array-like object");
          };
        }, { "../object/is-object": 84, "./is": 62 }], 64: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Math.sign : require2("./shim");
        }, { "./is-implemented": 65, "./shim": 66 }], 65: [function(require2, module3, exports3) {
          module3.exports = function() {
            var sign = Math.sign;
            if (typeof sign !== "function") return false;
            return sign(10) === 1 && sign(-20) === -1;
          };
        }, {}], 66: [function(require2, module3, exports3) {
          module3.exports = function(value) {
            value = Number(value);
            if (isNaN(value) || value === 0) return value;
            return value > 0 ? 1 : -1;
          };
        }, {}], 67: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Math.trunc : require2("./shim");
        }, { "./is-implemented": 68, "./shim": 69 }], 68: [function(require2, module3, exports3) {
          module3.exports = function() {
            var trunc = Math.trunc;
            if (typeof trunc !== "function") return false;
            return trunc(13.67) === 13 && trunc(-13.67) === -13;
          };
        }, {}], 69: [function(require2, module3, exports3) {
          var floor = Math.floor;
          module3.exports = function(value) {
            if (isNaN(value)) return NaN;
            value = Number(value);
            if (value === 0) return value;
            if (value === Infinity) return Infinity;
            if (value === -Infinity) return -Infinity;
            if (value > 0) return floor(value);
            return -floor(-value);
          };
        }, {}], 70: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Number.isNaN : require2("./shim");
        }, { "./is-implemented": 71, "./shim": 72 }], 71: [function(require2, module3, exports3) {
          module3.exports = function() {
            var numberIsNaN = Number.isNaN;
            if (typeof numberIsNaN !== "function") return false;
            return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
          };
        }, {}], 72: [function(require2, module3, exports3) {
          module3.exports = function(value) {
            return value !== value;
          };
        }, {}], 73: [function(require2, module3, exports3) {
          var sign = require2("../math/sign"), abs = Math.abs, floor = Math.floor;
          module3.exports = function(value) {
            if (isNaN(value)) return 0;
            value = Number(value);
            if (value === 0 || !isFinite(value)) return value;
            return sign(value) * floor(abs(value));
          };
        }, { "../math/sign": 64 }], 74: [function(require2, module3, exports3) {
          var toInteger = require2("./to-integer"), max = Math.max;
          module3.exports = function(value) {
            return max(0, toInteger(value));
          };
        }, { "./to-integer": 73 }], 75: [function(require2, module3, exports3) {
          var callable = require2("./valid-callable"), value = require2("./valid-value"), bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys, objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
          module3.exports = function(method, defVal) {
            return function(obj, cb) {
              var list, thisArg = arguments[2], compareFn = arguments[3];
              obj = Object(value(obj));
              callable(cb);
              list = keys(obj);
              if (compareFn) {
                list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
              }
              if (typeof method !== "function") method = list[method];
              return call.call(method, list, function(key, index) {
                if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
                return call.call(cb, thisArg, obj[key], key, obj, index);
              });
            };
          };
        }, { "./valid-callable": 94, "./valid-value": 96 }], 76: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Object.assign : require2("./shim");
        }, { "./is-implemented": 77, "./shim": 78 }], 77: [function(require2, module3, exports3) {
          module3.exports = function() {
            var assign = Object.assign, obj;
            if (typeof assign !== "function") return false;
            obj = { foo: "raz" };
            assign(obj, { bar: "dwa" }, { trzy: "trzy" });
            return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
          };
        }, {}], 78: [function(require2, module3, exports3) {
          var keys = require2("../keys"), value = require2("../valid-value"), max = Math.max;
          module3.exports = function(dest, src) {
            var error, i2, length = max(arguments.length, 2), assign;
            dest = Object(value(dest));
            assign = function(key) {
              try {
                dest[key] = src[key];
              } catch (e2) {
                if (!error) error = e2;
              }
            };
            for (i2 = 1; i2 < length; ++i2) {
              src = arguments[i2];
              keys(src).forEach(assign);
            }
            if (error !== void 0) throw error;
            return dest;
          };
        }, { "../keys": 86, "../valid-value": 96 }], 79: [function(require2, module3, exports3) {
          var create = Object.create, shim;
          if (!require2("./set-prototype-of/is-implemented")()) {
            shim = require2("./set-prototype-of/shim");
          }
          module3.exports = function() {
            var nullObject, polyProps, desc;
            if (!shim) return create;
            if (shim.level !== 1) return create;
            nullObject = {};
            polyProps = {};
            desc = { configurable: false, enumerable: false, writable: true, value: void 0 };
            Object.getOwnPropertyNames(Object.prototype).forEach(function(name) {
              if (name === "__proto__") {
                polyProps[name] = {
                  configurable: true,
                  enumerable: false,
                  writable: true,
                  value: void 0
                };
                return;
              }
              polyProps[name] = desc;
            });
            Object.defineProperties(nullObject, polyProps);
            Object.defineProperty(shim, "nullPolyfill", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: nullObject
            });
            return function(prototype, props) {
              return create(prototype === null ? nullObject : prototype, props);
            };
          }();
        }, { "./set-prototype-of/is-implemented": 92, "./set-prototype-of/shim": 93 }], 80: [function(require2, module3, exports3) {
          var value = require2("./valid-value"), objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
          module3.exports = function(obj) {
            var i2;
            value(obj);
            for (i2 in obj) {
              if (objPropertyIsEnumerable.call(obj, i2)) return i2;
            }
            return null;
          };
        }, { "./valid-value": 96 }], 81: [function(require2, module3, exports3) {
          module3.exports = require2("./_iterate")("forEach");
        }, { "./_iterate": 75 }], 82: [function(require2, module3, exports3) {
          var isFunction = require2("../function/is-function"), isObject2 = require2("./is-object"), isValue = require2("./is-value");
          module3.exports = function(value) {
            return isValue(value) && typeof value.length === "number" && // Just checking ((typeof x === 'object') && (typeof x !== 'function'))
            // won't work right for some cases, e.g.:
            // type of instance of NodeList in Safari is a 'function'
            (isObject2(value) && !isFunction(value) || typeof value === "string") || false;
          };
        }, { "../function/is-function": 60, "./is-object": 84, "./is-value": 85 }], 83: [function(require2, module3, exports3) {
          module3.exports = function(obj) {
            return typeof obj === "function";
          };
        }, {}], 84: [function(require2, module3, exports3) {
          var isValue = require2("./is-value");
          var map = { function: true, object: true };
          module3.exports = function(value) {
            return isValue(value) && map[typeof value] || false;
          };
        }, { "./is-value": 85 }], 85: [function(require2, module3, exports3) {
          var _undefined = require2("../function/noop")();
          module3.exports = function(val) {
            return val !== _undefined && val !== null;
          };
        }, { "../function/noop": 61 }], 86: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Object.keys : require2("./shim");
        }, { "./is-implemented": 87, "./shim": 88 }], 87: [function(require2, module3, exports3) {
          module3.exports = function() {
            try {
              Object.keys("primitive");
              return true;
            } catch (e2) {
              return false;
            }
          };
        }, {}], 88: [function(require2, module3, exports3) {
          var isValue = require2("../is-value");
          var keys = Object.keys;
          module3.exports = function(object) {
            return keys(isValue(object) ? Object(object) : object);
          };
        }, { "../is-value": 85 }], 89: [function(require2, module3, exports3) {
          var callable = require2("./valid-callable"), forEach = require2("./for-each"), call = Function.prototype.call;
          module3.exports = function(obj, cb) {
            var result = {}, thisArg = arguments[2];
            callable(cb);
            forEach(obj, function(value, key, targetObj, index) {
              result[key] = call.call(cb, thisArg, value, key, targetObj, index);
            });
            return result;
          };
        }, { "./for-each": 81, "./valid-callable": 94 }], 90: [function(require2, module3, exports3) {
          var forEach = Array.prototype.forEach, create = Object.create;
          module3.exports = function(arg) {
            var set = create(null);
            forEach.call(arguments, function(name) {
              set[name] = true;
            });
            return set;
          };
        }, {}], 91: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? Object.setPrototypeOf : require2("./shim");
        }, { "./is-implemented": 92, "./shim": 93 }], 92: [function(require2, module3, exports3) {
          var create = Object.create, getPrototypeOf = Object.getPrototypeOf, plainObject = {};
          module3.exports = function() {
            var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
            if (typeof setPrototypeOf !== "function") return false;
            return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
          };
        }, {}], 93: [function(require2, module3, exports3) {
          var isObject2 = require2("../is-object"), value = require2("../valid-value"), objIsPrototypeOf = Object.prototype.isPrototypeOf, defineProperty = Object.defineProperty, nullDesc = { configurable: true, enumerable: false, writable: true, value: void 0 }, validate;
          validate = function(obj, prototype) {
            value(obj);
            if (prototype === null || isObject2(prototype)) return obj;
            throw new TypeError("Prototype must be null or an object");
          };
          module3.exports = function(status) {
            var fn, set;
            if (!status) return null;
            if (status.level === 2) {
              if (status.set) {
                set = status.set;
                fn = function(obj, prototype) {
                  set.call(validate(obj, prototype), prototype);
                  return obj;
                };
              } else {
                fn = function(obj, prototype) {
                  validate(obj, prototype).__proto__ = prototype;
                  return obj;
                };
              }
            } else {
              fn = function self2(obj, prototype) {
                var isNullBase;
                validate(obj, prototype);
                isNullBase = objIsPrototypeOf.call(self2.nullPolyfill, obj);
                if (isNullBase) delete self2.nullPolyfill.__proto__;
                if (prototype === null) prototype = self2.nullPolyfill;
                obj.__proto__ = prototype;
                if (isNullBase) defineProperty(self2.nullPolyfill, "__proto__", nullDesc);
                return obj;
              };
            }
            return Object.defineProperty(fn, "level", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: status.level
            });
          }(
            function() {
              var tmpObj1 = /* @__PURE__ */ Object.create(null), tmpObj2 = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
              if (desc) {
                try {
                  set = desc.set;
                  set.call(tmpObj1, tmpObj2);
                } catch (ignore) {
                }
                if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set, level: 2 };
              }
              tmpObj1.__proto__ = tmpObj2;
              if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };
              tmpObj1 = {};
              tmpObj1.__proto__ = tmpObj2;
              if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };
              return false;
            }()
          );
          require2("../create");
        }, { "../create": 79, "../is-object": 84, "../valid-value": 96 }], 94: [function(require2, module3, exports3) {
          module3.exports = function(fn) {
            if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
            return fn;
          };
        }, {}], 95: [function(require2, module3, exports3) {
          var isObject2 = require2("./is-object");
          module3.exports = function(value) {
            if (!isObject2(value)) throw new TypeError(value + " is not an Object");
            return value;
          };
        }, { "./is-object": 84 }], 96: [function(require2, module3, exports3) {
          var isValue = require2("./is-value");
          module3.exports = function(value) {
            if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
            return value;
          };
        }, { "./is-value": 85 }], 97: [function(require2, module3, exports3) {
          var ensureValue = require2("./valid-value"), stringifiable = require2("./validate-stringifiable");
          module3.exports = function(value) {
            return stringifiable(ensureValue(value));
          };
        }, { "./valid-value": 96, "./validate-stringifiable": 98 }], 98: [function(require2, module3, exports3) {
          var isCallable = require2("./is-callable");
          module3.exports = function(stringifiable) {
            try {
              if (stringifiable && isCallable(stringifiable.toString)) return stringifiable.toString();
              return String(stringifiable);
            } catch (e2) {
              throw new TypeError("Passed argument cannot be stringifed");
            }
          };
        }, { "./is-callable": 83 }], 99: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? String.prototype.contains : require2("./shim");
        }, { "./is-implemented": 100, "./shim": 101 }], 100: [function(require2, module3, exports3) {
          var str = "razdwatrzy";
          module3.exports = function() {
            if (typeof str.contains !== "function") return false;
            return str.contains("dwa") === true && str.contains("foo") === false;
          };
        }, {}], 101: [function(require2, module3, exports3) {
          var indexOf = String.prototype.indexOf;
          module3.exports = function(searchString) {
            return indexOf.call(this, searchString, arguments[1]) > -1;
          };
        }, {}], 102: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? String.prototype.repeat : require2("./shim");
        }, { "./is-implemented": 103, "./shim": 104 }], 103: [function(require2, module3, exports3) {
          var str = "foo";
          module3.exports = function() {
            if (typeof str.repeat !== "function") return false;
            return str.repeat(2) === "foofoo";
          };
        }, {}], 104: [function(require2, module3, exports3) {
          var value = require2("../../../object/valid-value"), toInteger = require2("../../../number/to-integer");
          module3.exports = function(count) {
            var str = String(value(this)), result;
            count = toInteger(count);
            if (count < 0) throw new RangeError("Count must be >= 0");
            if (!isFinite(count)) throw new RangeError("Count must be < ∞");
            result = "";
            while (count) {
              if (count % 2) result += str;
              if (count > 1) str += str;
              count >>= 1;
            }
            return result;
          };
        }, { "../../../number/to-integer": 73, "../../../object/valid-value": 96 }], 105: [function(require2, module3, exports3) {
          var objToString = Object.prototype.toString, id = objToString.call("");
          module3.exports = function(value) {
            return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
          };
        }, {}], 106: [function(require2, module3, exports3) {
          module3.exports = function() {
            return new RegExp(
              "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
              "g"
            );
          };
        }, {}], 107: [function(require2, module3, exports3) {
          module3.exports = "\x1B[2J\x1B[0;0H";
        }, {}], 108: [function(require2, module3, exports3) {
          var reAnsi = require2("./regex-ansi"), stringifiable = require2("es5-ext/object/validate-stringifiable-value"), length = require2("./get-stripped-length"), sgr = require2("./lib/sgr"), max = Math.max;
          var Token = function(token) {
            this.token = token;
          };
          var tokenize = function(str) {
            var match = reAnsi().exec(str);
            if (!match) {
              return [str];
            }
            var index = match.index, head, prehead, tail;
            if (index === 0) {
              head = match[0];
              tail = str.slice(head.length);
              return [new Token(head)].concat(tokenize(tail));
            }
            prehead = str.slice(0, index);
            head = match[0];
            tail = str.slice(index + head.length);
            return [prehead, new Token(head)].concat(tokenize(tail));
          };
          var isChunkInSlice = function(chunk, index, begin, end) {
            var endIndex = chunk.length + index;
            if (begin > endIndex) return false;
            if (end < index) return false;
            return true;
          };
          var sliceSeq = function(seq, begin, end) {
            var sliced = seq.reduce(
              function(state, chunk) {
                var index = state.index;
                if (chunk instanceof Token) {
                  var code = sgr.extractCode(chunk.token);
                  if (index <= begin) {
                    if (code in sgr.openers) {
                      sgr.openStyle(state.preOpeners, code);
                    }
                    if (code in sgr.closers) {
                      sgr.closeStyle(state.preOpeners, code);
                    }
                  } else if (index < end) {
                    if (code in sgr.openers) {
                      sgr.openStyle(state.inOpeners, code);
                      state.seq.push(chunk);
                    } else if (code in sgr.closers) {
                      state.inClosers.push(code);
                      state.seq.push(chunk);
                    }
                  }
                } else {
                  var nextChunk = "";
                  if (isChunkInSlice(chunk, index, begin, end)) {
                    var relBegin = Math.max(begin - index, 0), relEnd = Math.min(end - index, chunk.length);
                    nextChunk = chunk.slice(relBegin, relEnd);
                  }
                  state.seq.push(nextChunk);
                  state.index = index + chunk.length;
                }
                return state;
              },
              {
                index: 0,
                seq: [],
                // preOpeners -> [ mod ]
                // preOpeners must be prepended to the slice if they wasn't closed til the end of it
                // preOpeners must be closed if they wasn't closed til the end of the slice
                preOpeners: [],
                // inOpeners  -> [ mod ]
                // inOpeners already in the slice and must not be prepended to the slice
                // inOpeners must be closed if they wasn't closed til the end of the slice
                inOpeners: [],
                // opener CSI inside slice
                // inClosers -> [ code ]
                // closer CSIs for determining which pre/in-Openers must be closed
                inClosers: []
              }
            );
            sliced.seq = [].concat(
              sgr.prepend(sliced.preOpeners),
              sliced.seq,
              sgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)
            );
            return sliced.seq;
          };
          module3.exports = function(str) {
            var seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;
            str = stringifiable(str);
            len = length(str);
            if (isNaN(begin)) {
              begin = 0;
            }
            if (isNaN(end)) {
              end = len;
            }
            if (begin < 0) {
              begin = max(len + begin, 0);
            }
            if (end < 0) {
              end = max(len + end, 0);
            }
            seq = tokenize(str);
            seq = sliceSeq(seq, begin, end);
            return seq.map(function(chunk) {
              if (chunk instanceof Token) {
                return chunk.token;
              }
              return chunk;
            }).join("");
          };
        }, { "./get-stripped-length": 44, "./lib/sgr": 46, "./regex-ansi": 106, "es5-ext/object/validate-stringifiable-value": 97 }], 109: [function(require2, module3, exports3) {
          var stringifiable = require2("es5-ext/object/validate-stringifiable"), r2 = require2("./regex-ansi")();
          module3.exports = function(str) {
            return stringifiable(str).replace(r2, "");
          };
        }, { "./regex-ansi": 106, "es5-ext/object/validate-stringifiable": 98 }], 110: [function(require2, module3, exports3) {
          var compose = require2("es5-ext/function/#/compose"), callable = require2("es5-ext/object/valid-callable"), d2 = require2("d"), validTimeout = require2("timers-ext/valid-timeout");
          var chars = "-\\|/", l2 = chars.length, ThrobberIterator;
          ThrobberIterator = function() {
          };
          Object.defineProperties(ThrobberIterator.prototype, {
            index: d2(-1),
            running: d2(false),
            next: d2(function() {
              var str = this.running ? "\b" : "";
              if (!this.running) this.running = true;
              return str + chars[this.index = (this.index + 1) % l2];
            }),
            reset: d2(function() {
              if (!this.running) return "";
              this.index = -1;
              this.running = false;
              return "\b";
            })
          });
          module3.exports = exports3 = function(write, interval) {
            var format = arguments[2], token, iterator = new ThrobberIterator();
            callable(write);
            interval = validTimeout(interval);
            if (format !== void 0) write = compose.call(write, callable(format));
            return {
              start: function() {
                if (token) return;
                token = setInterval(function() {
                  write(iterator.next());
                }, interval);
              },
              restart: function() {
                this.stop();
                this.start();
              },
              stop: function() {
                if (!token) return;
                clearInterval(token);
                token = null;
                write(iterator.reset());
              }
            };
          };
          Object.defineProperty(exports3, "Iterator", d2(ThrobberIterator));
        }, { "d": 113, "es5-ext/function/#/compose": 58, "es5-ext/object/valid-callable": 94, "timers-ext/valid-timeout": 291 }], 111: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var d2 = require2("d");
              Object.defineProperties(exports3, {
                width: d2.gs("ce", function() {
                  return process.stdout.columns || 0;
                }),
                height: d2.gs("ce", function() {
                  return process.stdout.rows || 0;
                })
              });
            }).call(this);
          }).call(this, require2("_process"));
        }, { "_process": 263, "d": 113 }], 112: [function(require2, module3, exports3) {
          var isValue = require2("type/value/is"), ensureValue = require2("type/value/ensure"), ensurePlainFunction = require2("type/plain-function/ensure"), copy = require2("es5-ext/object/copy"), normalizeOptions = require2("es5-ext/object/normalize-options"), map = require2("es5-ext/object/map");
          var bind = Function.prototype.bind, defineProperty = Object.defineProperty, hasOwnProperty2 = Object.prototype.hasOwnProperty, define3;
          define3 = function(name, desc, options) {
            var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
            dgs = copy(desc);
            delete dgs.writable;
            delete dgs.value;
            dgs.get = function() {
              if (!options.overwriteDefinition && hasOwnProperty2.call(this, name)) return value;
              desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
              defineProperty(this, name, desc);
              return this[name];
            };
            return dgs;
          };
          module3.exports = function(props) {
            var options = normalizeOptions(arguments[1]);
            if (isValue(options.resolveContext)) ensurePlainFunction(options.resolveContext);
            return map(props, function(desc, name) {
              return define3(name, desc, options);
            });
          };
        }, { "es5-ext/object/copy": 140, "es5-ext/object/map": 149, "es5-ext/object/normalize-options": 151, "type/plain-function/ensure": 297, "type/value/ensure": 301, "type/value/is": 302 }], 113: [function(require2, module3, exports3) {
          var isValue = require2("type/value/is"), isPlainFunction = require2("type/plain-function/is"), assign = require2("es5-ext/object/assign"), normalizeOpts = require2("es5-ext/object/normalize-options"), contains = require2("es5-ext/string/#/contains");
          var d2 = module3.exports = function(dscr, value) {
            var c2, e2, w2, options, desc;
            if (arguments.length < 2 || typeof dscr !== "string") {
              options = value;
              value = dscr;
              dscr = null;
            } else {
              options = arguments[2];
            }
            if (isValue(dscr)) {
              c2 = contains.call(dscr, "c");
              e2 = contains.call(dscr, "e");
              w2 = contains.call(dscr, "w");
            } else {
              c2 = w2 = true;
              e2 = false;
            }
            desc = { value, configurable: c2, enumerable: e2, writable: w2 };
            return !options ? desc : assign(normalizeOpts(options), desc);
          };
          d2.gs = function(dscr, get2, set) {
            var c2, e2, options, desc;
            if (typeof dscr !== "string") {
              options = set;
              set = get2;
              get2 = dscr;
              dscr = null;
            } else {
              options = arguments[3];
            }
            if (!isValue(get2)) {
              get2 = void 0;
            } else if (!isPlainFunction(get2)) {
              options = get2;
              get2 = set = void 0;
            } else if (!isValue(set)) {
              set = void 0;
            } else if (!isPlainFunction(set)) {
              options = set;
              set = void 0;
            }
            if (isValue(dscr)) {
              c2 = contains.call(dscr, "c");
              e2 = contains.call(dscr, "e");
            } else {
              c2 = true;
              e2 = false;
            }
            desc = { get: get2, set, configurable: c2, enumerable: e2 };
            return !options ? desc : assign(normalizeOpts(options), desc);
          };
        }, { "es5-ext/object/assign": 137, "es5-ext/object/normalize-options": 151, "es5-ext/string/#/contains": 161, "type/plain-function/is": 298, "type/value/is": 302 }], 114: [function(require2, module3, exports3) {
          var isPlainFunction = require2("type/plain-function/is"), ensureValue = require2("type/value/ensure"), isValue = require2("type/value/is"), map = require2("es5-ext/object/map"), contains = require2("es5-ext/string/#/contains");
          var call = Function.prototype.call, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, hasOwnProperty2 = Object.prototype.hasOwnProperty, cacheDesc = { configurable: false, enumerable: false, writable: false, value: null }, define3;
          define3 = function(name, options) {
            var value, dgs, cacheName, desc, writable = false, resolvable, flat;
            options = Object(ensureValue(options));
            cacheName = options.cacheName;
            flat = options.flat;
            if (!isValue(cacheName)) cacheName = name;
            delete options.cacheName;
            value = options.value;
            resolvable = isPlainFunction(value);
            delete options.value;
            dgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };
            if (name !== cacheName) {
              dgs.get = function() {
                if (hasOwnProperty2.call(this, cacheName)) return this[cacheName];
                cacheDesc.value = resolvable ? call.call(value, this, options) : value;
                cacheDesc.writable = writable;
                defineProperty(this, cacheName, cacheDesc);
                cacheDesc.value = null;
                if (desc) defineProperty(this, name, desc);
                return this[cacheName];
              };
            } else if (!flat) {
              dgs.get = function self2() {
                var ownDesc;
                if (hasOwnProperty2.call(this, name)) {
                  ownDesc = getOwnPropertyDescriptor(this, name);
                  if (ownDesc) {
                    if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
                    if (typeof ownDesc.get === "function" && ownDesc.get !== self2) {
                      return ownDesc.get.call(this);
                    }
                    return value;
                  }
                }
                desc.value = resolvable ? call.call(value, this, options) : value;
                defineProperty(this, name, desc);
                desc.value = null;
                return this[name];
              };
            } else {
              dgs.get = function self2() {
                var base = this, ownDesc;
                if (hasOwnProperty2.call(this, name)) {
                  ownDesc = getOwnPropertyDescriptor(this, name);
                  if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
                  if (typeof ownDesc.get === "function" && ownDesc.get !== self2) {
                    return ownDesc.get.call(this);
                  }
                }
                while (!hasOwnProperty2.call(base, name)) base = getPrototypeOf(base);
                desc.value = resolvable ? call.call(value, base, options) : value;
                defineProperty(base, name, desc);
                desc.value = null;
                return base[name];
              };
            }
            dgs.set = function(value2) {
              if (hasOwnProperty2.call(this, name)) {
                throw new TypeError("Cannot assign to lazy defined '" + name + "' property of " + this);
              }
              dgs.get.call(this);
              this[cacheName] = value2;
            };
            if (options.desc) {
              desc = {
                configurable: contains.call(options.desc, "c"),
                enumerable: contains.call(options.desc, "e")
              };
              if (cacheName === name) {
                desc.writable = contains.call(options.desc, "w");
                desc.value = null;
              } else {
                writable = contains.call(options.desc, "w");
                desc.get = dgs.get;
                desc.set = dgs.set;
              }
              delete options.desc;
            } else if (cacheName === name) {
              desc = {
                configurable: Boolean(options.configurable),
                enumerable: Boolean(options.enumerable),
                writable: Boolean(options.writable),
                value: null
              };
            }
            delete options.configurable;
            delete options.enumerable;
            delete options.writable;
            return dgs;
          };
          module3.exports = function(props) {
            return map(props, function(desc, name) {
              return define3(name, desc);
            });
          };
        }, { "es5-ext/object/map": 149, "es5-ext/string/#/contains": 161, "type/plain-function/is": 298, "type/value/ensure": 301, "type/value/is": 302 }], 115: [function(require2, module3, exports3) {
          var undefined2;
          var $SyntaxError = SyntaxError;
          var $Function = Function;
          var $TypeError = TypeError;
          var getEvalledConstructor = function(expressionSyntax) {
            try {
              return Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
            } catch (e2) {
            }
          };
          var $gOPD = Object.getOwnPropertyDescriptor;
          if ($gOPD) {
            try {
              $gOPD({}, "");
            } catch (e2) {
              $gOPD = null;
            }
          }
          var throwTypeError = function() {
            throw new $TypeError();
          };
          var ThrowTypeError = $gOPD ? function() {
            try {
              arguments.callee;
              return throwTypeError;
            } catch (calleeThrows) {
              try {
                return $gOPD(arguments, "callee").get;
              } catch (gOPDthrows) {
                return throwTypeError;
              }
            }
          }() : throwTypeError;
          var hasSymbols = require2("has-symbols")();
          var getProto = Object.getPrototypeOf || function(x2) {
            return x2.__proto__;
          };
          var asyncGenFunction = getEvalledConstructor("async function* () {}");
          var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined2;
          var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined2;
          var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
          var INTRINSICS = {
            "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
            "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
            "%AsyncFromSyncIteratorPrototype%": undefined2,
            "%AsyncFunction%": getEvalledConstructor("async function () {}"),
            "%AsyncGenerator%": asyncGenFunctionPrototype,
            "%AsyncGeneratorFunction%": asyncGenFunction,
            "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined2,
            "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
            "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval,
            // eslint-disable-line no-eval
            "%EvalError%": EvalError,
            "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
            "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
            "%Function%": $Function,
            "%GeneratorFunction%": getEvalledConstructor("function* () {}"),
            "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
            "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
            "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
            "%JSON%": typeof JSON === "object" ? JSON : undefined2,
            "%Map%": typeof Map === "undefined" ? undefined2 : Map,
            "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
            "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set === "undefined" ? undefined2 : Set,
            "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
            "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
            "%Symbol%": hasSymbols ? Symbol : undefined2,
            "%SyntaxError%": $SyntaxError,
            "%ThrowTypeError%": ThrowTypeError,
            "%TypedArray%": TypedArray,
            "%TypeError%": $TypeError,
            "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
            "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
            "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
            "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
          };
          var LEGACY_ALIASES = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
          };
          var bind = require2("function-bind");
          var hasOwn = require2("has");
          var $concat = bind.call(Function.call, Array.prototype.concat);
          var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
          var $replace = bind.call(Function.call, String.prototype.replace);
          var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
          var reEscapeChar = /\\(\\)?/g;
          var stringToPath = function stringToPath2(string) {
            var result = [];
            $replace(string, rePropName, function(match, number, quote, subString) {
              result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
            });
            return result;
          };
          var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
              alias = LEGACY_ALIASES[intrinsicName];
              intrinsicName = "%" + alias[0] + "%";
            }
            if (hasOwn(INTRINSICS, intrinsicName)) {
              var value = INTRINSICS[intrinsicName];
              if (typeof value === "undefined" && !allowMissing) {
                throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
              }
              return {
                alias,
                name: intrinsicName,
                value
              };
            }
            throw new $SyntaxError("intrinsic " + name + " does not exist!");
          };
          module3.exports = function GetIntrinsic(name, allowMissing) {
            if (typeof name !== "string" || name.length === 0) {
              throw new $TypeError("intrinsic name must be a non-empty string");
            }
            if (arguments.length > 1 && typeof allowMissing !== "boolean") {
              throw new $TypeError('"allowMissing" argument must be a boolean');
            }
            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
            var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;
            var alias = intrinsic.alias;
            if (alias) {
              intrinsicBaseName = alias[0];
              $spliceApply(parts, $concat([0, 1], alias));
            }
            for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
              var part = parts[i2];
              if (part === "constructor" || !isOwn) {
                skipFurtherCaching = true;
              }
              intrinsicBaseName += "." + part;
              intrinsicRealName = "%" + intrinsicBaseName + "%";
              if (hasOwn(INTRINSICS, intrinsicRealName)) {
                value = INTRINSICS[intrinsicRealName];
              } else if (value != null) {
                if ($gOPD && i2 + 1 >= parts.length) {
                  var desc = $gOPD(value, part);
                  isOwn = !!desc;
                  if (!allowMissing && !(part in value)) {
                    throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                  }
                  if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                    value = desc.get;
                  } else {
                    value = value[part];
                  }
                } else {
                  isOwn = hasOwn(value, part);
                  value = value[part];
                }
                if (isOwn && !skipFurtherCaching) {
                  INTRINSICS[intrinsicRealName] = value;
                }
              }
            }
            return value;
          };
        }, { "function-bind": 188, "has": 192, "has-symbols": 190 }], 116: [function(require2, module3, exports3) {
          var GetIntrinsic = require2("../GetIntrinsic");
          var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%");
          if ($gOPD) {
            try {
              $gOPD([], "length");
            } catch (e2) {
              $gOPD = null;
            }
          }
          module3.exports = $gOPD;
        }, { "../GetIntrinsic": 115 }], 117: [function(require2, module3, exports3) {
          var value = require2("../../object/valid-value");
          module3.exports = function() {
            value(this).length = 0;
            return this;
          };
        }, { "../../object/valid-value": 157 }], 118: [function(require2, module3, exports3) {
          var numberIsNaN = require2("../../number/is-nan"), toPosInt = require2("../../number/to-pos-integer"), value = require2("../../object/valid-value"), indexOf = Array.prototype.indexOf, objHasOwnProperty = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
          module3.exports = function(searchElement) {
            var i2, length, fromIndex, val;
            if (!numberIsNaN(searchElement)) return indexOf.apply(this, arguments);
            length = toPosInt(value(this).length);
            fromIndex = arguments[1];
            if (isNaN(fromIndex)) fromIndex = 0;
            else if (fromIndex >= 0) fromIndex = floor(fromIndex);
            else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
            for (i2 = fromIndex; i2 < length; ++i2) {
              if (objHasOwnProperty.call(this, i2)) {
                val = this[i2];
                if (numberIsNaN(val)) return i2;
              }
            }
            return -1;
          };
        }, { "../../number/is-nan": 131, "../../number/to-pos-integer": 135, "../../object/valid-value": 157 }], 119: [function(require2, module3, exports3) {
          arguments[4][54][0].apply(exports3, arguments);
        }, { "./is-implemented": 120, "./shim": 121, "dup": 54 }], 120: [function(require2, module3, exports3) {
          arguments[4][55][0].apply(exports3, arguments);
        }, { "dup": 55 }], 121: [function(require2, module3, exports3) {
          var iteratorSymbol = require2("es6-symbol").iterator, isArguments = require2("../../function/is-arguments"), isFunction = require2("../../function/is-function"), toPosInt = require2("../../number/to-pos-integer"), callable = require2("../../object/valid-callable"), validValue = require2("../../object/valid-value"), isValue = require2("../../object/is-value"), isString = require2("../../string/is-string"), isArray = Array.isArray, call = Function.prototype.call, desc = { configurable: true, enumerable: true, writable: true, value: null }, defineProperty = Object.defineProperty;
          module3.exports = function(arrayLike) {
            var mapFn = arguments[1], thisArg = arguments[2], Context, i2, j2, arr, length, code, iterator, result, getIterator, value;
            arrayLike = Object(validValue(arrayLike));
            if (isValue(mapFn)) callable(mapFn);
            if (!this || this === Array || !isFunction(this)) {
              if (!mapFn) {
                if (isArguments(arrayLike)) {
                  length = arrayLike.length;
                  if (length !== 1) return Array.apply(null, arrayLike);
                  arr = new Array(1);
                  arr[0] = arrayLike[0];
                  return arr;
                }
                if (isArray(arrayLike)) {
                  arr = new Array(length = arrayLike.length);
                  for (i2 = 0; i2 < length; ++i2) arr[i2] = arrayLike[i2];
                  return arr;
                }
              }
              arr = [];
            } else {
              Context = this;
            }
            if (!isArray(arrayLike)) {
              if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
                iterator = callable(getIterator).call(arrayLike);
                if (Context) arr = new Context();
                result = iterator.next();
                i2 = 0;
                while (!result.done) {
                  value = mapFn ? call.call(mapFn, thisArg, result.value, i2) : result.value;
                  if (Context) {
                    desc.value = value;
                    defineProperty(arr, i2, desc);
                  } else {
                    arr[i2] = value;
                  }
                  result = iterator.next();
                  ++i2;
                }
                length = i2;
              } else if (isString(arrayLike)) {
                length = arrayLike.length;
                if (Context) arr = new Context();
                for (i2 = 0, j2 = 0; i2 < length; ++i2) {
                  value = arrayLike[i2];
                  if (i2 + 1 < length) {
                    code = value.charCodeAt(0);
                    if (code >= 55296 && code <= 56319) value += arrayLike[++i2];
                  }
                  value = mapFn ? call.call(mapFn, thisArg, value, j2) : value;
                  if (Context) {
                    desc.value = value;
                    defineProperty(arr, j2, desc);
                  } else {
                    arr[j2] = value;
                  }
                  ++j2;
                }
                length = j2;
              }
            }
            if (length === void 0) {
              length = toPosInt(arrayLike.length);
              if (Context) arr = new Context(length);
              for (i2 = 0; i2 < length; ++i2) {
                value = mapFn ? call.call(mapFn, thisArg, arrayLike[i2], i2) : arrayLike[i2];
                if (Context) {
                  desc.value = value;
                  defineProperty(arr, i2, desc);
                } else {
                  arr[i2] = value;
                }
              }
            }
            if (Context) {
              desc.value = null;
              arr.length = length;
            }
            return arr;
          };
        }, { "../../function/is-arguments": 125, "../../function/is-function": 126, "../../number/to-pos-integer": 135, "../../object/is-value": 145, "../../object/valid-callable": 156, "../../object/valid-value": 157, "../../string/is-string": 164, "es6-symbol": 173 }], 122: [function(require2, module3, exports3) {
          var from = require2("./from"), isArray = Array.isArray;
          module3.exports = function(arrayLike) {
            return isArray(arrayLike) ? arrayLike : from(arrayLike);
          };
        }, { "./from": 119 }], 123: [function(require2, module3, exports3) {
          var assign = require2("../object/assign"), isObject2 = require2("../object/is-object"), isValue = require2("../object/is-value"), captureStackTrace = Error.captureStackTrace;
          module3.exports = function(message) {
            var err = new Error(message), code = arguments[1], ext = arguments[2];
            if (!isValue(ext)) {
              if (isObject2(code)) {
                ext = code;
                code = null;
              }
            }
            if (isValue(ext)) assign(err, ext);
            if (isValue(code)) err.code = code;
            if (captureStackTrace) captureStackTrace(err, module3.exports);
            return err;
          };
        }, { "../object/assign": 137, "../object/is-object": 144, "../object/is-value": 145 }], 124: [function(require2, module3, exports3) {
          var toPosInt = require2("../number/to-pos-integer");
          var test = function(arg1, arg2) {
            return arg2;
          };
          var desc, defineProperty, generate, mixin;
          try {
            Object.defineProperty(test, "length", {
              configurable: true,
              writable: false,
              enumerable: false,
              value: 1
            });
          } catch (ignore) {
          }
          if (test.length === 1) {
            desc = { configurable: true, writable: false, enumerable: false };
            defineProperty = Object.defineProperty;
            module3.exports = function(fn, length) {
              length = toPosInt(length);
              if (fn.length === length) return fn;
              desc.value = length;
              return defineProperty(fn, "length", desc);
            };
          } else {
            mixin = require2("../object/mixin");
            generate = /* @__PURE__ */ function() {
              var cache = [];
              return function(length) {
                var args, i2 = 0;
                if (cache[length]) return cache[length];
                args = [];
                while (length--) args.push("a" + (++i2).toString(36));
                return new Function(
                  "fn",
                  "return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
                );
              };
            }();
            module3.exports = function(src, length) {
              var target;
              length = toPosInt(length);
              if (src.length === length) return src;
              target = generate(length)(src);
              try {
                mixin(target, src);
              } catch (ignore) {
              }
              return target;
            };
          }
        }, { "../number/to-pos-integer": 135, "../object/mixin": 150 }], 125: [function(require2, module3, exports3) {
          arguments[4][59][0].apply(exports3, arguments);
        }, { "dup": 59 }], 126: [function(require2, module3, exports3) {
          arguments[4][60][0].apply(exports3, arguments);
        }, { "dup": 60 }], 127: [function(require2, module3, exports3) {
          arguments[4][61][0].apply(exports3, arguments);
        }, { "dup": 61 }], 128: [function(require2, module3, exports3) {
          arguments[4][64][0].apply(exports3, arguments);
        }, { "./is-implemented": 129, "./shim": 130, "dup": 64 }], 129: [function(require2, module3, exports3) {
          arguments[4][65][0].apply(exports3, arguments);
        }, { "dup": 65 }], 130: [function(require2, module3, exports3) {
          arguments[4][66][0].apply(exports3, arguments);
        }, { "dup": 66 }], 131: [function(require2, module3, exports3) {
          arguments[4][70][0].apply(exports3, arguments);
        }, { "./is-implemented": 132, "./shim": 133, "dup": 70 }], 132: [function(require2, module3, exports3) {
          arguments[4][71][0].apply(exports3, arguments);
        }, { "dup": 71 }], 133: [function(require2, module3, exports3) {
          arguments[4][72][0].apply(exports3, arguments);
        }, { "dup": 72 }], 134: [function(require2, module3, exports3) {
          arguments[4][73][0].apply(exports3, arguments);
        }, { "../math/sign": 128, "dup": 73 }], 135: [function(require2, module3, exports3) {
          arguments[4][74][0].apply(exports3, arguments);
        }, { "./to-integer": 134, "dup": 74 }], 136: [function(require2, module3, exports3) {
          var callable = require2("./valid-callable"), value = require2("./valid-value"), bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys, objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
          module3.exports = function(method, defVal) {
            return function(obj, cb) {
              var list, thisArg = arguments[2], compareFn = arguments[3];
              obj = Object(value(obj));
              callable(cb);
              list = keys(obj);
              if (compareFn) {
                list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
              }
              if (typeof method !== "function") method = list[method];
              return call.call(method, list, function(key, index) {
                if (!objPropertyIsEnumerable.call(obj, key)) return defVal;
                return call.call(cb, thisArg, obj[key], key, obj, index);
              });
            };
          };
        }, { "./valid-callable": 156, "./valid-value": 157 }], 137: [function(require2, module3, exports3) {
          arguments[4][76][0].apply(exports3, arguments);
        }, { "./is-implemented": 138, "./shim": 139, "dup": 76 }], 138: [function(require2, module3, exports3) {
          arguments[4][77][0].apply(exports3, arguments);
        }, { "dup": 77 }], 139: [function(require2, module3, exports3) {
          var keys = require2("../keys"), value = require2("../valid-value"), max = Math.max;
          module3.exports = function(dest, src) {
            var error, i2, length = max(arguments.length, 2), assign;
            dest = Object(value(dest));
            assign = function(key) {
              try {
                dest[key] = src[key];
              } catch (e2) {
                if (!error) error = e2;
              }
            };
            for (i2 = 1; i2 < length; ++i2) {
              src = arguments[i2];
              keys(src).forEach(assign);
            }
            if (error !== void 0) throw error;
            return dest;
          };
        }, { "../keys": 146, "../valid-value": 157 }], 140: [function(require2, module3, exports3) {
          var aFrom = require2("../array/from"), assign = require2("./assign"), value = require2("./valid-value");
          module3.exports = function(obj) {
            var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
            if (copy !== obj && !propertyNames) return copy;
            var result = {};
            if (propertyNames) {
              aFrom(propertyNames, function(propertyName) {
                if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
              });
            } else {
              assign(result, obj);
            }
            return result;
          };
        }, { "../array/from": 119, "./assign": 137, "./valid-value": 157 }], 141: [function(require2, module3, exports3) {
          arguments[4][79][0].apply(exports3, arguments);
        }, { "./set-prototype-of/is-implemented": 154, "./set-prototype-of/shim": 155, "dup": 79 }], 142: [function(require2, module3, exports3) {
          arguments[4][81][0].apply(exports3, arguments);
        }, { "./_iterate": 136, "dup": 81 }], 143: [function(require2, module3, exports3) {
          arguments[4][83][0].apply(exports3, arguments);
        }, { "dup": 83 }], 144: [function(require2, module3, exports3) {
          arguments[4][84][0].apply(exports3, arguments);
        }, { "./is-value": 145, "dup": 84 }], 145: [function(require2, module3, exports3) {
          arguments[4][85][0].apply(exports3, arguments);
        }, { "../function/noop": 127, "dup": 85 }], 146: [function(require2, module3, exports3) {
          arguments[4][86][0].apply(exports3, arguments);
        }, { "./is-implemented": 147, "./shim": 148, "dup": 86 }], 147: [function(require2, module3, exports3) {
          arguments[4][87][0].apply(exports3, arguments);
        }, { "dup": 87 }], 148: [function(require2, module3, exports3) {
          arguments[4][88][0].apply(exports3, arguments);
        }, { "../is-value": 145, "dup": 88 }], 149: [function(require2, module3, exports3) {
          var callable = require2("./valid-callable"), forEach = require2("./for-each"), call = Function.prototype.call;
          module3.exports = function(obj, cb) {
            var result = {}, thisArg = arguments[2];
            callable(cb);
            forEach(obj, function(value, key, targetObj, index) {
              result[key] = call.call(cb, thisArg, value, key, targetObj, index);
            });
            return result;
          };
        }, { "./for-each": 142, "./valid-callable": 156 }], 150: [function(require2, module3, exports3) {
          var value = require2("./valid-value"), defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
          module3.exports = function(target, source) {
            var error, sourceObject = Object(value(source));
            target = Object(value(target));
            getOwnPropertyNames(sourceObject).forEach(function(name) {
              try {
                defineProperty(target, name, getOwnPropertyDescriptor(source, name));
              } catch (e2) {
                error = e2;
              }
            });
            if (typeof getOwnPropertySymbols === "function") {
              getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
                try {
                  defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
                } catch (e2) {
                  error = e2;
                }
              });
            }
            if (error !== void 0) throw error;
            return target;
          };
        }, { "./valid-value": 157 }], 151: [function(require2, module3, exports3) {
          var isValue = require2("./is-value");
          var forEach = Array.prototype.forEach, create = Object.create;
          var process = function(src, obj) {
            var key;
            for (key in src) obj[key] = src[key];
          };
          module3.exports = function(opts1) {
            var result = create(null);
            forEach.call(arguments, function(options) {
              if (!isValue(options)) return;
              process(Object(options), result);
            });
            return result;
          };
        }, { "./is-value": 145 }], 152: [function(require2, module3, exports3) {
          var forEach = Array.prototype.forEach, create = Object.create;
          module3.exports = function(arg) {
            var set = create(null);
            forEach.call(arguments, function(name) {
              set[name] = true;
            });
            return set;
          };
        }, {}], 153: [function(require2, module3, exports3) {
          arguments[4][91][0].apply(exports3, arguments);
        }, { "./is-implemented": 154, "./shim": 155, "dup": 91 }], 154: [function(require2, module3, exports3) {
          arguments[4][92][0].apply(exports3, arguments);
        }, { "dup": 92 }], 155: [function(require2, module3, exports3) {
          arguments[4][93][0].apply(exports3, arguments);
        }, { "../create": 141, "../is-object": 144, "../valid-value": 157, "dup": 93 }], 156: [function(require2, module3, exports3) {
          arguments[4][94][0].apply(exports3, arguments);
        }, { "dup": 94 }], 157: [function(require2, module3, exports3) {
          arguments[4][96][0].apply(exports3, arguments);
        }, { "./is-value": 145, "dup": 96 }], 158: [function(require2, module3, exports3) {
          arguments[4][97][0].apply(exports3, arguments);
        }, { "./valid-value": 157, "./validate-stringifiable": 159, "dup": 97 }], 159: [function(require2, module3, exports3) {
          arguments[4][98][0].apply(exports3, arguments);
        }, { "./is-callable": 143, "dup": 98 }], 160: [function(require2, module3, exports3) {
          var isCallable = require2("./object/is-callable");
          module3.exports = function(value) {
            try {
              if (value && isCallable(value.toString)) return value.toString();
              return String(value);
            } catch (e2) {
              return "<Non-coercible to string value>";
            }
          };
        }, { "./object/is-callable": 143 }], 161: [function(require2, module3, exports3) {
          arguments[4][99][0].apply(exports3, arguments);
        }, { "./is-implemented": 162, "./shim": 163, "dup": 99 }], 162: [function(require2, module3, exports3) {
          arguments[4][100][0].apply(exports3, arguments);
        }, { "dup": 100 }], 163: [function(require2, module3, exports3) {
          var indexOf = String.prototype.indexOf;
          module3.exports = function(searchString) {
            return indexOf.call(this, searchString, arguments[1]) > -1;
          };
        }, {}], 164: [function(require2, module3, exports3) {
          arguments[4][105][0].apply(exports3, arguments);
        }, { "dup": 105 }], 165: [function(require2, module3, exports3) {
          var safeToString = require2("./safe-to-string");
          var reNewLine = /[\n\r\u2028\u2029]/g;
          module3.exports = function(value) {
            var string = safeToString(value);
            if (string.length > 100) string = string.slice(0, 99) + "…";
            string = string.replace(reNewLine, function(char) {
              return JSON.stringify(char).slice(1, -1);
            });
            return string;
          };
        }, { "./safe-to-string": 160 }], 166: [function(require2, module3, exports3) {
          var setPrototypeOf = require2("es5-ext/object/set-prototype-of"), contains = require2("es5-ext/string/#/contains"), d2 = require2("d"), Symbol2 = require2("es6-symbol"), Iterator = require2("./");
          var defineProperty = Object.defineProperty, ArrayIterator;
          ArrayIterator = module3.exports = function(arr, kind) {
            if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
            Iterator.call(this, arr);
            if (!kind) kind = "value";
            else if (contains.call(kind, "key+value")) kind = "key+value";
            else if (contains.call(kind, "key")) kind = "key";
            else kind = "value";
            defineProperty(this, "__kind__", d2("", kind));
          };
          if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);
          delete ArrayIterator.prototype.constructor;
          ArrayIterator.prototype = Object.create(Iterator.prototype, {
            _resolve: d2(function(i2) {
              if (this.__kind__ === "value") return this.__list__[i2];
              if (this.__kind__ === "key+value") return [i2, this.__list__[i2]];
              return i2;
            })
          });
          defineProperty(ArrayIterator.prototype, Symbol2.toStringTag, d2("c", "Array Iterator"));
        }, { "./": 169, "d": 113, "es5-ext/object/set-prototype-of": 153, "es5-ext/string/#/contains": 161, "es6-symbol": 173 }], 167: [function(require2, module3, exports3) {
          var isArguments = require2("es5-ext/function/is-arguments"), callable = require2("es5-ext/object/valid-callable"), isString = require2("es5-ext/string/is-string"), get2 = require2("./get");
          var isArray = Array.isArray, call = Function.prototype.call, some = Array.prototype.some;
          module3.exports = function(iterable, cb) {
            var mode, thisArg = arguments[2], result, doBreak, broken, i2, length, char, code;
            if (isArray(iterable) || isArguments(iterable)) mode = "array";
            else if (isString(iterable)) mode = "string";
            else iterable = get2(iterable);
            callable(cb);
            doBreak = function() {
              broken = true;
            };
            if (mode === "array") {
              some.call(iterable, function(value) {
                call.call(cb, thisArg, value, doBreak);
                return broken;
              });
              return;
            }
            if (mode === "string") {
              length = iterable.length;
              for (i2 = 0; i2 < length; ++i2) {
                char = iterable[i2];
                if (i2 + 1 < length) {
                  code = char.charCodeAt(0);
                  if (code >= 55296 && code <= 56319) char += iterable[++i2];
                }
                call.call(cb, thisArg, char, doBreak);
                if (broken) break;
              }
              return;
            }
            result = iterable.next();
            while (!result.done) {
              call.call(cb, thisArg, result.value, doBreak);
              if (broken) return;
              result = iterable.next();
            }
          };
        }, { "./get": 168, "es5-ext/function/is-arguments": 125, "es5-ext/object/valid-callable": 156, "es5-ext/string/is-string": 164 }], 168: [function(require2, module3, exports3) {
          var isArguments = require2("es5-ext/function/is-arguments"), isString = require2("es5-ext/string/is-string"), ArrayIterator = require2("./array"), StringIterator = require2("./string"), iterable = require2("./valid-iterable"), iteratorSymbol = require2("es6-symbol").iterator;
          module3.exports = function(obj) {
            if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
            if (isArguments(obj)) return new ArrayIterator(obj);
            if (isString(obj)) return new StringIterator(obj);
            return new ArrayIterator(obj);
          };
        }, { "./array": 166, "./string": 171, "./valid-iterable": 172, "es5-ext/function/is-arguments": 125, "es5-ext/string/is-string": 164, "es6-symbol": 173 }], 169: [function(require2, module3, exports3) {
          var clear = require2("es5-ext/array/#/clear"), assign = require2("es5-ext/object/assign"), callable = require2("es5-ext/object/valid-callable"), value = require2("es5-ext/object/valid-value"), d2 = require2("d"), autoBind = require2("d/auto-bind"), Symbol2 = require2("es6-symbol");
          var defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, Iterator;
          module3.exports = Iterator = function(list, context) {
            if (!(this instanceof Iterator)) throw new TypeError("Constructor requires 'new'");
            defineProperties(this, {
              __list__: d2("w", value(list)),
              __context__: d2("w", context),
              __nextIndex__: d2("w", 0)
            });
            if (!context) return;
            callable(context.on);
            context.on("_add", this._onAdd);
            context.on("_delete", this._onDelete);
            context.on("_clear", this._onClear);
          };
          delete Iterator.prototype.constructor;
          defineProperties(
            Iterator.prototype,
            assign(
              {
                _next: d2(function() {
                  var i2;
                  if (!this.__list__) return void 0;
                  if (this.__redo__) {
                    i2 = this.__redo__.shift();
                    if (i2 !== void 0) return i2;
                  }
                  if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
                  this._unBind();
                  return void 0;
                }),
                next: d2(function() {
                  return this._createResult(this._next());
                }),
                _createResult: d2(function(i2) {
                  if (i2 === void 0) return { done: true, value: void 0 };
                  return { done: false, value: this._resolve(i2) };
                }),
                _resolve: d2(function(i2) {
                  return this.__list__[i2];
                }),
                _unBind: d2(function() {
                  this.__list__ = null;
                  delete this.__redo__;
                  if (!this.__context__) return;
                  this.__context__.off("_add", this._onAdd);
                  this.__context__.off("_delete", this._onDelete);
                  this.__context__.off("_clear", this._onClear);
                  this.__context__ = null;
                }),
                toString: d2(function() {
                  return "[object " + (this[Symbol2.toStringTag] || "Object") + "]";
                })
              },
              autoBind({
                _onAdd: d2(function(index) {
                  if (index >= this.__nextIndex__) return;
                  ++this.__nextIndex__;
                  if (!this.__redo__) {
                    defineProperty(this, "__redo__", d2("c", [index]));
                    return;
                  }
                  this.__redo__.forEach(function(redo, i2) {
                    if (redo >= index) this.__redo__[i2] = ++redo;
                  }, this);
                  this.__redo__.push(index);
                }),
                _onDelete: d2(function(index) {
                  var i2;
                  if (index >= this.__nextIndex__) return;
                  --this.__nextIndex__;
                  if (!this.__redo__) return;
                  i2 = this.__redo__.indexOf(index);
                  if (i2 !== -1) this.__redo__.splice(i2, 1);
                  this.__redo__.forEach(function(redo, j2) {
                    if (redo > index) this.__redo__[j2] = --redo;
                  }, this);
                }),
                _onClear: d2(function() {
                  if (this.__redo__) clear.call(this.__redo__);
                  this.__nextIndex__ = 0;
                })
              })
            )
          );
          defineProperty(
            Iterator.prototype,
            Symbol2.iterator,
            d2(function() {
              return this;
            })
          );
        }, { "d": 113, "d/auto-bind": 112, "es5-ext/array/#/clear": 117, "es5-ext/object/assign": 137, "es5-ext/object/valid-callable": 156, "es5-ext/object/valid-value": 157, "es6-symbol": 173 }], 170: [function(require2, module3, exports3) {
          var isArguments = require2("es5-ext/function/is-arguments"), isValue = require2("es5-ext/object/is-value"), isString = require2("es5-ext/string/is-string");
          var iteratorSymbol = require2("es6-symbol").iterator, isArray = Array.isArray;
          module3.exports = function(value) {
            if (!isValue(value)) return false;
            if (isArray(value)) return true;
            if (isString(value)) return true;
            if (isArguments(value)) return true;
            return typeof value[iteratorSymbol] === "function";
          };
        }, { "es5-ext/function/is-arguments": 125, "es5-ext/object/is-value": 145, "es5-ext/string/is-string": 164, "es6-symbol": 173 }], 171: [function(require2, module3, exports3) {
          var setPrototypeOf = require2("es5-ext/object/set-prototype-of"), d2 = require2("d"), Symbol2 = require2("es6-symbol"), Iterator = require2("./");
          var defineProperty = Object.defineProperty, StringIterator;
          StringIterator = module3.exports = function(str) {
            if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
            str = String(str);
            Iterator.call(this, str);
            defineProperty(this, "__length__", d2("", str.length));
          };
          if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);
          delete StringIterator.prototype.constructor;
          StringIterator.prototype = Object.create(Iterator.prototype, {
            _next: d2(function() {
              if (!this.__list__) return void 0;
              if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
              this._unBind();
              return void 0;
            }),
            _resolve: d2(function(i2) {
              var char = this.__list__[i2], code;
              if (this.__nextIndex__ === this.__length__) return char;
              code = char.charCodeAt(0);
              if (code >= 55296 && code <= 56319) return char + this.__list__[this.__nextIndex__++];
              return char;
            })
          });
          defineProperty(StringIterator.prototype, Symbol2.toStringTag, d2("c", "String Iterator"));
        }, { "./": 169, "d": 113, "es5-ext/object/set-prototype-of": 153, "es6-symbol": 173 }], 172: [function(require2, module3, exports3) {
          var isIterable = require2("./is-iterable");
          module3.exports = function(value) {
            if (!isIterable(value)) throw new TypeError(value + " is not iterable");
            return value;
          };
        }, { "./is-iterable": 170 }], 173: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? require2("ext/global-this").Symbol : require2("./polyfill");
        }, { "./is-implemented": 174, "./polyfill": 179, "ext/global-this": 184 }], 174: [function(require2, module3, exports3) {
          var global2 = require2("ext/global-this"), validTypes = { object: true, symbol: true };
          module3.exports = function() {
            var Symbol2 = global2.Symbol;
            var symbol;
            if (typeof Symbol2 !== "function") return false;
            symbol = Symbol2("test symbol");
            try {
              String(symbol);
            } catch (e2) {
              return false;
            }
            if (!validTypes[typeof Symbol2.iterator]) return false;
            if (!validTypes[typeof Symbol2.toPrimitive]) return false;
            if (!validTypes[typeof Symbol2.toStringTag]) return false;
            return true;
          };
        }, { "ext/global-this": 184 }], 175: [function(require2, module3, exports3) {
          module3.exports = function(value) {
            if (!value) return false;
            if (typeof value === "symbol") return true;
            if (!value.constructor) return false;
            if (value.constructor.name !== "Symbol") return false;
            return value[value.constructor.toStringTag] === "Symbol";
          };
        }, {}], 176: [function(require2, module3, exports3) {
          var d2 = require2("d");
          var create = Object.create, defineProperty = Object.defineProperty, objPrototype = Object.prototype;
          var created = create(null);
          module3.exports = function(desc) {
            var postfix = 0, name, ie11BugWorkaround;
            while (created[desc + (postfix || "")]) ++postfix;
            desc += postfix || "";
            created[desc] = true;
            name = "@@" + desc;
            defineProperty(
              objPrototype,
              name,
              d2.gs(null, function(value) {
                if (ie11BugWorkaround) return;
                ie11BugWorkaround = true;
                defineProperty(this, name, d2(value));
                ie11BugWorkaround = false;
              })
            );
            return name;
          };
        }, { "d": 113 }], 177: [function(require2, module3, exports3) {
          var d2 = require2("d"), NativeSymbol = require2("ext/global-this").Symbol;
          module3.exports = function(SymbolPolyfill) {
            return Object.defineProperties(SymbolPolyfill, {
              // To ensure proper interoperability with other native functions (e.g. Array.from)
              // fallback to eventual native implementation of given symbol
              hasInstance: d2(
                "",
                NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
              ),
              isConcatSpreadable: d2(
                "",
                NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
              ),
              iterator: d2("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
              match: d2("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
              replace: d2("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
              search: d2("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
              species: d2("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
              split: d2("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
              toPrimitive: d2(
                "",
                NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
              ),
              toStringTag: d2(
                "",
                NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
              ),
              unscopables: d2(
                "",
                NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
              )
            });
          };
        }, { "d": 113, "ext/global-this": 184 }], 178: [function(require2, module3, exports3) {
          var d2 = require2("d"), validateSymbol = require2("../../../validate-symbol");
          var registry = /* @__PURE__ */ Object.create(null);
          module3.exports = function(SymbolPolyfill) {
            return Object.defineProperties(SymbolPolyfill, {
              for: d2(function(key) {
                if (registry[key]) return registry[key];
                return registry[key] = SymbolPolyfill(String(key));
              }),
              keyFor: d2(function(symbol) {
                var key;
                validateSymbol(symbol);
                for (key in registry) {
                  if (registry[key] === symbol) return key;
                }
                return void 0;
              })
            });
          };
        }, { "../../../validate-symbol": 180, "d": 113 }], 179: [function(require2, module3, exports3) {
          var d2 = require2("d"), validateSymbol = require2("./validate-symbol"), NativeSymbol = require2("ext/global-this").Symbol, generateName = require2("./lib/private/generate-name"), setupStandardSymbols = require2("./lib/private/setup/standard-symbols"), setupSymbolRegistry = require2("./lib/private/setup/symbol-registry");
          var create = Object.create, defineProperties = Object.defineProperties, defineProperty = Object.defineProperty;
          var SymbolPolyfill, HiddenSymbol, isNativeSafe;
          if (typeof NativeSymbol === "function") {
            try {
              String(NativeSymbol());
              isNativeSafe = true;
            } catch (ignore) {
            }
          } else {
            NativeSymbol = null;
          }
          HiddenSymbol = function Symbol2(description) {
            if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
            return SymbolPolyfill(description);
          };
          module3.exports = SymbolPolyfill = function Symbol2(description) {
            var symbol;
            if (this instanceof Symbol2) throw new TypeError("Symbol is not a constructor");
            if (isNativeSafe) return NativeSymbol(description);
            symbol = create(HiddenSymbol.prototype);
            description = description === void 0 ? "" : String(description);
            return defineProperties(symbol, {
              __description__: d2("", description),
              __name__: d2("", generateName(description))
            });
          };
          setupStandardSymbols(SymbolPolyfill);
          setupSymbolRegistry(SymbolPolyfill);
          defineProperties(HiddenSymbol.prototype, {
            constructor: d2(SymbolPolyfill),
            toString: d2("", function() {
              return this.__name__;
            })
          });
          defineProperties(SymbolPolyfill.prototype, {
            toString: d2(function() {
              return "Symbol (" + validateSymbol(this).__description__ + ")";
            }),
            valueOf: d2(function() {
              return validateSymbol(this);
            })
          });
          defineProperty(
            SymbolPolyfill.prototype,
            SymbolPolyfill.toPrimitive,
            d2("", function() {
              var symbol = validateSymbol(this);
              if (typeof symbol === "symbol") return symbol;
              return symbol.toString();
            })
          );
          defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d2("c", "Symbol"));
          defineProperty(
            HiddenSymbol.prototype,
            SymbolPolyfill.toStringTag,
            d2("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
          );
          defineProperty(
            HiddenSymbol.prototype,
            SymbolPolyfill.toPrimitive,
            d2("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
          );
        }, { "./lib/private/generate-name": 176, "./lib/private/setup/standard-symbols": 177, "./lib/private/setup/symbol-registry": 178, "./validate-symbol": 180, "d": 113, "ext/global-this": 184 }], 180: [function(require2, module3, exports3) {
          var isSymbol = require2("./is-symbol");
          module3.exports = function(value) {
            if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
            return value;
          };
        }, { "./is-symbol": 175 }], 181: [function(require2, module3, exports3) {
          var d2 = require2("d"), callable = require2("es5-ext/object/valid-callable"), apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperty = Object.defineProperty, defineProperties = Object.defineProperties, hasOwnProperty2 = Object.prototype.hasOwnProperty, descriptor = { configurable: true, enumerable: false, writable: true }, on2, once, off, emit2, methods, descriptors, base;
          on2 = function(type, listener) {
            var data;
            callable(listener);
            if (!hasOwnProperty2.call(this, "__ee__")) {
              data = descriptor.value = create(null);
              defineProperty(this, "__ee__", descriptor);
              descriptor.value = null;
            } else {
              data = this.__ee__;
            }
            if (!data[type]) data[type] = listener;
            else if (typeof data[type] === "object") data[type].push(listener);
            else data[type] = [data[type], listener];
            return this;
          };
          once = function(type, listener) {
            var once2, self2;
            callable(listener);
            self2 = this;
            on2.call(this, type, once2 = function() {
              off.call(self2, type, once2);
              apply.call(listener, this, arguments);
            });
            once2.__eeOnceListener__ = listener;
            return this;
          };
          off = function(type, listener) {
            var data, listeners, candidate, i2;
            callable(listener);
            if (!hasOwnProperty2.call(this, "__ee__")) return this;
            data = this.__ee__;
            if (!data[type]) return this;
            listeners = data[type];
            if (typeof listeners === "object") {
              for (i2 = 0; candidate = listeners[i2]; ++i2) {
                if (candidate === listener || candidate.__eeOnceListener__ === listener) {
                  if (listeners.length === 2) data[type] = listeners[i2 ? 0 : 1];
                  else listeners.splice(i2, 1);
                }
              }
            } else {
              if (listeners === listener || listeners.__eeOnceListener__ === listener) {
                delete data[type];
              }
            }
            return this;
          };
          emit2 = function(type) {
            var i2, l2, listener, listeners, args;
            if (!hasOwnProperty2.call(this, "__ee__")) return;
            listeners = this.__ee__[type];
            if (!listeners) return;
            if (typeof listeners === "object") {
              l2 = arguments.length;
              args = new Array(l2 - 1);
              for (i2 = 1; i2 < l2; ++i2) args[i2 - 1] = arguments[i2];
              listeners = listeners.slice();
              for (i2 = 0; listener = listeners[i2]; ++i2) {
                apply.call(listener, this, args);
              }
            } else {
              switch (arguments.length) {
                case 1:
                  call.call(listeners, this);
                  break;
                case 2:
                  call.call(listeners, this, arguments[1]);
                  break;
                case 3:
                  call.call(listeners, this, arguments[1], arguments[2]);
                  break;
                default:
                  l2 = arguments.length;
                  args = new Array(l2 - 1);
                  for (i2 = 1; i2 < l2; ++i2) {
                    args[i2 - 1] = arguments[i2];
                  }
                  apply.call(listeners, this, args);
              }
            }
          };
          methods = {
            on: on2,
            once,
            off,
            emit: emit2
          };
          descriptors = {
            on: d2(on2),
            once: d2(once),
            off: d2(off),
            emit: d2(emit2)
          };
          base = defineProperties({}, descriptors);
          module3.exports = exports3 = function(o2) {
            return o2 == null ? create(base) : defineProperties(Object(o2), descriptors);
          };
          exports3.methods = methods;
        }, { "d": 113, "es5-ext/object/valid-callable": 156 }], 182: [function(require2, module3, exports3) {
          var R2 = typeof Reflect === "object" ? Reflect : null;
          var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
            return Function.prototype.apply.call(target, receiver, args);
          };
          var ReflectOwnKeys;
          if (R2 && typeof R2.ownKeys === "function") {
            ReflectOwnKeys = R2.ownKeys;
          } else if (Object.getOwnPropertySymbols) {
            ReflectOwnKeys = function ReflectOwnKeys2(target) {
              return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
            };
          } else {
            ReflectOwnKeys = function ReflectOwnKeys2(target) {
              return Object.getOwnPropertyNames(target);
            };
          }
          function ProcessEmitWarning(warning) {
            if (console && console.warn) console.warn(warning);
          }
          var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
            return value !== value;
          };
          function EventEmitter() {
            EventEmitter.init.call(this);
          }
          module3.exports = EventEmitter;
          module3.exports.once = once;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = void 0;
          EventEmitter.prototype._eventsCount = 0;
          EventEmitter.prototype._maxListeners = void 0;
          var defaultMaxListeners = 10;
          function checkListener(listener) {
            if (typeof listener !== "function") {
              throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
            }
          }
          Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: true,
            get: function() {
              return defaultMaxListeners;
            },
            set: function(arg) {
              if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
              }
              defaultMaxListeners = arg;
            }
          });
          EventEmitter.init = function() {
            if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || void 0;
          };
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
            if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
              throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
            }
            this._maxListeners = n2;
            return this;
          };
          function _getMaxListeners(that) {
            if (that._maxListeners === void 0)
              return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
          }
          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return _getMaxListeners(this);
          };
          EventEmitter.prototype.emit = function emit2(type) {
            var args = [];
            for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
            var doError = type === "error";
            var events = this._events;
            if (events !== void 0)
              doError = doError && events.error === void 0;
            else if (!doError)
              return false;
            if (doError) {
              var er;
              if (args.length > 0)
                er = args[0];
              if (er instanceof Error) {
                throw er;
              }
              var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
              err.context = er;
              throw err;
            }
            var handler = events[type];
            if (handler === void 0)
              return false;
            if (typeof handler === "function") {
              ReflectApply(handler, this, args);
            } else {
              var len = handler.length;
              var listeners = arrayClone(handler, len);
              for (var i2 = 0; i2 < len; ++i2)
                ReflectApply(listeners[i2], this, args);
            }
            return true;
          };
          function _addListener(target, type, listener, prepend) {
            var m2;
            var events;
            var existing;
            checkListener(listener);
            events = target._events;
            if (events === void 0) {
              events = target._events = /* @__PURE__ */ Object.create(null);
              target._eventsCount = 0;
            } else {
              if (events.newListener !== void 0) {
                target.emit(
                  "newListener",
                  type,
                  listener.listener ? listener.listener : listener
                );
                events = target._events;
              }
              existing = events[type];
            }
            if (existing === void 0) {
              existing = events[type] = listener;
              ++target._eventsCount;
            } else {
              if (typeof existing === "function") {
                existing = events[type] = prepend ? [listener, existing] : [existing, listener];
              } else if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
              m2 = _getMaxListeners(target);
              if (m2 > 0 && existing.length > m2 && !existing.warned) {
                existing.warned = true;
                var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                w2.name = "MaxListenersExceededWarning";
                w2.emitter = target;
                w2.type = type;
                w2.count = existing.length;
                ProcessEmitWarning(w2);
              }
            }
            return target;
          }
          EventEmitter.prototype.addListener = function addListener(type, listener) {
            return _addListener(this, type, listener, false);
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.prependListener = function prependListener(type, listener) {
            return _addListener(this, type, listener, true);
          };
          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn);
              this.fired = true;
              if (arguments.length === 0)
                return this.listener.call(this.target);
              return this.listener.apply(this.target, arguments);
            }
          }
          function _onceWrap(target, type, listener) {
            var state = { fired: false, wrapFn: void 0, target, type, listener };
            var wrapped = onceWrapper.bind(state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
          }
          EventEmitter.prototype.once = function once2(type, listener) {
            checkListener(listener);
            this.on(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
            checkListener(listener);
            this.prependListener(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.removeListener = function removeListener(type, listener) {
            var list, events, position, i2, originalListener;
            checkListener(listener);
            events = this._events;
            if (events === void 0)
              return this;
            list = events[type];
            if (list === void 0)
              return this;
            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0)
                this._events = /* @__PURE__ */ Object.create(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit("removeListener", type, list.listener || listener);
              }
            } else if (typeof list !== "function") {
              position = -1;
              for (i2 = list.length - 1; i2 >= 0; i2--) {
                if (list[i2] === listener || list[i2].listener === listener) {
                  originalListener = list[i2].listener;
                  position = i2;
                  break;
                }
              }
              if (position < 0)
                return this;
              if (position === 0)
                list.shift();
              else {
                spliceOne(list, position);
              }
              if (list.length === 1)
                events[type] = list[0];
              if (events.removeListener !== void 0)
                this.emit("removeListener", type, originalListener || listener);
            }
            return this;
          };
          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
          EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
            var listeners, events, i2;
            events = this._events;
            if (events === void 0)
              return this;
            if (events.removeListener === void 0) {
              if (arguments.length === 0) {
                this._events = /* @__PURE__ */ Object.create(null);
                this._eventsCount = 0;
              } else if (events[type] !== void 0) {
                if (--this._eventsCount === 0)
                  this._events = /* @__PURE__ */ Object.create(null);
                else
                  delete events[type];
              }
              return this;
            }
            if (arguments.length === 0) {
              var keys = Object.keys(events);
              var key;
              for (i2 = 0; i2 < keys.length; ++i2) {
                key = keys[i2];
                if (key === "removeListener") continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = /* @__PURE__ */ Object.create(null);
              this._eventsCount = 0;
              return this;
            }
            listeners = events[type];
            if (typeof listeners === "function") {
              this.removeListener(type, listeners);
            } else if (listeners !== void 0) {
              for (i2 = listeners.length - 1; i2 >= 0; i2--) {
                this.removeListener(type, listeners[i2]);
              }
            }
            return this;
          };
          function _listeners(target, type, unwrap) {
            var events = target._events;
            if (events === void 0)
              return [];
            var evlistener = events[type];
            if (evlistener === void 0)
              return [];
            if (typeof evlistener === "function")
              return unwrap ? [evlistener.listener || evlistener] : [evlistener];
            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
          }
          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
          };
          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
          };
          EventEmitter.listenerCount = function(emitter, type) {
            if (typeof emitter.listenerCount === "function") {
              return emitter.listenerCount(type);
            } else {
              return listenerCount.call(emitter, type);
            }
          };
          EventEmitter.prototype.listenerCount = listenerCount;
          function listenerCount(type) {
            var events = this._events;
            if (events !== void 0) {
              var evlistener = events[type];
              if (typeof evlistener === "function") {
                return 1;
              } else if (evlistener !== void 0) {
                return evlistener.length;
              }
            }
            return 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
          };
          function arrayClone(arr, n2) {
            var copy = new Array(n2);
            for (var i2 = 0; i2 < n2; ++i2)
              copy[i2] = arr[i2];
            return copy;
          }
          function spliceOne(list, index) {
            for (; index + 1 < list.length; index++)
              list[index] = list[index + 1];
            list.pop();
          }
          function unwrapListeners(arr) {
            var ret = new Array(arr.length);
            for (var i2 = 0; i2 < ret.length; ++i2) {
              ret[i2] = arr[i2].listener || arr[i2];
            }
            return ret;
          }
          function once(emitter, name) {
            return new Promise(function(resolve, reject) {
              function eventListener() {
                if (errorListener !== void 0) {
                  emitter.removeListener("error", errorListener);
                }
                resolve([].slice.call(arguments));
              }
              var errorListener;
              if (name !== "error") {
                errorListener = function errorListener2(err) {
                  emitter.removeListener(name, eventListener);
                  reject(err);
                };
                emitter.once("error", errorListener);
              }
              emitter.once(name, eventListener);
            });
          }
        }, {}], 183: [function(require2, module3, exports3) {
          var naiveFallback = function() {
            if (typeof self === "object" && self) return self;
            if (typeof window === "object" && window) return window;
            throw new Error("Unable to resolve global `this`");
          };
          module3.exports = function() {
            if (this) return this;
            try {
              Object.defineProperty(Object.prototype, "__global__", {
                get: function() {
                  return this;
                },
                configurable: true
              });
            } catch (error) {
              return naiveFallback();
            }
            try {
              if (!__global__) return naiveFallback();
              return __global__;
            } finally {
              delete Object.prototype.__global__;
            }
          }();
        }, {}], 184: [function(require2, module3, exports3) {
          module3.exports = require2("./is-implemented")() ? globalThis : require2("./implementation");
        }, { "./implementation": 183, "./is-implemented": 185 }], 185: [function(require2, module3, exports3) {
          module3.exports = function() {
            if (typeof globalThis !== "object") return false;
            if (!globalThis) return false;
            return globalThis.Array === Array;
          };
        }, {}], 186: [function(require2, module3, exports3) {
          var hasOwn = Object.prototype.hasOwnProperty;
          var toString2 = Object.prototype.toString;
          module3.exports = function forEach(obj, fn, ctx2) {
            if (toString2.call(fn) !== "[object Function]") {
              throw new TypeError("iterator must be a function");
            }
            var l2 = obj.length;
            if (l2 === +l2) {
              for (var i2 = 0; i2 < l2; i2++) {
                fn.call(ctx2, obj[i2], i2, obj);
              }
            } else {
              for (var k2 in obj) {
                if (hasOwn.call(obj, k2)) {
                  fn.call(ctx2, obj[k2], k2, obj);
                }
              }
            }
          };
        }, {}], 187: [function(require2, module3, exports3) {
          var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
          var slice = Array.prototype.slice;
          var toStr = Object.prototype.toString;
          var funcType = "[object Function]";
          module3.exports = function bind(that) {
            var target = this;
            if (typeof target !== "function" || toStr.call(target) !== funcType) {
              throw new TypeError(ERROR_MESSAGE + target);
            }
            var args = slice.call(arguments, 1);
            var bound;
            var binder = function() {
              if (this instanceof bound) {
                var result = target.apply(
                  this,
                  args.concat(slice.call(arguments))
                );
                if (Object(result) === result) {
                  return result;
                }
                return this;
              } else {
                return target.apply(
                  that,
                  args.concat(slice.call(arguments))
                );
              }
            };
            var boundLength = Math.max(0, target.length - args.length);
            var boundArgs = [];
            for (var i2 = 0; i2 < boundLength; i2++) {
              boundArgs.push("$" + i2);
            }
            bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
            if (target.prototype) {
              var Empty = function Empty2() {
              };
              Empty.prototype = target.prototype;
              bound.prototype = new Empty();
              Empty.prototype = null;
            }
            return bound;
          };
        }, {}], 188: [function(require2, module3, exports3) {
          var implementation = require2("./implementation");
          module3.exports = Function.prototype.bind || implementation;
        }, { "./implementation": 187 }], 189: [function(require2, module3, exports3) {
          var undefined2;
          var $SyntaxError = SyntaxError;
          var $Function = Function;
          var $TypeError = TypeError;
          var getEvalledConstructor = function(expressionSyntax) {
            try {
              return Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
            } catch (e2) {
            }
          };
          var $gOPD = Object.getOwnPropertyDescriptor;
          if ($gOPD) {
            try {
              $gOPD({}, "");
            } catch (e2) {
              $gOPD = null;
            }
          }
          var throwTypeError = function() {
            throw new $TypeError();
          };
          var ThrowTypeError = $gOPD ? function() {
            try {
              arguments.callee;
              return throwTypeError;
            } catch (calleeThrows) {
              try {
                return $gOPD(arguments, "callee").get;
              } catch (gOPDthrows) {
                return throwTypeError;
              }
            }
          }() : throwTypeError;
          var hasSymbols = require2("has-symbols")();
          var getProto = Object.getPrototypeOf || function(x2) {
            return x2.__proto__;
          };
          var asyncGenFunction = getEvalledConstructor("async function* () {}");
          var asyncGenFunctionPrototype = asyncGenFunction ? asyncGenFunction.prototype : undefined2;
          var asyncGenPrototype = asyncGenFunctionPrototype ? asyncGenFunctionPrototype.prototype : undefined2;
          var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
          var INTRINSICS = {
            "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
            "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
            "%AsyncFromSyncIteratorPrototype%": undefined2,
            "%AsyncFunction%": getEvalledConstructor("async function () {}"),
            "%AsyncGenerator%": asyncGenFunctionPrototype,
            "%AsyncGeneratorFunction%": asyncGenFunction,
            "%AsyncIteratorPrototype%": asyncGenPrototype ? getProto(asyncGenPrototype) : undefined2,
            "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
            "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": Error,
            "%eval%": eval,
            // eslint-disable-line no-eval
            "%EvalError%": EvalError,
            "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
            "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
            "%Function%": $Function,
            "%GeneratorFunction%": getEvalledConstructor("function* () {}"),
            "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
            "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
            "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
            "%JSON%": typeof JSON === "object" ? JSON : undefined2,
            "%Map%": typeof Map === "undefined" ? undefined2 : Map,
            "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": Object,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
            "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
            "%RangeError%": RangeError,
            "%ReferenceError%": ReferenceError,
            "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set === "undefined" ? undefined2 : Set,
            "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
            "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
            "%Symbol%": hasSymbols ? Symbol : undefined2,
            "%SyntaxError%": $SyntaxError,
            "%ThrowTypeError%": ThrowTypeError,
            "%TypedArray%": TypedArray,
            "%TypeError%": $TypeError,
            "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
            "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
            "%URIError%": URIError,
            "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
            "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
            "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
          };
          var LEGACY_ALIASES = {
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
          };
          var bind = require2("function-bind");
          var hasOwn = require2("has");
          var $concat = bind.call(Function.call, Array.prototype.concat);
          var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
          var $replace = bind.call(Function.call, String.prototype.replace);
          var $strSlice = bind.call(Function.call, String.prototype.slice);
          var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
          var reEscapeChar = /\\(\\)?/g;
          var stringToPath = function stringToPath2(string) {
            var first = $strSlice(string, 0, 1);
            var last = $strSlice(string, -1);
            if (first === "%" && last !== "%") {
              throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
            } else if (last === "%" && first !== "%") {
              throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
            }
            var result = [];
            $replace(string, rePropName, function(match, number, quote, subString) {
              result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
            });
            return result;
          };
          var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
            var intrinsicName = name;
            var alias;
            if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
              alias = LEGACY_ALIASES[intrinsicName];
              intrinsicName = "%" + alias[0] + "%";
            }
            if (hasOwn(INTRINSICS, intrinsicName)) {
              var value = INTRINSICS[intrinsicName];
              if (typeof value === "undefined" && !allowMissing) {
                throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
              }
              return {
                alias,
                name: intrinsicName,
                value
              };
            }
            throw new $SyntaxError("intrinsic " + name + " does not exist!");
          };
          module3.exports = function GetIntrinsic(name, allowMissing) {
            if (typeof name !== "string" || name.length === 0) {
              throw new $TypeError("intrinsic name must be a non-empty string");
            }
            if (arguments.length > 1 && typeof allowMissing !== "boolean") {
              throw new $TypeError('"allowMissing" argument must be a boolean');
            }
            var parts = stringToPath(name);
            var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
            var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
            var intrinsicRealName = intrinsic.name;
            var value = intrinsic.value;
            var skipFurtherCaching = false;
            var alias = intrinsic.alias;
            if (alias) {
              intrinsicBaseName = alias[0];
              $spliceApply(parts, $concat([0, 1], alias));
            }
            for (var i2 = 1, isOwn = true; i2 < parts.length; i2 += 1) {
              var part = parts[i2];
              var first = $strSlice(part, 0, 1);
              var last = $strSlice(part, -1);
              if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
                throw new $SyntaxError("property names with quotes must have matching quotes");
              }
              if (part === "constructor" || !isOwn) {
                skipFurtherCaching = true;
              }
              intrinsicBaseName += "." + part;
              intrinsicRealName = "%" + intrinsicBaseName + "%";
              if (hasOwn(INTRINSICS, intrinsicRealName)) {
                value = INTRINSICS[intrinsicRealName];
              } else if (value != null) {
                if (!(part in value)) {
                  if (!allowMissing) {
                    throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
                  }
                  return void 0;
                }
                if ($gOPD && i2 + 1 >= parts.length) {
                  var desc = $gOPD(value, part);
                  isOwn = !!desc;
                  if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                    value = desc.get;
                  } else {
                    value = value[part];
                  }
                } else {
                  isOwn = hasOwn(value, part);
                  value = value[part];
                }
                if (isOwn && !skipFurtherCaching) {
                  INTRINSICS[intrinsicRealName] = value;
                }
              }
            }
            return value;
          };
        }, { "function-bind": 188, "has": 192, "has-symbols": 190 }], 190: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var origSymbol = global2.Symbol;
              var hasSymbolSham = require2("./shams");
              module3.exports = function hasNativeSymbols() {
                if (typeof origSymbol !== "function") {
                  return false;
                }
                if (typeof Symbol !== "function") {
                  return false;
                }
                if (typeof origSymbol("foo") !== "symbol") {
                  return false;
                }
                if (typeof Symbol("bar") !== "symbol") {
                  return false;
                }
                return hasSymbolSham();
              };
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./shams": 191 }], 191: [function(require2, module3, exports3) {
          module3.exports = function hasSymbols() {
            if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
              return false;
            }
            if (typeof Symbol.iterator === "symbol") {
              return true;
            }
            var obj = {};
            var sym = Symbol("test");
            var symObj = Object(sym);
            if (typeof sym === "string") {
              return false;
            }
            if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
              return false;
            }
            if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
              return false;
            }
            var symVal = 42;
            obj[sym] = symVal;
            for (sym in obj) {
              return false;
            }
            if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
              return false;
            }
            if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
              return false;
            }
            var syms = Object.getOwnPropertySymbols(obj);
            if (syms.length !== 1 || syms[0] !== sym) {
              return false;
            }
            if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
              return false;
            }
            if (typeof Object.getOwnPropertyDescriptor === "function") {
              var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
              if (descriptor.value !== symVal || descriptor.enumerable !== true) {
                return false;
              }
            }
            return true;
          };
        }, {}], 192: [function(require2, module3, exports3) {
          var bind = require2("function-bind");
          module3.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
        }, { "function-bind": 188 }], 193: [function(require2, module3, exports3) {
          var http = require2("http");
          var url = require2("url");
          var https = module3.exports;
          for (var key in http) {
            if (http.hasOwnProperty(key)) https[key] = http[key];
          }
          https.request = function(params, cb) {
            params = validateParams(params);
            return http.request.call(this, params, cb);
          };
          https.get = function(params, cb) {
            params = validateParams(params);
            return http.get.call(this, params, cb);
          };
          function validateParams(params) {
            if (typeof params === "string") {
              params = url.parse(params);
            }
            if (!params.protocol) {
              params.protocol = "https:";
            }
            if (params.protocol !== "https:") {
              throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
            }
            return params;
          }
        }, { "http": 268, "url": 303 }], 194: [function(require2, module3, exports3) {
          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
          exports3.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e2, m2;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i2 = isLE ? nBytes - 1 : 0;
            var d2 = isLE ? -1 : 1;
            var s2 = buffer[offset + i2];
            i2 += d2;
            e2 = s2 & (1 << -nBits) - 1;
            s2 >>= -nBits;
            nBits += eLen;
            for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
            }
            m2 = e2 & (1 << -nBits) - 1;
            e2 >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m2 = m2 * 256 + buffer[offset + i2], i2 += d2, nBits -= 8) {
            }
            if (e2 === 0) {
              e2 = 1 - eBias;
            } else if (e2 === eMax) {
              return m2 ? NaN : (s2 ? -1 : 1) * Infinity;
            } else {
              m2 = m2 + Math.pow(2, mLen);
              e2 = e2 - eBias;
            }
            return (s2 ? -1 : 1) * m2 * Math.pow(2, e2 - mLen);
          };
          exports3.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e2, m2, c2;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i2 = isLE ? 0 : nBytes - 1;
            var d2 = isLE ? 1 : -1;
            var s2 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m2 = isNaN(value) ? 1 : 0;
              e2 = eMax;
            } else {
              e2 = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c2 = Math.pow(2, -e2)) < 1) {
                e2--;
                c2 *= 2;
              }
              if (e2 + eBias >= 1) {
                value += rt / c2;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c2 >= 2) {
                e2++;
                c2 /= 2;
              }
              if (e2 + eBias >= eMax) {
                m2 = 0;
                e2 = eMax;
              } else if (e2 + eBias >= 1) {
                m2 = (value * c2 - 1) * Math.pow(2, mLen);
                e2 = e2 + eBias;
              } else {
                m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e2 = 0;
              }
            }
            for (; mLen >= 8; buffer[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
            }
            e2 = e2 << mLen | m2;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i2] = e2 & 255, i2 += d2, e2 /= 256, eLen -= 8) {
            }
            buffer[offset + i2 - d2] |= s2 * 128;
          };
        }, {}], 195: [function(require2, module3, exports3) {
          if (typeof Object.create === "function") {
            module3.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor;
                ctor.prototype = Object.create(superCtor.prototype, {
                  constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                  }
                });
              }
            };
          } else {
            module3.exports = function inherits(ctor, superCtor) {
              if (superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {
                };
                TempCtor.prototype = superCtor.prototype;
                ctor.prototype = new TempCtor();
                ctor.prototype.constructor = ctor;
              }
            };
          }
        }, {}], 196: [function(require2, module3, exports3) {
          var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
          var callBound = require2("call-bind/callBound");
          var $toString = callBound("Object.prototype.toString");
          var isStandardArguments = function isArguments(value) {
            if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
              return false;
            }
            return $toString(value) === "[object Arguments]";
          };
          var isLegacyArguments = function isArguments(value) {
            if (isStandardArguments(value)) {
              return true;
            }
            return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
          };
          var supportsStandardArguments = function() {
            return isStandardArguments(arguments);
          }();
          isStandardArguments.isLegacyArguments = isLegacyArguments;
          module3.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
        }, { "call-bind/callBound": 36 }], 197: [function(require2, module3, exports3) {
          /*!
           * Determine if an object is a Buffer
           *
           * @author   Feross Aboukhadijeh <https://feross.org>
           * @license  MIT
           */
          module3.exports = function(obj) {
            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
          };
          function isBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
          }
          function isSlowBuffer(obj) {
            return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
          }
        }, {}], 198: [function(require2, module3, exports3) {
          var toStr = Object.prototype.toString;
          var fnToStr = Function.prototype.toString;
          var isFnRegex = /^\s*(?:function)?\*/;
          var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
          var getProto = Object.getPrototypeOf;
          var getGeneratorFunc = function() {
            if (!hasToStringTag) {
              return false;
            }
            try {
              return Function("return function*() {}")();
            } catch (e2) {
            }
          };
          var generatorFunc = getGeneratorFunc();
          var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;
          module3.exports = function isGeneratorFunction(fn) {
            if (typeof fn !== "function") {
              return false;
            }
            if (isFnRegex.test(fnToStr.call(fn))) {
              return true;
            }
            if (!hasToStringTag) {
              var str = toStr.call(fn);
              return str === "[object GeneratorFunction]";
            }
            return getProto && getProto(fn) === GeneratorFunction;
          };
        }, {}], 199: [function(require2, module3, exports3) {
          module3.exports = isPromise;
          module3.exports.default = isPromise;
          function isPromise(obj) {
            return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
          }
        }, {}], 200: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var forEach = require2("foreach");
              var availableTypedArrays = require2("available-typed-arrays");
              var callBound = require2("call-bind/callBound");
              var $toString = callBound("Object.prototype.toString");
              var hasSymbols = require2("has-symbols")();
              var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
              var typedArrays = availableTypedArrays();
              var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
                for (var i2 = 0; i2 < array.length; i2 += 1) {
                  if (array[i2] === value) {
                    return i2;
                  }
                }
                return -1;
              };
              var $slice = callBound("String.prototype.slice");
              var toStrTags = {};
              var gOPD = require2("es-abstract/helpers/getOwnPropertyDescriptor");
              var getPrototypeOf = Object.getPrototypeOf;
              if (hasToStringTag && gOPD && getPrototypeOf) {
                forEach(typedArrays, function(typedArray) {
                  var arr = new global2[typedArray]();
                  if (!(Symbol.toStringTag in arr)) {
                    throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
                  }
                  var proto = getPrototypeOf(arr);
                  var descriptor = gOPD(proto, Symbol.toStringTag);
                  if (!descriptor) {
                    var superProto = getPrototypeOf(proto);
                    descriptor = gOPD(superProto, Symbol.toStringTag);
                  }
                  toStrTags[typedArray] = descriptor.get;
                });
              }
              var tryTypedArrays = function tryAllTypedArrays(value) {
                var anyTrue = false;
                forEach(toStrTags, function(getter, typedArray) {
                  if (!anyTrue) {
                    try {
                      anyTrue = getter.call(value) === typedArray;
                    } catch (e2) {
                    }
                  }
                });
                return anyTrue;
              };
              module3.exports = function isTypedArray(value) {
                if (!value || typeof value !== "object") {
                  return false;
                }
                if (!hasToStringTag) {
                  var tag = $slice($toString(value), 8, -1);
                  return $indexOf(typedArrays, tag) > -1;
                }
                if (!gOPD) {
                  return false;
                }
                return tryTypedArrays(value);
              };
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "available-typed-arrays": 30, "call-bind/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 116, "foreach": 186, "has-symbols": 190 }], 201: [function(require2, module3, exports3) {
          var loader = require2("./lib/loader");
          var dumper = require2("./lib/dumper");
          function renamed(from, to) {
            return function() {
              throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
            };
          }
          module3.exports.Type = require2("./lib/type");
          module3.exports.Schema = require2("./lib/schema");
          module3.exports.FAILSAFE_SCHEMA = require2("./lib/schema/failsafe");
          module3.exports.JSON_SCHEMA = require2("./lib/schema/json");
          module3.exports.CORE_SCHEMA = require2("./lib/schema/core");
          module3.exports.DEFAULT_SCHEMA = require2("./lib/schema/default");
          module3.exports.load = loader.load;
          module3.exports.loadAll = loader.loadAll;
          module3.exports.dump = dumper.dump;
          module3.exports.YAMLException = require2("./lib/exception");
          module3.exports.types = {
            binary: require2("./lib/type/binary"),
            float: require2("./lib/type/float"),
            map: require2("./lib/type/map"),
            null: require2("./lib/type/null"),
            pairs: require2("./lib/type/pairs"),
            set: require2("./lib/type/set"),
            timestamp: require2("./lib/type/timestamp"),
            bool: require2("./lib/type/bool"),
            int: require2("./lib/type/int"),
            merge: require2("./lib/type/merge"),
            omap: require2("./lib/type/omap"),
            seq: require2("./lib/type/seq"),
            str: require2("./lib/type/str")
          };
          module3.exports.safeLoad = renamed("safeLoad", "load");
          module3.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
          module3.exports.safeDump = renamed("safeDump", "dump");
        }, { "./lib/dumper": 203, "./lib/exception": 204, "./lib/loader": 205, "./lib/schema": 206, "./lib/schema/core": 207, "./lib/schema/default": 208, "./lib/schema/failsafe": 209, "./lib/schema/json": 210, "./lib/type": 212, "./lib/type/binary": 213, "./lib/type/bool": 214, "./lib/type/float": 215, "./lib/type/int": 216, "./lib/type/map": 217, "./lib/type/merge": 218, "./lib/type/null": 219, "./lib/type/omap": 220, "./lib/type/pairs": 221, "./lib/type/seq": 222, "./lib/type/set": 223, "./lib/type/str": 224, "./lib/type/timestamp": 225 }], 202: [function(require2, module3, exports3) {
          function isNothing(subject) {
            return typeof subject === "undefined" || subject === null;
          }
          function isObject2(subject) {
            return typeof subject === "object" && subject !== null;
          }
          function toArray(sequence) {
            if (Array.isArray(sequence)) return sequence;
            else if (isNothing(sequence)) return [];
            return [sequence];
          }
          function extend(target, source) {
            var index, length, key, sourceKeys;
            if (source) {
              sourceKeys = Object.keys(source);
              for (index = 0, length = sourceKeys.length; index < length; index += 1) {
                key = sourceKeys[index];
                target[key] = source[key];
              }
            }
            return target;
          }
          function repeat(string, count) {
            var result = "", cycle;
            for (cycle = 0; cycle < count; cycle += 1) {
              result += string;
            }
            return result;
          }
          function isNegativeZero(number) {
            return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
          }
          module3.exports.isNothing = isNothing;
          module3.exports.isObject = isObject2;
          module3.exports.toArray = toArray;
          module3.exports.repeat = repeat;
          module3.exports.isNegativeZero = isNegativeZero;
          module3.exports.extend = extend;
        }, {}], 203: [function(require2, module3, exports3) {
          var common = require2("./common");
          var YAMLException = require2("./exception");
          var DEFAULT_SCHEMA = require2("./schema/default");
          var _toString = Object.prototype.toString;
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CHAR_BOM = 65279;
          var CHAR_TAB = 9;
          var CHAR_LINE_FEED = 10;
          var CHAR_CARRIAGE_RETURN = 13;
          var CHAR_SPACE = 32;
          var CHAR_EXCLAMATION = 33;
          var CHAR_DOUBLE_QUOTE = 34;
          var CHAR_SHARP = 35;
          var CHAR_PERCENT = 37;
          var CHAR_AMPERSAND = 38;
          var CHAR_SINGLE_QUOTE = 39;
          var CHAR_ASTERISK = 42;
          var CHAR_COMMA = 44;
          var CHAR_MINUS = 45;
          var CHAR_COLON = 58;
          var CHAR_EQUALS = 61;
          var CHAR_GREATER_THAN = 62;
          var CHAR_QUESTION = 63;
          var CHAR_COMMERCIAL_AT = 64;
          var CHAR_LEFT_SQUARE_BRACKET = 91;
          var CHAR_RIGHT_SQUARE_BRACKET = 93;
          var CHAR_GRAVE_ACCENT = 96;
          var CHAR_LEFT_CURLY_BRACKET = 123;
          var CHAR_VERTICAL_LINE = 124;
          var CHAR_RIGHT_CURLY_BRACKET = 125;
          var ESCAPE_SEQUENCES = {};
          ESCAPE_SEQUENCES[0] = "\\0";
          ESCAPE_SEQUENCES[7] = "\\a";
          ESCAPE_SEQUENCES[8] = "\\b";
          ESCAPE_SEQUENCES[9] = "\\t";
          ESCAPE_SEQUENCES[10] = "\\n";
          ESCAPE_SEQUENCES[11] = "\\v";
          ESCAPE_SEQUENCES[12] = "\\f";
          ESCAPE_SEQUENCES[13] = "\\r";
          ESCAPE_SEQUENCES[27] = "\\e";
          ESCAPE_SEQUENCES[34] = '\\"';
          ESCAPE_SEQUENCES[92] = "\\\\";
          ESCAPE_SEQUENCES[133] = "\\N";
          ESCAPE_SEQUENCES[160] = "\\_";
          ESCAPE_SEQUENCES[8232] = "\\L";
          ESCAPE_SEQUENCES[8233] = "\\P";
          var DEPRECATED_BOOLEANS_SYNTAX = [
            "y",
            "Y",
            "yes",
            "Yes",
            "YES",
            "on",
            "On",
            "ON",
            "n",
            "N",
            "no",
            "No",
            "NO",
            "off",
            "Off",
            "OFF"
          ];
          var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
          function compileStyleMap(schema, map) {
            var result, keys, index, length, tag, style, type;
            if (map === null) return {};
            result = {};
            keys = Object.keys(map);
            for (index = 0, length = keys.length; index < length; index += 1) {
              tag = keys[index];
              style = String(map[tag]);
              if (tag.slice(0, 2) === "!!") {
                tag = "tag:yaml.org,2002:" + tag.slice(2);
              }
              type = schema.compiledTypeMap["fallback"][tag];
              if (type && _hasOwnProperty.call(type.styleAliases, style)) {
                style = type.styleAliases[style];
              }
              result[tag] = style;
            }
            return result;
          }
          function encodeHex(character) {
            var string, handle, length;
            string = character.toString(16).toUpperCase();
            if (character <= 255) {
              handle = "x";
              length = 2;
            } else if (character <= 65535) {
              handle = "u";
              length = 4;
            } else if (character <= 4294967295) {
              handle = "U";
              length = 8;
            } else {
              throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
            }
            return "\\" + handle + common.repeat("0", length - string.length) + string;
          }
          var QUOTING_TYPE_SINGLE = 1, QUOTING_TYPE_DOUBLE = 2;
          function State(options) {
            this.schema = options["schema"] || DEFAULT_SCHEMA;
            this.indent = Math.max(1, options["indent"] || 2);
            this.noArrayIndent = options["noArrayIndent"] || false;
            this.skipInvalid = options["skipInvalid"] || false;
            this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
            this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
            this.sortKeys = options["sortKeys"] || false;
            this.lineWidth = options["lineWidth"] || 80;
            this.noRefs = options["noRefs"] || false;
            this.noCompatMode = options["noCompatMode"] || false;
            this.condenseFlow = options["condenseFlow"] || false;
            this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
            this.forceQuotes = options["forceQuotes"] || false;
            this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.explicitTypes = this.schema.compiledExplicit;
            this.tag = null;
            this.result = "";
            this.duplicates = [];
            this.usedDuplicates = null;
          }
          function indentString(string, spaces) {
            var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
            while (position < length) {
              next = string.indexOf("\n", position);
              if (next === -1) {
                line = string.slice(position);
                position = length;
              } else {
                line = string.slice(position, next + 1);
                position = next + 1;
              }
              if (line.length && line !== "\n") result += ind;
              result += line;
            }
            return result;
          }
          function generateNextLine(state, level) {
            return "\n" + common.repeat(" ", state.indent * level);
          }
          function testImplicitResolving(state, str) {
            var index, length, type;
            for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
              type = state.implicitTypes[index];
              if (type.resolve(str)) {
                return true;
              }
            }
            return false;
          }
          function isWhitespace(c2) {
            return c2 === CHAR_SPACE || c2 === CHAR_TAB;
          }
          function isPrintable(c2) {
            return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
          }
          function isNsCharOrWhitespace(c2) {
            return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
          }
          function isPlainSafe(c2, prev, inblock) {
            var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
            var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
            return (
              // ns-plain-safe
              (inblock ? (
                // c = flow-in
                cIsNsCharOrWhitespace
              ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
            );
          }
          function isPlainSafeFirst(c2) {
            return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
          }
          function isPlainSafeLast(c2) {
            return !isWhitespace(c2) && c2 !== CHAR_COLON;
          }
          function codePointAt(string, pos) {
            var first = string.charCodeAt(pos), second;
            if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
              second = string.charCodeAt(pos + 1);
              if (second >= 56320 && second <= 57343) {
                return (first - 55296) * 1024 + second - 56320 + 65536;
              }
            }
            return first;
          }
          function needIndentIndicator(string) {
            var leadingSpaceRe = /^\n* /;
            return leadingSpaceRe.test(string);
          }
          var STYLE_PLAIN = 1, STYLE_SINGLE = 2, STYLE_LITERAL = 3, STYLE_FOLDED = 4, STYLE_DOUBLE = 5;
          function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
            var i2;
            var char = 0;
            var prevChar = null;
            var hasLineBreak = false;
            var hasFoldableLine = false;
            var shouldTrackWidth = lineWidth !== -1;
            var previousLineBreak = -1;
            var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
            if (singleLineOnly || forceQuotes) {
              for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
                char = codePointAt(string, i2);
                if (!isPrintable(char)) {
                  return STYLE_DOUBLE;
                }
                plain = plain && isPlainSafe(char, prevChar, inblock);
                prevChar = char;
              }
            } else {
              for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
                char = codePointAt(string, i2);
                if (char === CHAR_LINE_FEED) {
                  hasLineBreak = true;
                  if (shouldTrackWidth) {
                    hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
                    i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
                    previousLineBreak = i2;
                  }
                } else if (!isPrintable(char)) {
                  return STYLE_DOUBLE;
                }
                plain = plain && isPlainSafe(char, prevChar, inblock);
                prevChar = char;
              }
              hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
            }
            if (!hasLineBreak && !hasFoldableLine) {
              if (plain && !forceQuotes && !testAmbiguousType(string)) {
                return STYLE_PLAIN;
              }
              return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
            }
            if (indentPerLevel > 9 && needIndentIndicator(string)) {
              return STYLE_DOUBLE;
            }
            if (!forceQuotes) {
              return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
            }
            return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
          }
          function writeScalar(state, string, level, iskey, inblock) {
            state.dump = function() {
              if (string.length === 0) {
                return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
              }
              if (!state.noCompatMode) {
                if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
                  return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
                }
              }
              var indent = state.indent * Math.max(1, level);
              var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
              var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
              function testAmbiguity(string2) {
                return testImplicitResolving(state, string2);
              }
              switch (chooseScalarStyle(
                string,
                singleLineOnly,
                state.indent,
                lineWidth,
                testAmbiguity,
                state.quotingType,
                state.forceQuotes && !iskey,
                inblock
              )) {
                case STYLE_PLAIN:
                  return string;
                case STYLE_SINGLE:
                  return "'" + string.replace(/'/g, "''") + "'";
                case STYLE_LITERAL:
                  return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
                case STYLE_FOLDED:
                  return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
                case STYLE_DOUBLE:
                  return '"' + escapeString(string) + '"';
                default:
                  throw new YAMLException("impossible error: invalid scalar style");
              }
            }();
          }
          function blockHeader(string, indentPerLevel) {
            var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
            var clip = string[string.length - 1] === "\n";
            var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
            var chomp = keep ? "+" : clip ? "" : "-";
            return indentIndicator + chomp + "\n";
          }
          function dropEndingNewline(string) {
            return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
          }
          function foldString(string, width) {
            var lineRe = /(\n+)([^\n]*)/g;
            var result = function() {
              var nextLF = string.indexOf("\n");
              nextLF = nextLF !== -1 ? nextLF : string.length;
              lineRe.lastIndex = nextLF;
              return foldLine(string.slice(0, nextLF), width);
            }();
            var prevMoreIndented = string[0] === "\n" || string[0] === " ";
            var moreIndented;
            var match;
            while (match = lineRe.exec(string)) {
              var prefix = match[1], line = match[2];
              moreIndented = line[0] === " ";
              result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
              prevMoreIndented = moreIndented;
            }
            return result;
          }
          function foldLine(line, width) {
            if (line === "" || line[0] === " ") return line;
            var breakRe = / [^ ]/g;
            var match;
            var start = 0, end, curr = 0, next = 0;
            var result = "";
            while (match = breakRe.exec(line)) {
              next = match.index;
              if (next - start > width) {
                end = curr > start ? curr : next;
                result += "\n" + line.slice(start, end);
                start = end + 1;
              }
              curr = next;
            }
            result += "\n";
            if (line.length - start > width && curr > start) {
              result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
            } else {
              result += line.slice(start);
            }
            return result.slice(1);
          }
          function escapeString(string) {
            var result = "";
            var char = 0;
            var escapeSeq;
            for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
              char = codePointAt(string, i2);
              escapeSeq = ESCAPE_SEQUENCES[char];
              if (!escapeSeq && isPrintable(char)) {
                result += string[i2];
                if (char >= 65536) result += string[i2 + 1];
              } else {
                result += escapeSeq || encodeHex(char);
              }
            }
            return result;
          }
          function writeFlowSequence(state, level, object) {
            var _result = "", _tag = state.tag, index, length, value;
            for (index = 0, length = object.length; index < length; index += 1) {
              value = object[index];
              if (state.replacer) {
                value = state.replacer.call(object, String(index), value);
              }
              if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
                if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = "[" + _result + "]";
          }
          function writeBlockSequence(state, level, object, compact) {
            var _result = "", _tag = state.tag, index, length, value;
            for (index = 0, length = object.length; index < length; index += 1) {
              value = object[index];
              if (state.replacer) {
                value = state.replacer.call(object, String(index), value);
              }
              if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
                if (!compact || _result !== "") {
                  _result += generateNextLine(state, level);
                }
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  _result += "-";
                } else {
                  _result += "- ";
                }
                _result += state.dump;
              }
            }
            state.tag = _tag;
            state.dump = _result || "[]";
          }
          function writeFlowMapping(state, level, object) {
            var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              pairBuffer = "";
              if (_result !== "") pairBuffer += ", ";
              if (state.condenseFlow) pairBuffer += '"';
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (state.replacer) {
                objectValue = state.replacer.call(object, objectKey, objectValue);
              }
              if (!writeNode(state, level, objectKey, false, false)) {
                continue;
              }
              if (state.dump.length > 1024) pairBuffer += "? ";
              pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
              if (!writeNode(state, level, objectValue, false, false)) {
                continue;
              }
              pairBuffer += state.dump;
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = "{" + _result + "}";
          }
          function writeBlockMapping(state, level, object, compact) {
            var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
            if (state.sortKeys === true) {
              objectKeyList.sort();
            } else if (typeof state.sortKeys === "function") {
              objectKeyList.sort(state.sortKeys);
            } else if (state.sortKeys) {
              throw new YAMLException("sortKeys must be a boolean or a function");
            }
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              pairBuffer = "";
              if (!compact || _result !== "") {
                pairBuffer += generateNextLine(state, level);
              }
              objectKey = objectKeyList[index];
              objectValue = object[objectKey];
              if (state.replacer) {
                objectValue = state.replacer.call(object, objectKey, objectValue);
              }
              if (!writeNode(state, level + 1, objectKey, true, true, true)) {
                continue;
              }
              explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
              if (explicitPair) {
                if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                  pairBuffer += "?";
                } else {
                  pairBuffer += "? ";
                }
              }
              pairBuffer += state.dump;
              if (explicitPair) {
                pairBuffer += generateNextLine(state, level);
              }
              if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
                continue;
              }
              if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += ":";
              } else {
                pairBuffer += ": ";
              }
              pairBuffer += state.dump;
              _result += pairBuffer;
            }
            state.tag = _tag;
            state.dump = _result || "{}";
          }
          function detectType(state, object, explicit) {
            var _result, typeList, index, length, type, style;
            typeList = explicit ? state.explicitTypes : state.implicitTypes;
            for (index = 0, length = typeList.length; index < length; index += 1) {
              type = typeList[index];
              if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
                if (explicit) {
                  if (type.multi && type.representName) {
                    state.tag = type.representName(object);
                  } else {
                    state.tag = type.tag;
                  }
                } else {
                  state.tag = "?";
                }
                if (type.represent) {
                  style = state.styleMap[type.tag] || type.defaultStyle;
                  if (_toString.call(type.represent) === "[object Function]") {
                    _result = type.represent(object, style);
                  } else if (_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                  } else {
                    throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
                  }
                  state.dump = _result;
                }
                return true;
              }
            }
            return false;
          }
          function writeNode(state, level, object, block2, compact, iskey, isblockseq) {
            state.tag = null;
            state.dump = object;
            if (!detectType(state, object, false)) {
              detectType(state, object, true);
            }
            var type = _toString.call(state.dump);
            var inblock = block2;
            var tagStr;
            if (block2) {
              block2 = state.flowLevel < 0 || state.flowLevel > level;
            }
            var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
            if (objectOrArray) {
              duplicateIndex = state.duplicates.indexOf(object);
              duplicate = duplicateIndex !== -1;
            }
            if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
              compact = false;
            }
            if (duplicate && state.usedDuplicates[duplicateIndex]) {
              state.dump = "*ref_" + duplicateIndex;
            } else {
              if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
                state.usedDuplicates[duplicateIndex] = true;
              }
              if (type === "[object Object]") {
                if (block2 && Object.keys(state.dump).length !== 0) {
                  writeBlockMapping(state, level, state.dump, compact);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                  }
                } else {
                  writeFlowMapping(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if (type === "[object Array]") {
                if (block2 && state.dump.length !== 0) {
                  if (state.noArrayIndent && !isblockseq && level > 0) {
                    writeBlockSequence(state, level - 1, state.dump, compact);
                  } else {
                    writeBlockSequence(state, level, state.dump, compact);
                  }
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + state.dump;
                  }
                } else {
                  writeFlowSequence(state, level, state.dump);
                  if (duplicate) {
                    state.dump = "&ref_" + duplicateIndex + " " + state.dump;
                  }
                }
              } else if (type === "[object String]") {
                if (state.tag !== "?") {
                  writeScalar(state, state.dump, level, iskey, inblock);
                }
              } else if (type === "[object Undefined]") {
                return false;
              } else {
                if (state.skipInvalid) return false;
                throw new YAMLException("unacceptable kind of an object to dump " + type);
              }
              if (state.tag !== null && state.tag !== "?") {
                tagStr = encodeURI(
                  state.tag[0] === "!" ? state.tag.slice(1) : state.tag
                ).replace(/!/g, "%21");
                if (state.tag[0] === "!") {
                  tagStr = "!" + tagStr;
                } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
                  tagStr = "!!" + tagStr.slice(18);
                } else {
                  tagStr = "!<" + tagStr + ">";
                }
                state.dump = tagStr + " " + state.dump;
              }
            }
            return true;
          }
          function getDuplicateReferences(object, state) {
            var objects = [], duplicatesIndexes = [], index, length;
            inspectNode(object, objects, duplicatesIndexes);
            for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
              state.duplicates.push(objects[duplicatesIndexes[index]]);
            }
            state.usedDuplicates = new Array(length);
          }
          function inspectNode(object, objects, duplicatesIndexes) {
            var objectKeyList, index, length;
            if (object !== null && typeof object === "object") {
              index = objects.indexOf(object);
              if (index !== -1) {
                if (duplicatesIndexes.indexOf(index) === -1) {
                  duplicatesIndexes.push(index);
                }
              } else {
                objects.push(object);
                if (Array.isArray(object)) {
                  for (index = 0, length = object.length; index < length; index += 1) {
                    inspectNode(object[index], objects, duplicatesIndexes);
                  }
                } else {
                  objectKeyList = Object.keys(object);
                  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                  }
                }
              }
            }
          }
          function dump(input, options) {
            options = options || {};
            var state = new State(options);
            if (!state.noRefs) getDuplicateReferences(input, state);
            var value = input;
            if (state.replacer) {
              value = state.replacer.call({ "": value }, "", value);
            }
            if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
            return "";
          }
          module3.exports.dump = dump;
        }, { "./common": 202, "./exception": 204, "./schema/default": 208 }], 204: [function(require2, module3, exports3) {
          function formatError(exception, compact) {
            var where = "", message = exception.reason || "(unknown reason)";
            if (!exception.mark) return message;
            if (exception.mark.name) {
              where += 'in "' + exception.mark.name + '" ';
            }
            where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
            if (!compact && exception.mark.snippet) {
              where += "\n\n" + exception.mark.snippet;
            }
            return message + " " + where;
          }
          function YAMLException(reason, mark) {
            Error.call(this);
            this.name = "YAMLException";
            this.reason = reason;
            this.mark = mark;
            this.message = formatError(this, false);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(this, this.constructor);
            } else {
              this.stack = new Error().stack || "";
            }
          }
          YAMLException.prototype = Object.create(Error.prototype);
          YAMLException.prototype.constructor = YAMLException;
          YAMLException.prototype.toString = function toString2(compact) {
            return this.name + ": " + formatError(this, compact);
          };
          module3.exports = YAMLException;
        }, {}], 205: [function(require2, module3, exports3) {
          var common = require2("./common");
          var YAMLException = require2("./exception");
          var makeSnippet = require2("./snippet");
          var DEFAULT_SCHEMA = require2("./schema/default");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var CONTEXT_FLOW_IN = 1;
          var CONTEXT_FLOW_OUT = 2;
          var CONTEXT_BLOCK_IN = 3;
          var CONTEXT_BLOCK_OUT = 4;
          var CHOMPING_CLIP = 1;
          var CHOMPING_STRIP = 2;
          var CHOMPING_KEEP = 3;
          var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
          var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
          var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
          var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
          var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
          function _class(obj) {
            return Object.prototype.toString.call(obj);
          }
          function is_EOL(c2) {
            return c2 === 10 || c2 === 13;
          }
          function is_WHITE_SPACE(c2) {
            return c2 === 9 || c2 === 32;
          }
          function is_WS_OR_EOL(c2) {
            return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
          }
          function is_FLOW_INDICATOR(c2) {
            return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
          }
          function fromHexCode(c2) {
            var lc;
            if (48 <= c2 && c2 <= 57) {
              return c2 - 48;
            }
            lc = c2 | 32;
            if (97 <= lc && lc <= 102) {
              return lc - 97 + 10;
            }
            return -1;
          }
          function escapedHexLen(c2) {
            if (c2 === 120) {
              return 2;
            }
            if (c2 === 117) {
              return 4;
            }
            if (c2 === 85) {
              return 8;
            }
            return 0;
          }
          function fromDecimalCode(c2) {
            if (48 <= c2 && c2 <= 57) {
              return c2 - 48;
            }
            return -1;
          }
          function simpleEscapeSequence(c2) {
            return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? " " : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
          }
          function charFromCodepoint(c2) {
            if (c2 <= 65535) {
              return String.fromCharCode(c2);
            }
            return String.fromCharCode(
              (c2 - 65536 >> 10) + 55296,
              (c2 - 65536 & 1023) + 56320
            );
          }
          var simpleEscapeCheck = new Array(256);
          var simpleEscapeMap = new Array(256);
          for (var i2 = 0; i2 < 256; i2++) {
            simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
            simpleEscapeMap[i2] = simpleEscapeSequence(i2);
          }
          function State(input, options) {
            this.input = input;
            this.filename = options["filename"] || null;
            this.schema = options["schema"] || DEFAULT_SCHEMA;
            this.onWarning = options["onWarning"] || null;
            this.legacy = options["legacy"] || false;
            this.json = options["json"] || false;
            this.listener = options["listener"] || null;
            this.implicitTypes = this.schema.compiledImplicit;
            this.typeMap = this.schema.compiledTypeMap;
            this.length = input.length;
            this.position = 0;
            this.line = 0;
            this.lineStart = 0;
            this.lineIndent = 0;
            this.firstTabInLine = -1;
            this.documents = [];
          }
          function generateError(state, message) {
            var mark = {
              name: state.filename,
              buffer: state.input.slice(0, -1),
              // omit trailing \0
              position: state.position,
              line: state.line,
              column: state.position - state.lineStart
            };
            mark.snippet = makeSnippet(mark);
            return new YAMLException(message, mark);
          }
          function throwError(state, message) {
            throw generateError(state, message);
          }
          function throwWarning(state, message) {
            if (state.onWarning) {
              state.onWarning.call(null, generateError(state, message));
            }
          }
          var directiveHandlers = {
            YAML: function handleYamlDirective(state, name, args) {
              var match, major, minor;
              if (state.version !== null) {
                throwError(state, "duplication of %YAML directive");
              }
              if (args.length !== 1) {
                throwError(state, "YAML directive accepts exactly one argument");
              }
              match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
              if (match === null) {
                throwError(state, "ill-formed argument of the YAML directive");
              }
              major = parseInt(match[1], 10);
              minor = parseInt(match[2], 10);
              if (major !== 1) {
                throwError(state, "unacceptable YAML version of the document");
              }
              state.version = args[0];
              state.checkLineBreaks = minor < 2;
              if (minor !== 1 && minor !== 2) {
                throwWarning(state, "unsupported YAML version of the document");
              }
            },
            TAG: function handleTagDirective(state, name, args) {
              var handle, prefix;
              if (args.length !== 2) {
                throwError(state, "TAG directive accepts exactly two arguments");
              }
              handle = args[0];
              prefix = args[1];
              if (!PATTERN_TAG_HANDLE.test(handle)) {
                throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
              }
              if (_hasOwnProperty.call(state.tagMap, handle)) {
                throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
              }
              if (!PATTERN_TAG_URI.test(prefix)) {
                throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
              }
              try {
                prefix = decodeURIComponent(prefix);
              } catch (err) {
                throwError(state, "tag prefix is malformed: " + prefix);
              }
              state.tagMap[handle] = prefix;
            }
          };
          function captureSegment(state, start, end, checkJson) {
            var _position, _length, _character, _result;
            if (start < end) {
              _result = state.input.slice(start, end);
              if (checkJson) {
                for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                  _character = _result.charCodeAt(_position);
                  if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
                    throwError(state, "expected valid JSON character");
                  }
                }
              } else if (PATTERN_NON_PRINTABLE.test(_result)) {
                throwError(state, "the stream contains non-printable characters");
              }
              state.result += _result;
            }
          }
          function mergeMappings(state, destination, source, overridableKeys) {
            var sourceKeys, key, index, quantity;
            if (!common.isObject(source)) {
              throwError(state, "cannot merge mappings; the provided source object is unacceptable");
            }
            sourceKeys = Object.keys(source);
            for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
              key = sourceKeys[index];
              if (!_hasOwnProperty.call(destination, key)) {
                destination[key] = source[key];
                overridableKeys[key] = true;
              }
            }
          }
          function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
            var index, quantity;
            if (Array.isArray(keyNode)) {
              keyNode = Array.prototype.slice.call(keyNode);
              for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
                if (Array.isArray(keyNode[index])) {
                  throwError(state, "nested arrays are not supported inside keys");
                }
                if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
                  keyNode[index] = "[object Object]";
                }
              }
            }
            if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
              keyNode = "[object Object]";
            }
            keyNode = String(keyNode);
            if (_result === null) {
              _result = {};
            }
            if (keyTag === "tag:yaml.org,2002:merge") {
              if (Array.isArray(valueNode)) {
                for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
                  mergeMappings(state, _result, valueNode[index], overridableKeys);
                }
              } else {
                mergeMappings(state, _result, valueNode, overridableKeys);
              }
            } else {
              if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
                state.line = startLine || state.line;
                state.lineStart = startLineStart || state.lineStart;
                state.position = startPos || state.position;
                throwError(state, "duplicated mapping key");
              }
              if (keyNode === "__proto__") {
                Object.defineProperty(_result, keyNode, {
                  configurable: true,
                  enumerable: true,
                  writable: true,
                  value: valueNode
                });
              } else {
                _result[keyNode] = valueNode;
              }
              delete overridableKeys[keyNode];
            }
            return _result;
          }
          function readLineBreak(state) {
            var ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 10) {
              state.position++;
            } else if (ch === 13) {
              state.position++;
              if (state.input.charCodeAt(state.position) === 10) {
                state.position++;
              }
            } else {
              throwError(state, "a line break is expected");
            }
            state.line += 1;
            state.lineStart = state.position;
            state.firstTabInLine = -1;
          }
          function skipSeparationSpace(state, allowComments, checkIndent) {
            var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              while (is_WHITE_SPACE(ch)) {
                if (ch === 9 && state.firstTabInLine === -1) {
                  state.firstTabInLine = state.position;
                }
                ch = state.input.charCodeAt(++state.position);
              }
              if (allowComments && ch === 35) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (ch !== 10 && ch !== 13 && ch !== 0);
              }
              if (is_EOL(ch)) {
                readLineBreak(state);
                ch = state.input.charCodeAt(state.position);
                lineBreaks++;
                state.lineIndent = 0;
                while (ch === 32) {
                  state.lineIndent++;
                  ch = state.input.charCodeAt(++state.position);
                }
              } else {
                break;
              }
            }
            if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
              throwWarning(state, "deficient indentation");
            }
            return lineBreaks;
          }
          function testDocumentSeparator(state) {
            var _position = state.position, ch;
            ch = state.input.charCodeAt(_position);
            if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
              _position += 3;
              ch = state.input.charCodeAt(_position);
              if (ch === 0 || is_WS_OR_EOL(ch)) {
                return true;
              }
            }
            return false;
          }
          function writeFoldedLines(state, count) {
            if (count === 1) {
              state.result += " ";
            } else if (count > 1) {
              state.result += common.repeat("\n", count - 1);
            }
          }
          function readPlainScalar(state, nodeIndent, withinFlowCollection) {
            var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
            ch = state.input.charCodeAt(state.position);
            if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
              return false;
            }
            if (ch === 63 || ch === 45) {
              following = state.input.charCodeAt(state.position + 1);
              if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                return false;
              }
            }
            state.kind = "scalar";
            state.result = "";
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
            while (ch !== 0) {
              if (ch === 58) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
                  break;
                }
              } else if (ch === 35) {
                preceding = state.input.charCodeAt(state.position - 1);
                if (is_WS_OR_EOL(preceding)) {
                  break;
                }
              } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
                break;
              } else if (is_EOL(ch)) {
                _line = state.line;
                _lineStart = state.lineStart;
                _lineIndent = state.lineIndent;
                skipSeparationSpace(state, false, -1);
                if (state.lineIndent >= nodeIndent) {
                  hasPendingContent = true;
                  ch = state.input.charCodeAt(state.position);
                  continue;
                } else {
                  state.position = captureEnd;
                  state.line = _line;
                  state.lineStart = _lineStart;
                  state.lineIndent = _lineIndent;
                  break;
                }
              }
              if (hasPendingContent) {
                captureSegment(state, captureStart, captureEnd, false);
                writeFoldedLines(state, state.line - _line);
                captureStart = captureEnd = state.position;
                hasPendingContent = false;
              }
              if (!is_WHITE_SPACE(ch)) {
                captureEnd = state.position + 1;
              }
              ch = state.input.charCodeAt(++state.position);
            }
            captureSegment(state, captureStart, captureEnd, false);
            if (state.result) {
              return true;
            }
            state.kind = _kind;
            state.result = _result;
            return false;
          }
          function readSingleQuotedScalar(state, nodeIndent) {
            var ch, captureStart, captureEnd;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 39) {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            state.position++;
            captureStart = captureEnd = state.position;
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              if (ch === 39) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (ch === 39) {
                  captureStart = state.position;
                  state.position++;
                  captureEnd = state.position;
                } else {
                  return true;
                }
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                captureStart = captureEnd = state.position;
              } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                throwError(state, "unexpected end of the document within a single quoted scalar");
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(state, "unexpected end of the stream within a single quoted scalar");
          }
          function readDoubleQuotedScalar(state, nodeIndent) {
            var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 34) {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            state.position++;
            captureStart = captureEnd = state.position;
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              if (ch === 34) {
                captureSegment(state, captureStart, state.position, true);
                state.position++;
                return true;
              } else if (ch === 92) {
                captureSegment(state, captureStart, state.position, true);
                ch = state.input.charCodeAt(++state.position);
                if (is_EOL(ch)) {
                  skipSeparationSpace(state, false, nodeIndent);
                } else if (ch < 256 && simpleEscapeCheck[ch]) {
                  state.result += simpleEscapeMap[ch];
                  state.position++;
                } else if ((tmp = escapedHexLen(ch)) > 0) {
                  hexLength = tmp;
                  hexResult = 0;
                  for (; hexLength > 0; hexLength--) {
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                      hexResult = (hexResult << 4) + tmp;
                    } else {
                      throwError(state, "expected hexadecimal character");
                    }
                  }
                  state.result += charFromCodepoint(hexResult);
                  state.position++;
                } else {
                  throwError(state, "unknown escape sequence");
                }
                captureStart = captureEnd = state.position;
              } else if (is_EOL(ch)) {
                captureSegment(state, captureStart, captureEnd, true);
                writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
                captureStart = captureEnd = state.position;
              } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
                throwError(state, "unexpected end of the document within a double quoted scalar");
              } else {
                state.position++;
                captureEnd = state.position;
              }
            }
            throwError(state, "unexpected end of the stream within a double quoted scalar");
          }
          function readFlowCollection(state, nodeIndent) {
            var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 91) {
              terminator = 93;
              isMapping = false;
              _result = [];
            } else if (ch === 123) {
              terminator = 125;
              isMapping = true;
              _result = {};
            } else {
              return false;
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(++state.position);
            while (ch !== 0) {
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === terminator) {
                state.position++;
                state.tag = _tag;
                state.anchor = _anchor;
                state.kind = isMapping ? "mapping" : "sequence";
                state.result = _result;
                return true;
              } else if (!readNext) {
                throwError(state, "missed comma between flow collection entries");
              } else if (ch === 44) {
                throwError(state, "expected the node content, but found ','");
              }
              keyTag = keyNode = valueNode = null;
              isPair = isExplicitPair = false;
              if (ch === 63) {
                following = state.input.charCodeAt(state.position + 1);
                if (is_WS_OR_EOL(following)) {
                  isPair = isExplicitPair = true;
                  state.position++;
                  skipSeparationSpace(state, true, nodeIndent);
                }
              }
              _line = state.line;
              _lineStart = state.lineStart;
              _pos = state.position;
              composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
              keyTag = state.tag;
              keyNode = state.result;
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if ((isExplicitPair || state.line === _line) && ch === 58) {
                isPair = true;
                ch = state.input.charCodeAt(++state.position);
                skipSeparationSpace(state, true, nodeIndent);
                composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
                valueNode = state.result;
              }
              if (isMapping) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
              } else if (isPair) {
                _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
              } else {
                _result.push(keyNode);
              }
              skipSeparationSpace(state, true, nodeIndent);
              ch = state.input.charCodeAt(state.position);
              if (ch === 44) {
                readNext = true;
                ch = state.input.charCodeAt(++state.position);
              } else {
                readNext = false;
              }
            }
            throwError(state, "unexpected end of the stream within a flow collection");
          }
          function readBlockScalar(state, nodeIndent) {
            var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch === 124) {
              folding = false;
            } else if (ch === 62) {
              folding = true;
            } else {
              return false;
            }
            state.kind = "scalar";
            state.result = "";
            while (ch !== 0) {
              ch = state.input.charCodeAt(++state.position);
              if (ch === 43 || ch === 45) {
                if (CHOMPING_CLIP === chomping) {
                  chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
                } else {
                  throwError(state, "repeat of a chomping mode identifier");
                }
              } else if ((tmp = fromDecimalCode(ch)) >= 0) {
                if (tmp === 0) {
                  throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
                } else if (!detectedIndent) {
                  textIndent = nodeIndent + tmp - 1;
                  detectedIndent = true;
                } else {
                  throwError(state, "repeat of an indentation width identifier");
                }
              } else {
                break;
              }
            }
            if (is_WHITE_SPACE(ch)) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (is_WHITE_SPACE(ch));
              if (ch === 35) {
                do {
                  ch = state.input.charCodeAt(++state.position);
                } while (!is_EOL(ch) && ch !== 0);
              }
            }
            while (ch !== 0) {
              readLineBreak(state);
              state.lineIndent = 0;
              ch = state.input.charCodeAt(state.position);
              while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
              }
              if (!detectedIndent && state.lineIndent > textIndent) {
                textIndent = state.lineIndent;
              }
              if (is_EOL(ch)) {
                emptyLines++;
                continue;
              }
              if (state.lineIndent < textIndent) {
                if (chomping === CHOMPING_KEEP) {
                  state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                } else if (chomping === CHOMPING_CLIP) {
                  if (didReadContent) {
                    state.result += "\n";
                  }
                }
                break;
              }
              if (folding) {
                if (is_WHITE_SPACE(ch)) {
                  atMoreIndented = true;
                  state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
                } else if (atMoreIndented) {
                  atMoreIndented = false;
                  state.result += common.repeat("\n", emptyLines + 1);
                } else if (emptyLines === 0) {
                  if (didReadContent) {
                    state.result += " ";
                  }
                } else {
                  state.result += common.repeat("\n", emptyLines);
                }
              } else {
                state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
              }
              didReadContent = true;
              detectedIndent = true;
              emptyLines = 0;
              captureStart = state.position;
              while (!is_EOL(ch) && ch !== 0) {
                ch = state.input.charCodeAt(++state.position);
              }
              captureSegment(state, captureStart, state.position, false);
            }
            return true;
          }
          function readBlockSequence(state, nodeIndent) {
            var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
            if (state.firstTabInLine !== -1) return false;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              if (state.firstTabInLine !== -1) {
                state.position = state.firstTabInLine;
                throwError(state, "tab characters must not be used in indentation");
              }
              if (ch !== 45) {
                break;
              }
              following = state.input.charCodeAt(state.position + 1);
              if (!is_WS_OR_EOL(following)) {
                break;
              }
              detected = true;
              state.position++;
              if (skipSeparationSpace(state, true, -1)) {
                if (state.lineIndent <= nodeIndent) {
                  _result.push(null);
                  ch = state.input.charCodeAt(state.position);
                  continue;
                }
              }
              _line = state.line;
              composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
              _result.push(state.result);
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
                throwError(state, "bad indentation of a sequence entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            }
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "sequence";
              state.result = _result;
              return true;
            }
            return false;
          }
          function readBlockMapping(state, nodeIndent, flowIndent) {
            var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
            if (state.firstTabInLine !== -1) return false;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = _result;
            }
            ch = state.input.charCodeAt(state.position);
            while (ch !== 0) {
              if (!atExplicitKey && state.firstTabInLine !== -1) {
                state.position = state.firstTabInLine;
                throwError(state, "tab characters must not be used in indentation");
              }
              following = state.input.charCodeAt(state.position + 1);
              _line = state.line;
              if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
                if (ch === 63) {
                  if (atExplicitKey) {
                    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                    keyTag = keyNode = valueNode = null;
                  }
                  detected = true;
                  atExplicitKey = true;
                  allowCompact = true;
                } else if (atExplicitKey) {
                  atExplicitKey = false;
                  allowCompact = true;
                } else {
                  throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
                }
                state.position += 1;
                ch = following;
              } else {
                _keyLine = state.line;
                _keyLineStart = state.lineStart;
                _keyPos = state.position;
                if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
                  break;
                }
                if (state.line === _line) {
                  ch = state.input.charCodeAt(state.position);
                  while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                  }
                  if (ch === 58) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                      throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
                    }
                    if (atExplicitKey) {
                      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                      keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                  } else if (detected) {
                    throwError(state, "can not read an implicit mapping pair; a colon is missed");
                  } else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true;
                  }
                } else if (detected) {
                  throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
                } else {
                  state.tag = _tag;
                  state.anchor = _anchor;
                  return true;
                }
              }
              if (state.line === _line || state.lineIndent > nodeIndent) {
                if (atExplicitKey) {
                  _keyLine = state.line;
                  _keyLineStart = state.lineStart;
                  _keyPos = state.position;
                }
                if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                  if (atExplicitKey) {
                    keyNode = state.result;
                  } else {
                    valueNode = state.result;
                  }
                }
                if (!atExplicitKey) {
                  storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
                  keyTag = keyNode = valueNode = null;
                }
                skipSeparationSpace(state, true, -1);
                ch = state.input.charCodeAt(state.position);
              }
              if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
                throwError(state, "bad indentation of a mapping entry");
              } else if (state.lineIndent < nodeIndent) {
                break;
              }
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            }
            if (detected) {
              state.tag = _tag;
              state.anchor = _anchor;
              state.kind = "mapping";
              state.result = _result;
            }
            return detected;
          }
          function readTagProperty(state) {
            var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 33) return false;
            if (state.tag !== null) {
              throwError(state, "duplication of a tag property");
            }
            ch = state.input.charCodeAt(++state.position);
            if (ch === 60) {
              isVerbatim = true;
              ch = state.input.charCodeAt(++state.position);
            } else if (ch === 33) {
              isNamed = true;
              tagHandle = "!!";
              ch = state.input.charCodeAt(++state.position);
            } else {
              tagHandle = "!";
            }
            _position = state.position;
            if (isVerbatim) {
              do {
                ch = state.input.charCodeAt(++state.position);
              } while (ch !== 0 && ch !== 62);
              if (state.position < state.length) {
                tagName = state.input.slice(_position, state.position);
                ch = state.input.charCodeAt(++state.position);
              } else {
                throwError(state, "unexpected end of the stream within a verbatim tag");
              }
            } else {
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                if (ch === 33) {
                  if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                      throwError(state, "named tag handle cannot contain such characters");
                    }
                    isNamed = true;
                    _position = state.position + 1;
                  } else {
                    throwError(state, "tag suffix cannot contain exclamation marks");
                  }
                }
                ch = state.input.charCodeAt(++state.position);
              }
              tagName = state.input.slice(_position, state.position);
              if (PATTERN_FLOW_INDICATORS.test(tagName)) {
                throwError(state, "tag suffix cannot contain flow indicator characters");
              }
            }
            if (tagName && !PATTERN_TAG_URI.test(tagName)) {
              throwError(state, "tag name cannot contain such characters: " + tagName);
            }
            try {
              tagName = decodeURIComponent(tagName);
            } catch (err) {
              throwError(state, "tag name is malformed: " + tagName);
            }
            if (isVerbatim) {
              state.tag = tagName;
            } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
              state.tag = state.tagMap[tagHandle] + tagName;
            } else if (tagHandle === "!") {
              state.tag = "!" + tagName;
            } else if (tagHandle === "!!") {
              state.tag = "tag:yaml.org,2002:" + tagName;
            } else {
              throwError(state, 'undeclared tag handle "' + tagHandle + '"');
            }
            return true;
          }
          function readAnchorProperty(state) {
            var _position, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 38) return false;
            if (state.anchor !== null) {
              throwError(state, "duplication of an anchor property");
            }
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(state, "name of an anchor node must contain at least one character");
            }
            state.anchor = state.input.slice(_position, state.position);
            return true;
          }
          function readAlias(state) {
            var _position, alias, ch;
            ch = state.input.charCodeAt(state.position);
            if (ch !== 42) return false;
            ch = state.input.charCodeAt(++state.position);
            _position = state.position;
            while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (state.position === _position) {
              throwError(state, "name of an alias node must contain at least one character");
            }
            alias = state.input.slice(_position, state.position);
            if (!_hasOwnProperty.call(state.anchorMap, alias)) {
              throwError(state, 'unidentified alias "' + alias + '"');
            }
            state.result = state.anchorMap[alias];
            skipSeparationSpace(state, true, -1);
            return true;
          }
          function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
            var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
            if (state.listener !== null) {
              state.listener("open", state);
            }
            state.tag = null;
            state.anchor = null;
            state.kind = null;
            state.result = null;
            allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
            if (allowToSeek) {
              if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                if (state.lineIndent > parentIndent) {
                  indentStatus = 1;
                } else if (state.lineIndent === parentIndent) {
                  indentStatus = 0;
                } else if (state.lineIndent < parentIndent) {
                  indentStatus = -1;
                }
              }
            }
            if (indentStatus === 1) {
              while (readTagProperty(state) || readAnchorProperty(state)) {
                if (skipSeparationSpace(state, true, -1)) {
                  atNewLine = true;
                  allowBlockCollections = allowBlockStyles;
                  if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                  } else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                  } else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                  }
                } else {
                  allowBlockCollections = false;
                }
              }
            }
            if (allowBlockCollections) {
              allowBlockCollections = atNewLine || allowCompact;
            }
            if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
              if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
                flowIndent = parentIndent;
              } else {
                flowIndent = parentIndent + 1;
              }
              blockIndent = state.position - state.lineStart;
              if (indentStatus === 1) {
                if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
                  hasContent = true;
                } else {
                  if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
                    hasContent = true;
                  } else if (readAlias(state)) {
                    hasContent = true;
                    if (state.tag !== null || state.anchor !== null) {
                      throwError(state, "alias node should not have any properties");
                    }
                  } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (state.tag === null) {
                      state.tag = "?";
                    }
                  }
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                }
              } else if (indentStatus === 0) {
                hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
              }
            }
            if (state.tag === null) {
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
            } else if (state.tag === "?") {
              if (state.result !== null && state.kind !== "scalar") {
                throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
              }
              for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                if (type.resolve(state.result)) {
                  state.result = type.construct(state.result);
                  state.tag = type.tag;
                  if (state.anchor !== null) {
                    state.anchorMap[state.anchor] = state.result;
                  }
                  break;
                }
              }
            } else if (state.tag !== "!") {
              if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
                type = state.typeMap[state.kind || "fallback"][state.tag];
              } else {
                type = null;
                typeList = state.typeMap.multi[state.kind || "fallback"];
                for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
                  if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
                    type = typeList[typeIndex];
                    break;
                  }
                }
              }
              if (!type) {
                throwError(state, "unknown tag !<" + state.tag + ">");
              }
              if (state.result !== null && type.kind !== state.kind) {
                throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
              }
              if (!type.resolve(state.result, state.tag)) {
                throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
              } else {
                state.result = type.construct(state.result, state.tag);
                if (state.anchor !== null) {
                  state.anchorMap[state.anchor] = state.result;
                }
              }
            }
            if (state.listener !== null) {
              state.listener("close", state);
            }
            return state.tag !== null || state.anchor !== null || hasContent;
          }
          function readDocument(state) {
            var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
            state.version = null;
            state.checkLineBreaks = state.legacy;
            state.tagMap = /* @__PURE__ */ Object.create(null);
            state.anchorMap = /* @__PURE__ */ Object.create(null);
            while ((ch = state.input.charCodeAt(state.position)) !== 0) {
              skipSeparationSpace(state, true, -1);
              ch = state.input.charCodeAt(state.position);
              if (state.lineIndent > 0 || ch !== 37) {
                break;
              }
              hasDirectives = true;
              ch = state.input.charCodeAt(++state.position);
              _position = state.position;
              while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
              }
              directiveName = state.input.slice(_position, state.position);
              directiveArgs = [];
              if (directiveName.length < 1) {
                throwError(state, "directive name must not be less than one character in length");
              }
              while (ch !== 0) {
                while (is_WHITE_SPACE(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                if (ch === 35) {
                  do {
                    ch = state.input.charCodeAt(++state.position);
                  } while (ch !== 0 && !is_EOL(ch));
                  break;
                }
                if (is_EOL(ch)) break;
                _position = state.position;
                while (ch !== 0 && !is_WS_OR_EOL(ch)) {
                  ch = state.input.charCodeAt(++state.position);
                }
                directiveArgs.push(state.input.slice(_position, state.position));
              }
              if (ch !== 0) readLineBreak(state);
              if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
                directiveHandlers[directiveName](state, directiveName, directiveArgs);
              } else {
                throwWarning(state, 'unknown document directive "' + directiveName + '"');
              }
            }
            skipSeparationSpace(state, true, -1);
            if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
              state.position += 3;
              skipSeparationSpace(state, true, -1);
            } else if (hasDirectives) {
              throwError(state, "directives end mark is expected");
            }
            composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
            skipSeparationSpace(state, true, -1);
            if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
              throwWarning(state, "non-ASCII line breaks are interpreted as content");
            }
            state.documents.push(state.result);
            if (state.position === state.lineStart && testDocumentSeparator(state)) {
              if (state.input.charCodeAt(state.position) === 46) {
                state.position += 3;
                skipSeparationSpace(state, true, -1);
              }
              return;
            }
            if (state.position < state.length - 1) {
              throwError(state, "end of the stream or a document separator is expected");
            } else {
              return;
            }
          }
          function loadDocuments(input, options) {
            input = String(input);
            options = options || {};
            if (input.length !== 0) {
              if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
                input += "\n";
              }
              if (input.charCodeAt(0) === 65279) {
                input = input.slice(1);
              }
            }
            var state = new State(input, options);
            var nullpos = input.indexOf("\0");
            if (nullpos !== -1) {
              state.position = nullpos;
              throwError(state, "null byte is not allowed in input");
            }
            state.input += "\0";
            while (state.input.charCodeAt(state.position) === 32) {
              state.lineIndent += 1;
              state.position += 1;
            }
            while (state.position < state.length - 1) {
              readDocument(state);
            }
            return state.documents;
          }
          function loadAll(input, iterator, options) {
            if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
              options = iterator;
              iterator = null;
            }
            var documents = loadDocuments(input, options);
            if (typeof iterator !== "function") {
              return documents;
            }
            for (var index = 0, length = documents.length; index < length; index += 1) {
              iterator(documents[index]);
            }
          }
          function load(input, options) {
            var documents = loadDocuments(input, options);
            if (documents.length === 0) {
              return void 0;
            } else if (documents.length === 1) {
              return documents[0];
            }
            throw new YAMLException("expected a single document in the stream, but found more");
          }
          module3.exports.loadAll = loadAll;
          module3.exports.load = load;
        }, { "./common": 202, "./exception": 204, "./schema/default": 208, "./snippet": 211 }], 206: [function(require2, module3, exports3) {
          var YAMLException = require2("./exception");
          var Type = require2("./type");
          function compileList(schema, name) {
            var result = [];
            schema[name].forEach(function(currentType) {
              var newIndex = result.length;
              result.forEach(function(previousType, previousIndex) {
                if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
                  newIndex = previousIndex;
                }
              });
              result[newIndex] = currentType;
            });
            return result;
          }
          function compileMap() {
            var result = {
              scalar: {},
              sequence: {},
              mapping: {},
              fallback: {},
              multi: {
                scalar: [],
                sequence: [],
                mapping: [],
                fallback: []
              }
            }, index, length;
            function collectType(type) {
              if (type.multi) {
                result.multi[type.kind].push(type);
                result.multi["fallback"].push(type);
              } else {
                result[type.kind][type.tag] = result["fallback"][type.tag] = type;
              }
            }
            for (index = 0, length = arguments.length; index < length; index += 1) {
              arguments[index].forEach(collectType);
            }
            return result;
          }
          function Schema(definition) {
            return this.extend(definition);
          }
          Schema.prototype.extend = function extend(definition) {
            var implicit = [];
            var explicit = [];
            if (definition instanceof Type) {
              explicit.push(definition);
            } else if (Array.isArray(definition)) {
              explicit = explicit.concat(definition);
            } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
              if (definition.implicit) implicit = implicit.concat(definition.implicit);
              if (definition.explicit) explicit = explicit.concat(definition.explicit);
            } else {
              throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
            }
            implicit.forEach(function(type) {
              if (!(type instanceof Type)) {
                throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
              }
              if (type.loadKind && type.loadKind !== "scalar") {
                throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
              }
              if (type.multi) {
                throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
              }
            });
            explicit.forEach(function(type) {
              if (!(type instanceof Type)) {
                throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
              }
            });
            var result = Object.create(Schema.prototype);
            result.implicit = (this.implicit || []).concat(implicit);
            result.explicit = (this.explicit || []).concat(explicit);
            result.compiledImplicit = compileList(result, "implicit");
            result.compiledExplicit = compileList(result, "explicit");
            result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
            return result;
          };
          module3.exports = Schema;
        }, { "./exception": 204, "./type": 212 }], 207: [function(require2, module3, exports3) {
          module3.exports = require2("./json");
        }, { "./json": 210 }], 208: [function(require2, module3, exports3) {
          module3.exports = require2("./core").extend({
            implicit: [
              require2("../type/timestamp"),
              require2("../type/merge")
            ],
            explicit: [
              require2("../type/binary"),
              require2("../type/omap"),
              require2("../type/pairs"),
              require2("../type/set")
            ]
          });
        }, { "../type/binary": 213, "../type/merge": 218, "../type/omap": 220, "../type/pairs": 221, "../type/set": 223, "../type/timestamp": 225, "./core": 207 }], 209: [function(require2, module3, exports3) {
          var Schema = require2("../schema");
          module3.exports = new Schema({
            explicit: [
              require2("../type/str"),
              require2("../type/seq"),
              require2("../type/map")
            ]
          });
        }, { "../schema": 206, "../type/map": 217, "../type/seq": 222, "../type/str": 224 }], 210: [function(require2, module3, exports3) {
          module3.exports = require2("./failsafe").extend({
            implicit: [
              require2("../type/null"),
              require2("../type/bool"),
              require2("../type/int"),
              require2("../type/float")
            ]
          });
        }, { "../type/bool": 214, "../type/float": 215, "../type/int": 216, "../type/null": 219, "./failsafe": 209 }], 211: [function(require2, module3, exports3) {
          var common = require2("./common");
          function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
            var head = "";
            var tail = "";
            var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
            if (position - lineStart > maxHalfLength) {
              head = " ... ";
              lineStart = position - maxHalfLength + head.length;
            }
            if (lineEnd - position > maxHalfLength) {
              tail = " ...";
              lineEnd = position + maxHalfLength - tail.length;
            }
            return {
              str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "→") + tail,
              pos: position - lineStart + head.length
              // relative position
            };
          }
          function padStart(string, max) {
            return common.repeat(" ", max - string.length) + string;
          }
          function makeSnippet(mark, options) {
            options = Object.create(options || null);
            if (!mark.buffer) return null;
            if (!options.maxLength) options.maxLength = 79;
            if (typeof options.indent !== "number") options.indent = 1;
            if (typeof options.linesBefore !== "number") options.linesBefore = 3;
            if (typeof options.linesAfter !== "number") options.linesAfter = 2;
            var re2 = /\r?\n|\r|\0/g;
            var lineStarts = [0];
            var lineEnds = [];
            var match;
            var foundLineNo = -1;
            while (match = re2.exec(mark.buffer)) {
              lineEnds.push(match.index);
              lineStarts.push(match.index + match[0].length);
              if (mark.position <= match.index && foundLineNo < 0) {
                foundLineNo = lineStarts.length - 2;
              }
            }
            if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
            var result = "", i2, line;
            var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
            var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
            for (i2 = 1; i2 <= options.linesBefore; i2++) {
              if (foundLineNo - i2 < 0) break;
              line = getLine(
                mark.buffer,
                lineStarts[foundLineNo - i2],
                lineEnds[foundLineNo - i2],
                mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
                maxLineLength
              );
              result = common.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
            }
            line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
            result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
            result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
            for (i2 = 1; i2 <= options.linesAfter; i2++) {
              if (foundLineNo + i2 >= lineEnds.length) break;
              line = getLine(
                mark.buffer,
                lineStarts[foundLineNo + i2],
                lineEnds[foundLineNo + i2],
                mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
                maxLineLength
              );
              result += common.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
            }
            return result.replace(/\n$/, "");
          }
          module3.exports = makeSnippet;
        }, { "./common": 202 }], 212: [function(require2, module3, exports3) {
          var YAMLException = require2("./exception");
          var TYPE_CONSTRUCTOR_OPTIONS = [
            "kind",
            "multi",
            "resolve",
            "construct",
            "instanceOf",
            "predicate",
            "represent",
            "representName",
            "defaultStyle",
            "styleAliases"
          ];
          var YAML_NODE_KINDS = [
            "scalar",
            "sequence",
            "mapping"
          ];
          function compileStyleAliases(map) {
            var result = {};
            if (map !== null) {
              Object.keys(map).forEach(function(style) {
                map[style].forEach(function(alias) {
                  result[String(alias)] = style;
                });
              });
            }
            return result;
          }
          function Type(tag, options) {
            options = options || {};
            Object.keys(options).forEach(function(name) {
              if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
                throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
              }
            });
            this.options = options;
            this.tag = tag;
            this.kind = options["kind"] || null;
            this.resolve = options["resolve"] || function() {
              return true;
            };
            this.construct = options["construct"] || function(data) {
              return data;
            };
            this.instanceOf = options["instanceOf"] || null;
            this.predicate = options["predicate"] || null;
            this.represent = options["represent"] || null;
            this.representName = options["representName"] || null;
            this.defaultStyle = options["defaultStyle"] || null;
            this.multi = options["multi"] || false;
            this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
            if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
              throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
            }
          }
          module3.exports = Type;
        }, { "./exception": 204 }], 213: [function(require2, module3, exports3) {
          var Type = require2("../type");
          var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
          function resolveYamlBinary(data) {
            if (data === null) return false;
            var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
            for (idx = 0; idx < max; idx++) {
              code = map.indexOf(data.charAt(idx));
              if (code > 64) continue;
              if (code < 0) return false;
              bitlen += 6;
            }
            return bitlen % 8 === 0;
          }
          function constructYamlBinary(data) {
            var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
            for (idx = 0; idx < max; idx++) {
              if (idx % 4 === 0 && idx) {
                result.push(bits >> 16 & 255);
                result.push(bits >> 8 & 255);
                result.push(bits & 255);
              }
              bits = bits << 6 | map.indexOf(input.charAt(idx));
            }
            tailbits = max % 4 * 6;
            if (tailbits === 0) {
              result.push(bits >> 16 & 255);
              result.push(bits >> 8 & 255);
              result.push(bits & 255);
            } else if (tailbits === 18) {
              result.push(bits >> 10 & 255);
              result.push(bits >> 2 & 255);
            } else if (tailbits === 12) {
              result.push(bits >> 4 & 255);
            }
            return new Uint8Array(result);
          }
          function representYamlBinary(object) {
            var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
            for (idx = 0; idx < max; idx++) {
              if (idx % 3 === 0 && idx) {
                result += map[bits >> 18 & 63];
                result += map[bits >> 12 & 63];
                result += map[bits >> 6 & 63];
                result += map[bits & 63];
              }
              bits = (bits << 8) + object[idx];
            }
            tail = max % 3;
            if (tail === 0) {
              result += map[bits >> 18 & 63];
              result += map[bits >> 12 & 63];
              result += map[bits >> 6 & 63];
              result += map[bits & 63];
            } else if (tail === 2) {
              result += map[bits >> 10 & 63];
              result += map[bits >> 4 & 63];
              result += map[bits << 2 & 63];
              result += map[64];
            } else if (tail === 1) {
              result += map[bits >> 2 & 63];
              result += map[bits << 4 & 63];
              result += map[64];
              result += map[64];
            }
            return result;
          }
          function isBinary(obj) {
            return Object.prototype.toString.call(obj) === "[object Uint8Array]";
          }
          module3.exports = new Type("tag:yaml.org,2002:binary", {
            kind: "scalar",
            resolve: resolveYamlBinary,
            construct: constructYamlBinary,
            predicate: isBinary,
            represent: representYamlBinary
          });
        }, { "../type": 212 }], 214: [function(require2, module3, exports3) {
          var Type = require2("../type");
          function resolveYamlBoolean(data) {
            if (data === null) return false;
            var max = data.length;
            return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
          }
          function constructYamlBoolean(data) {
            return data === "true" || data === "True" || data === "TRUE";
          }
          function isBoolean(object) {
            return Object.prototype.toString.call(object) === "[object Boolean]";
          }
          module3.exports = new Type("tag:yaml.org,2002:bool", {
            kind: "scalar",
            resolve: resolveYamlBoolean,
            construct: constructYamlBoolean,
            predicate: isBoolean,
            represent: {
              lowercase: function(object) {
                return object ? "true" : "false";
              },
              uppercase: function(object) {
                return object ? "TRUE" : "FALSE";
              },
              camelcase: function(object) {
                return object ? "True" : "False";
              }
            },
            defaultStyle: "lowercase"
          });
        }, { "../type": 212 }], 215: [function(require2, module3, exports3) {
          var common = require2("../common");
          var Type = require2("../type");
          var YAML_FLOAT_PATTERN = new RegExp(
            // 2.5e4, 2.5 and integers
            "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
          );
          function resolveYamlFloat(data) {
            if (data === null) return false;
            if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
            // Probably should update regexp & check speed
            data[data.length - 1] === "_") {
              return false;
            }
            return true;
          }
          function constructYamlFloat(data) {
            var value, sign;
            value = data.replace(/_/g, "").toLowerCase();
            sign = value[0] === "-" ? -1 : 1;
            if ("+-".indexOf(value[0]) >= 0) {
              value = value.slice(1);
            }
            if (value === ".inf") {
              return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
            } else if (value === ".nan") {
              return NaN;
            }
            return sign * parseFloat(value, 10);
          }
          var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
          function representYamlFloat(object, style) {
            var res;
            if (isNaN(object)) {
              switch (style) {
                case "lowercase":
                  return ".nan";
                case "uppercase":
                  return ".NAN";
                case "camelcase":
                  return ".NaN";
              }
            } else if (Number.POSITIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return ".inf";
                case "uppercase":
                  return ".INF";
                case "camelcase":
                  return ".Inf";
              }
            } else if (Number.NEGATIVE_INFINITY === object) {
              switch (style) {
                case "lowercase":
                  return "-.inf";
                case "uppercase":
                  return "-.INF";
                case "camelcase":
                  return "-.Inf";
              }
            } else if (common.isNegativeZero(object)) {
              return "-0.0";
            }
            res = object.toString(10);
            return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
          }
          function isFloat(object) {
            return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
          }
          module3.exports = new Type("tag:yaml.org,2002:float", {
            kind: "scalar",
            resolve: resolveYamlFloat,
            construct: constructYamlFloat,
            predicate: isFloat,
            represent: representYamlFloat,
            defaultStyle: "lowercase"
          });
        }, { "../common": 202, "../type": 212 }], 216: [function(require2, module3, exports3) {
          var common = require2("../common");
          var Type = require2("../type");
          function isHexCode(c2) {
            return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
          }
          function isOctCode(c2) {
            return 48 <= c2 && c2 <= 55;
          }
          function isDecCode(c2) {
            return 48 <= c2 && c2 <= 57;
          }
          function resolveYamlInteger(data) {
            if (data === null) return false;
            var max = data.length, index = 0, hasDigits = false, ch;
            if (!max) return false;
            ch = data[index];
            if (ch === "-" || ch === "+") {
              ch = data[++index];
            }
            if (ch === "0") {
              if (index + 1 === max) return true;
              ch = data[++index];
              if (ch === "b") {
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (ch !== "0" && ch !== "1") return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
              if (ch === "x") {
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (!isHexCode(data.charCodeAt(index))) return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
              if (ch === "o") {
                index++;
                for (; index < max; index++) {
                  ch = data[index];
                  if (ch === "_") continue;
                  if (!isOctCode(data.charCodeAt(index))) return false;
                  hasDigits = true;
                }
                return hasDigits && ch !== "_";
              }
            }
            if (ch === "_") return false;
            for (; index < max; index++) {
              ch = data[index];
              if (ch === "_") continue;
              if (!isDecCode(data.charCodeAt(index))) {
                return false;
              }
              hasDigits = true;
            }
            if (!hasDigits || ch === "_") return false;
            return true;
          }
          function constructYamlInteger(data) {
            var value = data, sign = 1, ch;
            if (value.indexOf("_") !== -1) {
              value = value.replace(/_/g, "");
            }
            ch = value[0];
            if (ch === "-" || ch === "+") {
              if (ch === "-") sign = -1;
              value = value.slice(1);
              ch = value[0];
            }
            if (value === "0") return 0;
            if (ch === "0") {
              if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
              if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
              if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
            }
            return sign * parseInt(value, 10);
          }
          function isInteger(object) {
            return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
          }
          module3.exports = new Type("tag:yaml.org,2002:int", {
            kind: "scalar",
            resolve: resolveYamlInteger,
            construct: constructYamlInteger,
            predicate: isInteger,
            represent: {
              binary: function(obj) {
                return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
              },
              octal: function(obj) {
                return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
              },
              decimal: function(obj) {
                return obj.toString(10);
              },
              /* eslint-disable max-len */
              hexadecimal: function(obj) {
                return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
              }
            },
            defaultStyle: "decimal",
            styleAliases: {
              binary: [2, "bin"],
              octal: [8, "oct"],
              decimal: [10, "dec"],
              hexadecimal: [16, "hex"]
            }
          });
        }, { "../common": 202, "../type": 212 }], 217: [function(require2, module3, exports3) {
          var Type = require2("../type");
          module3.exports = new Type("tag:yaml.org,2002:map", {
            kind: "mapping",
            construct: function(data) {
              return data !== null ? data : {};
            }
          });
        }, { "../type": 212 }], 218: [function(require2, module3, exports3) {
          var Type = require2("../type");
          function resolveYamlMerge(data) {
            return data === "<<" || data === null;
          }
          module3.exports = new Type("tag:yaml.org,2002:merge", {
            kind: "scalar",
            resolve: resolveYamlMerge
          });
        }, { "../type": 212 }], 219: [function(require2, module3, exports3) {
          var Type = require2("../type");
          function resolveYamlNull(data) {
            if (data === null) return true;
            var max = data.length;
            return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
          }
          function constructYamlNull() {
            return null;
          }
          function isNull(object) {
            return object === null;
          }
          module3.exports = new Type("tag:yaml.org,2002:null", {
            kind: "scalar",
            resolve: resolveYamlNull,
            construct: constructYamlNull,
            predicate: isNull,
            represent: {
              canonical: function() {
                return "~";
              },
              lowercase: function() {
                return "null";
              },
              uppercase: function() {
                return "NULL";
              },
              camelcase: function() {
                return "Null";
              },
              empty: function() {
                return "";
              }
            },
            defaultStyle: "lowercase"
          });
        }, { "../type": 212 }], 220: [function(require2, module3, exports3) {
          var Type = require2("../type");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var _toString = Object.prototype.toString;
          function resolveYamlOmap(data) {
            if (data === null) return true;
            var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              pairHasKey = false;
              if (_toString.call(pair) !== "[object Object]") return false;
              for (pairKey in pair) {
                if (_hasOwnProperty.call(pair, pairKey)) {
                  if (!pairHasKey) pairHasKey = true;
                  else return false;
                }
              }
              if (!pairHasKey) return false;
              if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
              else return false;
            }
            return true;
          }
          function constructYamlOmap(data) {
            return data !== null ? data : [];
          }
          module3.exports = new Type("tag:yaml.org,2002:omap", {
            kind: "sequence",
            resolve: resolveYamlOmap,
            construct: constructYamlOmap
          });
        }, { "../type": 212 }], 221: [function(require2, module3, exports3) {
          var Type = require2("../type");
          var _toString = Object.prototype.toString;
          function resolveYamlPairs(data) {
            if (data === null) return true;
            var index, length, pair, keys, result, object = data;
            result = new Array(object.length);
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              if (_toString.call(pair) !== "[object Object]") return false;
              keys = Object.keys(pair);
              if (keys.length !== 1) return false;
              result[index] = [keys[0], pair[keys[0]]];
            }
            return true;
          }
          function constructYamlPairs(data) {
            if (data === null) return [];
            var index, length, pair, keys, result, object = data;
            result = new Array(object.length);
            for (index = 0, length = object.length; index < length; index += 1) {
              pair = object[index];
              keys = Object.keys(pair);
              result[index] = [keys[0], pair[keys[0]]];
            }
            return result;
          }
          module3.exports = new Type("tag:yaml.org,2002:pairs", {
            kind: "sequence",
            resolve: resolveYamlPairs,
            construct: constructYamlPairs
          });
        }, { "../type": 212 }], 222: [function(require2, module3, exports3) {
          var Type = require2("../type");
          module3.exports = new Type("tag:yaml.org,2002:seq", {
            kind: "sequence",
            construct: function(data) {
              return data !== null ? data : [];
            }
          });
        }, { "../type": 212 }], 223: [function(require2, module3, exports3) {
          var Type = require2("../type");
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          function resolveYamlSet(data) {
            if (data === null) return true;
            var key, object = data;
            for (key in object) {
              if (_hasOwnProperty.call(object, key)) {
                if (object[key] !== null) return false;
              }
            }
            return true;
          }
          function constructYamlSet(data) {
            return data !== null ? data : {};
          }
          module3.exports = new Type("tag:yaml.org,2002:set", {
            kind: "mapping",
            resolve: resolveYamlSet,
            construct: constructYamlSet
          });
        }, { "../type": 212 }], 224: [function(require2, module3, exports3) {
          var Type = require2("../type");
          module3.exports = new Type("tag:yaml.org,2002:str", {
            kind: "scalar",
            construct: function(data) {
              return data !== null ? data : "";
            }
          });
        }, { "../type": 212 }], 225: [function(require2, module3, exports3) {
          var Type = require2("../type");
          var YAML_DATE_REGEXP = new RegExp(
            "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
          );
          var YAML_TIMESTAMP_REGEXP = new RegExp(
            "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
          );
          function resolveYamlTimestamp(data) {
            if (data === null) return false;
            if (YAML_DATE_REGEXP.exec(data) !== null) return true;
            if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
            return false;
          }
          function constructYamlTimestamp(data) {
            var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
            match = YAML_DATE_REGEXP.exec(data);
            if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
            if (match === null) throw new Error("Date resolve error");
            year = +match[1];
            month = +match[2] - 1;
            day = +match[3];
            if (!match[4]) {
              return new Date(Date.UTC(year, month, day));
            }
            hour = +match[4];
            minute = +match[5];
            second = +match[6];
            if (match[7]) {
              fraction = match[7].slice(0, 3);
              while (fraction.length < 3) {
                fraction += "0";
              }
              fraction = +fraction;
            }
            if (match[9]) {
              tz_hour = +match[10];
              tz_minute = +(match[11] || 0);
              delta = (tz_hour * 60 + tz_minute) * 6e4;
              if (match[9] === "-") delta = -delta;
            }
            date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
            if (delta) date.setTime(date.getTime() - delta);
            return date;
          }
          function representYamlTimestamp(object) {
            return object.toISOString();
          }
          module3.exports = new Type("tag:yaml.org,2002:timestamp", {
            kind: "scalar",
            resolve: resolveYamlTimestamp,
            construct: constructYamlTimestamp,
            instanceOf: Date,
            represent: representYamlTimestamp
          });
        }, { "../type": 212 }], 226: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var __assign = this && this.__assign || function() {
                __assign = Object.assign || function(t2) {
                  for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                    s2 = arguments[i2];
                    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
                      t2[p2] = s2[p2];
                  }
                  return t2;
                };
                return __assign.apply(this, arguments);
              };
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.format = void 0;
              var prettier_1 = typeof window !== "undefined" ? window["prettier"] : typeof global2 !== "undefined" ? global2["prettier"] : null;
              function format(code, options) {
                if (!options.format) {
                  return code;
                }
                return (0, prettier_1.format)(code, __assign({ parser: "typescript" }, options.style));
              }
              exports3.format = format;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 227: [function(require2, module3, exports3) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
              if (ar || !(i2 in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                ar[i2] = from[i2];
              }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.generateType = exports3.generate = void 0;
          var lodash_1 = require2("lodash");
          var index_1 = require2("./index");
          var AST_1 = require2("./types/AST");
          var utils_1 = require2("./utils");
          function generate(ast, options) {
            if (options === void 0) {
              options = index_1.DEFAULT_OPTIONS;
            }
            return [
              options.bannerComment,
              declareNamedTypes(ast, options, ast.standaloneName),
              declareNamedInterfaces(ast, options, ast.standaloneName),
              declareEnums(ast, options)
            ].filter(Boolean).join("\n\n") + "\n";
          }
          exports3.generate = generate;
          function declareEnums(ast, options, processed) {
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Set();
            }
            if (processed.has(ast)) {
              return "";
            }
            processed.add(ast);
            var type = "";
            switch (ast.type) {
              case "ENUM":
                return generateStandaloneEnum(ast, options) + "\n";
              case "ARRAY":
                return declareEnums(ast.params, options, processed);
              case "UNION":
              case "INTERSECTION":
                return ast.params.reduce(function(prev, ast2) {
                  return prev + declareEnums(ast2, options, processed);
                }, "");
              case "TUPLE":
                type = ast.params.reduce(function(prev, ast2) {
                  return prev + declareEnums(ast2, options, processed);
                }, "");
                if (ast.spreadParam) {
                  type += declareEnums(ast.spreadParam, options, processed);
                }
                return type;
              case "INTERFACE":
                return getSuperTypesAndParams(ast).reduce(function(prev, ast2) {
                  return prev + declareEnums(ast2, options, processed);
                }, "");
              default:
                return "";
            }
          }
          function declareNamedInterfaces(ast, options, rootASTName, processed) {
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Set();
            }
            if (processed.has(ast)) {
              return "";
            }
            processed.add(ast);
            var type = "";
            switch (ast.type) {
              case "ARRAY":
                type = declareNamedInterfaces(ast.params, options, rootASTName, processed);
                break;
              case "INTERFACE":
                type = [
                  (0, AST_1.hasStandaloneName)(ast) && (ast.standaloneName === rootASTName || options.declareExternallyReferenced) && generateStandaloneInterface(ast, options),
                  getSuperTypesAndParams(ast).map(function(ast2) {
                    return declareNamedInterfaces(ast2, options, rootASTName, processed);
                  }).filter(Boolean).join("\n")
                ].filter(Boolean).join("\n");
                break;
              case "INTERSECTION":
              case "TUPLE":
              case "UNION":
                type = ast.params.map(function(_2) {
                  return declareNamedInterfaces(_2, options, rootASTName, processed);
                }).filter(Boolean).join("\n");
                if (ast.type === "TUPLE" && ast.spreadParam) {
                  type += declareNamedInterfaces(ast.spreadParam, options, rootASTName, processed);
                }
                break;
              default:
                type = "";
            }
            return type;
          }
          function declareNamedTypes(ast, options, rootASTName, processed) {
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Set();
            }
            if (processed.has(ast)) {
              return "";
            }
            processed.add(ast);
            switch (ast.type) {
              case "ARRAY":
                return [
                  declareNamedTypes(ast.params, options, rootASTName, processed),
                  (0, AST_1.hasStandaloneName)(ast) ? generateStandaloneType(ast, options) : void 0
                ].filter(Boolean).join("\n");
              case "ENUM":
                return "";
              case "INTERFACE":
                return getSuperTypesAndParams(ast).map(function(ast2) {
                  return (ast2.standaloneName === rootASTName || options.declareExternallyReferenced) && declareNamedTypes(ast2, options, rootASTName, processed);
                }).filter(Boolean).join("\n");
              case "INTERSECTION":
              case "TUPLE":
              case "UNION":
                return [
                  (0, AST_1.hasStandaloneName)(ast) ? generateStandaloneType(ast, options) : void 0,
                  ast.params.map(function(ast2) {
                    return declareNamedTypes(ast2, options, rootASTName, processed);
                  }).filter(Boolean).join("\n"),
                  "spreadParam" in ast && ast.spreadParam ? declareNamedTypes(ast.spreadParam, options, rootASTName, processed) : void 0
                ].filter(Boolean).join("\n");
              default:
                if ((0, AST_1.hasStandaloneName)(ast)) {
                  return generateStandaloneType(ast, options);
                }
                return "";
            }
          }
          function generateTypeUnmemoized(ast, options) {
            var type = generateRawType(ast, options);
            if (options.strictIndexSignatures && ast.keyName === "[k: string]") {
              return "".concat(type, " | undefined");
            }
            return type;
          }
          exports3.generateType = (0, lodash_1.memoize)(generateTypeUnmemoized);
          function generateRawType(ast, options) {
            (0, utils_1.log)("magenta", "generator", ast);
            if ((0, AST_1.hasStandaloneName)(ast)) {
              return (0, utils_1.toSafeString)(ast.standaloneName);
            }
            switch (ast.type) {
              case "ANY":
                return "any";
              case "ARRAY":
                return function() {
                  var type = (0, exports3.generateType)(ast.params, options);
                  return type.endsWith('"') ? "(" + type + ")[]" : type + "[]";
                }();
              case "BOOLEAN":
                return "boolean";
              case "INTERFACE":
                return generateInterface(ast, options);
              case "INTERSECTION":
                return generateSetOperation(ast, options);
              case "LITERAL":
                return JSON.stringify(ast.params);
              case "NUMBER":
                return "number";
              case "NULL":
                return "null";
              case "OBJECT":
                return "object";
              case "REFERENCE":
                return ast.params;
              case "STRING":
                return "string";
              case "TUPLE":
                return function() {
                  var minItems = ast.minItems;
                  var maxItems = ast.maxItems || -1;
                  var spreadParam = ast.spreadParam;
                  var astParams = __spreadArray([], ast.params, true);
                  if (minItems > 0 && minItems > astParams.length && ast.spreadParam === void 0) {
                    if (maxItems < 0) {
                      spreadParam = options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY;
                    }
                  }
                  if (maxItems > astParams.length && ast.spreadParam === void 0) {
                    for (var i2 = astParams.length; i2 < maxItems; i2 += 1) {
                      astParams.push(options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY);
                    }
                  }
                  function addSpreadParam(params) {
                    if (spreadParam) {
                      var spread = "...(" + (0, exports3.generateType)(spreadParam, options) + ")[]";
                      params.push(spread);
                    }
                    return params;
                  }
                  function paramsToString(params) {
                    return "[" + params.join(", ") + "]";
                  }
                  var paramsList = astParams.map(function(param) {
                    return (0, exports3.generateType)(param, options);
                  });
                  if (paramsList.length > minItems) {
                    var cumulativeParamsList = paramsList.slice(0, minItems);
                    var typesToUnion = [];
                    if (cumulativeParamsList.length > 0) {
                      typesToUnion.push(paramsToString(cumulativeParamsList));
                    } else {
                      typesToUnion.push(paramsToString([]));
                    }
                    for (var i2 = minItems; i2 < paramsList.length; i2 += 1) {
                      cumulativeParamsList.push(paramsList[i2]);
                      if (i2 === paramsList.length - 1) {
                        addSpreadParam(cumulativeParamsList);
                      }
                      typesToUnion.push(paramsToString(cumulativeParamsList));
                    }
                    return typesToUnion.join("|");
                  }
                  return paramsToString(addSpreadParam(paramsList));
                }();
              case "UNION":
                return generateSetOperation(ast, options);
              case "UNKNOWN":
                return "unknown";
              case "CUSTOM_TYPE":
                return ast.params;
            }
          }
          function generateSetOperation(ast, options) {
            var members = ast.params.map(function(_2) {
              return (0, exports3.generateType)(_2, options);
            });
            var separator = ast.type === "UNION" ? "|" : "&";
            return members.length === 1 ? members[0] : "(" + members.join(" " + separator + " ") + ")";
          }
          function generateInterface(ast, options) {
            return "{\n" + ast.params.filter(function(_2) {
              return !_2.isPatternProperty && !_2.isUnreachableDefinition;
            }).map(function(_a) {
              var isRequired = _a.isRequired, keyName = _a.keyName, ast2 = _a.ast;
              return [isRequired, keyName, ast2, (0, exports3.generateType)(ast2, options)];
            }).map(function(_a) {
              var isRequired = _a[0], keyName = _a[1], ast2 = _a[2], type = _a[3];
              return ((0, AST_1.hasComment)(ast2) && !ast2.standaloneName ? generateComment(ast2.comment) + "\n" : "") + escapeKeyName(keyName) + (isRequired ? "" : "?") + ": " + ((0, AST_1.hasStandaloneName)(ast2) ? (0, utils_1.toSafeString)(type) : type);
            }).join("\n") + "\n}";
          }
          function generateComment(comment) {
            return __spreadArray(__spreadArray(["/**"], comment.split("\n").map(function(_2) {
              return " * " + _2;
            }), true), [" */"], false).join("\n");
          }
          function generateStandaloneEnum(ast, options) {
            return ((0, AST_1.hasComment)(ast) ? generateComment(ast.comment) + "\n" : "") + "export " + (options.enableConstEnums ? "const " : "") + "enum ".concat((0, utils_1.toSafeString)(ast.standaloneName), " {") + "\n" + ast.params.map(function(_a) {
              var ast2 = _a.ast, keyName = _a.keyName;
              return keyName + " = " + (0, exports3.generateType)(ast2, options);
            }).join(",\n") + "\n}";
          }
          function generateStandaloneInterface(ast, options) {
            return ((0, AST_1.hasComment)(ast) ? generateComment(ast.comment) + "\n" : "") + "export interface ".concat((0, utils_1.toSafeString)(ast.standaloneName), " ") + (ast.superTypes.length > 0 ? "extends ".concat(ast.superTypes.map(function(superType) {
              return (0, utils_1.toSafeString)(superType.standaloneName);
            }).join(", "), " ") : "") + generateInterface(ast, options);
          }
          function generateStandaloneType(ast, options) {
            return ((0, AST_1.hasComment)(ast) ? generateComment(ast.comment) + "\n" : "") + "export type ".concat((0, utils_1.toSafeString)(ast.standaloneName), " = ").concat((0, exports3.generateType)((0, lodash_1.omit)(ast, "standaloneName"), options));
          }
          function escapeKeyName(keyName) {
            if (keyName.length && /[A-Za-z_$]/.test(keyName.charAt(0)) && /^[\w$]+$/.test(keyName)) {
              return keyName;
            }
            if (keyName === "[k: string]") {
              return keyName;
            }
            return JSON.stringify(keyName);
          }
          function getSuperTypesAndParams(ast) {
            return ast.params.map(function(param) {
              return param.ast;
            }).concat(ast.superTypes);
          }
        }, { "./index": "json-schema-to-typescript", "./types/AST": 234, "./utils": 237, "lodash": 239 }], 228: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.link = void 0;
          var JSONSchema_1 = require2("./types/JSONSchema");
          var lodash_1 = require2("lodash");
          function link(schema, parent) {
            if (parent === void 0) {
              parent = null;
            }
            if (!Array.isArray(schema) && !(0, lodash_1.isPlainObject)(schema)) {
              return schema;
            }
            if (schema.hasOwnProperty(JSONSchema_1.Parent)) {
              return schema;
            }
            Object.defineProperty(schema, JSONSchema_1.Parent, {
              enumerable: false,
              value: parent,
              writable: false
            });
            if (Array.isArray(schema)) {
              schema.forEach(function(child) {
                return link(child, schema);
              });
            }
            for (var key in schema) {
              link(schema[key], schema);
            }
            return schema;
          }
          exports3.link = link;
        }, { "./types/JSONSchema": 235, "lodash": 239 }], 229: [function(require2, module3, exports3) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
              if (ar || !(i2 in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                ar[i2] = from[i2];
              }
            }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.normalize = void 0;
          var JSONSchema_1 = require2("./types/JSONSchema");
          var utils_1 = require2("./utils");
          var util_1 = require2("util");
          var rules = /* @__PURE__ */ new Map();
          function hasType(schema, type) {
            return schema.type === type || Array.isArray(schema.type) && schema.type.includes(type);
          }
          function isObjectType(schema) {
            return schema.properties !== void 0 || hasType(schema, "object") || hasType(schema, "any");
          }
          function isArrayType(schema) {
            return schema.items !== void 0 || hasType(schema, "array") || hasType(schema, "any");
          }
          rules.set('Remove `type=["null"]` if `enum=[null]`', function(schema) {
            if (Array.isArray(schema.enum) && schema.enum.some(function(e2) {
              return e2 === null;
            }) && Array.isArray(schema.type) && schema.type.includes("null")) {
              schema.type = schema.type.filter(function(type) {
                return type !== "null";
              });
            }
          });
          rules.set("Destructure unary types", function(schema) {
            if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
              schema.type = schema.type[0];
            }
          });
          rules.set("Add empty `required` property if none is defined", function(schema) {
            if (isObjectType(schema) && !("required" in schema)) {
              schema.required = [];
            }
          });
          rules.set("Transform `required`=false to `required`=[]", function(schema) {
            if (schema.required === false) {
              schema.required = [];
            }
          });
          rules.set("Default additionalProperties", function(schema, _2, options) {
            if (isObjectType(schema) && !("additionalProperties" in schema) && schema.patternProperties === void 0) {
              schema.additionalProperties = options.additionalProperties;
            }
          });
          rules.set("Transform id to $id", function(schema, fileName) {
            if (!(0, utils_1.isSchemaLike)(schema)) {
              return;
            }
            if (schema.id && schema.$id && schema.id !== schema.$id) {
              throw ReferenceError("Schema must define either id or $id, not both. Given id=".concat(schema.id, ", $id=").concat(schema.$id, " in ").concat(fileName));
            }
            if (schema.id) {
              schema.$id = schema.id;
              delete schema.id;
            }
          });
          rules.set("Add an $id to anything that needs it", function(schema, fileName, _options, _key, dereferencedPaths) {
            if (!(0, utils_1.isSchemaLike)(schema)) {
              return;
            }
            if (!schema.$id && !schema[JSONSchema_1.Parent]) {
              schema.$id = (0, utils_1.toSafeString)((0, utils_1.justName)(fileName));
              return;
            }
            if (!isArrayType(schema) && !isObjectType(schema)) {
              return;
            }
            var dereferencedName = dereferencedPaths.get(schema);
            if (!schema.$id && !schema.title && dereferencedName) {
              schema.$id = (0, utils_1.toSafeString)((0, utils_1.justName)(dereferencedName));
            }
            if (dereferencedName) {
              dereferencedPaths.delete(schema);
            }
          });
          rules.set("Escape closing JSDoc comment", function(schema) {
            (0, utils_1.escapeBlockComment)(schema);
          });
          rules.set("Add JSDoc comments for minItems and maxItems", function(schema) {
            if (!isArrayType(schema)) {
              return;
            }
            var commentsToAppend = [
              "minItems" in schema ? "@minItems ".concat(schema.minItems) : "",
              "maxItems" in schema ? "@maxItems ".concat(schema.maxItems) : ""
            ].filter(Boolean);
            if (commentsToAppend.length) {
              schema.description = utils_1.appendToDescription.apply(void 0, __spreadArray([schema.description], commentsToAppend, false));
            }
          });
          rules.set("Optionally remove maxItems and minItems", function(schema, _fileName, options) {
            if (!isArrayType(schema)) {
              return;
            }
            if ("minItems" in schema && options.ignoreMinAndMaxItems) {
              delete schema.minItems;
            }
            if ("maxItems" in schema && (options.ignoreMinAndMaxItems || options.maxItems === -1)) {
              delete schema.maxItems;
            }
          });
          rules.set("Normalize schema.minItems", function(schema, _fileName, options) {
            if (options.ignoreMinAndMaxItems) {
              return;
            }
            if (!isArrayType(schema)) {
              return;
            }
            var minItems = schema.minItems;
            schema.minItems = typeof minItems === "number" ? minItems : 0;
          });
          rules.set("Remove maxItems if it is big enough to likely cause OOMs", function(schema, _fileName, options) {
            if (options.ignoreMinAndMaxItems || options.maxItems === -1) {
              return;
            }
            if (!isArrayType(schema)) {
              return;
            }
            var maxItems = schema.maxItems, minItems = schema.minItems;
            if (maxItems !== void 0 && maxItems - minItems > options.maxItems) {
              delete schema.maxItems;
            }
          });
          rules.set("Normalize schema.items", function(schema, _fileName, options) {
            if (options.ignoreMinAndMaxItems) {
              return;
            }
            var maxItems = schema.maxItems, minItems = schema.minItems;
            var hasMaxItems = typeof maxItems === "number" && maxItems >= 0;
            var hasMinItems = typeof minItems === "number" && minItems > 0;
            if (schema.items && !Array.isArray(schema.items) && (hasMaxItems || hasMinItems)) {
              var items = schema.items;
              var newItems = Array(maxItems || minItems || 0).fill(items);
              if (!hasMaxItems) {
                schema.additionalItems = items;
              }
              schema.items = newItems;
            }
            if (Array.isArray(schema.items) && hasMaxItems && maxItems < schema.items.length) {
              schema.items = schema.items.slice(0, maxItems);
            }
            return schema;
          });
          rules.set("Remove extends, if it is empty", function(schema) {
            if (!schema.hasOwnProperty("extends")) {
              return;
            }
            if (schema.extends == null || Array.isArray(schema.extends) && schema.extends.length === 0) {
              delete schema.extends;
            }
          });
          rules.set("Make extends always an array, if it is defined", function(schema) {
            if (schema.extends == null) {
              return;
            }
            if (!Array.isArray(schema.extends)) {
              schema.extends = [schema.extends];
            }
          });
          rules.set("Transform definitions to $defs", function(schema, fileName) {
            if (schema.definitions && schema.$defs && !(0, util_1.isDeepStrictEqual)(schema.definitions, schema.$defs)) {
              throw ReferenceError("Schema must define either definitions or $defs, not both. Given id=".concat(schema.id, " in ").concat(fileName));
            }
            if (schema.definitions) {
              schema.$defs = schema.definitions;
              delete schema.definitions;
            }
          });
          rules.set("Transform const to singleton enum", function(schema) {
            if (schema.const !== void 0) {
              schema.enum = [schema.const];
              delete schema.const;
            }
          });
          function normalize(rootSchema, dereferencedPaths, filename, options) {
            rules.forEach(function(rule) {
              return (0, utils_1.traverse)(rootSchema, function(schema, key) {
                return rule(schema, filename, options, key, dereferencedPaths);
              });
            });
            return rootSchema;
          }
          exports3.normalize = normalize;
        }, { "./types/JSONSchema": 235, "./utils": 237, "util": 308 }], 230: [function(require2, module3, exports3) {
          var __assign = this && this.__assign || function() {
            __assign = Object.assign || function(t2) {
              for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                s2 = arguments[i2];
                for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
                  t2[p2] = s2[p2];
              }
              return t2;
            };
            return __assign.apply(this, arguments);
          };
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.optimize = void 0;
          var lodash_1 = require2("lodash");
          var generator_1 = require2("./generator");
          var AST_1 = require2("./types/AST");
          var utils_1 = require2("./utils");
          function optimize(ast, options, processed) {
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Set();
            }
            if (processed.has(ast)) {
              return ast;
            }
            processed.add(ast);
            switch (ast.type) {
              case "INTERFACE":
                return Object.assign(ast, {
                  params: ast.params.map(function(_2) {
                    return Object.assign(_2, { ast: optimize(_2.ast, options, processed) });
                  })
                });
              case "INTERSECTION":
              case "UNION":
                var optimizedAST_1 = Object.assign(ast, {
                  params: ast.params.map(function(_2) {
                    return optimize(_2, options, processed);
                  })
                });
                if (optimizedAST_1.params.some(function(_2) {
                  return _2.type === "ANY";
                })) {
                  (0, utils_1.log)("cyan", "optimizer", "[A, B, C, Any] -> Any", optimizedAST_1);
                  return AST_1.T_ANY;
                }
                if (optimizedAST_1.params.some(function(_2) {
                  return _2.type === "UNKNOWN";
                })) {
                  (0, utils_1.log)("cyan", "optimizer", "[A, B, C, Unknown] -> Unknown", optimizedAST_1);
                  return AST_1.T_UNKNOWN;
                }
                if (optimizedAST_1.params.every(function(_2) {
                  var a2 = (0, generator_1.generateType)(omitStandaloneName(_2), options);
                  var b2 = (0, generator_1.generateType)(omitStandaloneName(optimizedAST_1.params[0]), options);
                  return a2 === b2;
                }) && optimizedAST_1.params.some(function(_2) {
                  return _2.standaloneName !== void 0;
                })) {
                  (0, utils_1.log)("cyan", "optimizer", "[A (named), A] -> [A (named)]", optimizedAST_1);
                  optimizedAST_1.params = optimizedAST_1.params.filter(function(_2) {
                    return _2.standaloneName !== void 0;
                  });
                }
                var params = (0, lodash_1.uniqBy)(optimizedAST_1.params, function(_2) {
                  return (0, generator_1.generateType)(_2, options);
                });
                if (params.length !== optimizedAST_1.params.length) {
                  (0, utils_1.log)("cyan", "optimizer", "[A, B, B] -> [A, B]", optimizedAST_1);
                  optimizedAST_1.params = params;
                }
                return Object.assign(optimizedAST_1, {
                  params: optimizedAST_1.params.map(function(_2) {
                    return optimize(_2, options, processed);
                  })
                });
              default:
                return ast;
            }
          }
          exports3.optimize = optimize;
          function omitStandaloneName(ast) {
            switch (ast.type) {
              case "ENUM":
                return ast;
              default:
                return __assign(__assign({}, ast), { standaloneName: void 0 });
            }
          }
        }, { "./generator": 227, "./types/AST": 234, "./utils": 237, "lodash": 239 }], 231: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.validateOptions = void 0;
          function validateOptions(_a) {
            var maxItems = _a.maxItems;
            if (maxItems !== void 0 && maxItems < -1) {
              throw RangeError("Expected options.maxItems to be >= -1, but was given ".concat(maxItems, "."));
            }
          }
          exports3.validateOptions = validateOptions;
        }, {}], 232: [function(require2, module3, exports3) {
          var __assign = this && this.__assign || function() {
            __assign = Object.assign || function(t2) {
              for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                s2 = arguments[i2];
                for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
                  t2[p2] = s2[p2];
              }
              return t2;
            };
            return __assign.apply(this, arguments);
          };
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.parse = void 0;
          var lodash_1 = require2("lodash");
          var util_1 = require2("util");
          var typesOfSchema_1 = require2("./typesOfSchema");
          var AST_1 = require2("./types/AST");
          var JSONSchema_1 = require2("./types/JSONSchema");
          var utils_1 = require2("./utils");
          function parse(schema, options, keyName, processed, usedNames) {
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Map();
            }
            if (usedNames === void 0) {
              usedNames = /* @__PURE__ */ new Set();
            }
            if ((0, JSONSchema_1.isPrimitive)(schema)) {
              return parseLiteral(schema, keyName);
            }
            var types = (0, typesOfSchema_1.typesOfSchema)(schema);
            if (types.length === 1) {
              var ast_1 = parseAsTypeWithCache(schema, types[0], options, keyName, processed, usedNames);
              (0, utils_1.log)("blue", "parser", "Types:", types, "Input:", schema, "Output:", ast_1);
              return ast_1;
            }
            var ast = parseAsTypeWithCache({
              $id: schema.$id,
              allOf: [],
              description: schema.description,
              title: schema.title
            }, "ALL_OF", options, keyName, processed, usedNames);
            ast.params = types.map(function(type) {
              return parseAsTypeWithCache((0, utils_1.maybeStripNameHints)(schema), type, options, keyName, processed, usedNames);
            });
            (0, utils_1.log)("blue", "parser", "Types:", types, "Input:", schema, "Output:", ast);
            return ast;
          }
          exports3.parse = parse;
          function parseAsTypeWithCache(schema, type, options, keyName, processed, usedNames) {
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Map();
            }
            if (usedNames === void 0) {
              usedNames = /* @__PURE__ */ new Set();
            }
            var cachedTypeMap = processed.get(schema);
            if (!cachedTypeMap) {
              cachedTypeMap = /* @__PURE__ */ new Map();
              processed.set(schema, cachedTypeMap);
            }
            var cachedAST = cachedTypeMap.get(type);
            if (cachedAST) {
              return cachedAST;
            }
            var ast = {};
            cachedTypeMap.set(type, ast);
            return Object.assign(ast, parseNonLiteral(schema, type, options, keyName, processed, usedNames));
          }
          function parseLiteral(schema, keyName) {
            return {
              keyName,
              params: schema,
              type: "LITERAL"
            };
          }
          function parseNonLiteral(schema, type, options, keyName, processed, usedNames) {
            var definitions = getDefinitionsMemoized((0, JSONSchema_1.getRootSchema)(schema));
            var keyNameFromDefinition = (0, lodash_1.findKey)(definitions, function(_2) {
              return _2 === schema;
            });
            switch (type) {
              case "ALL_OF":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  params: schema.allOf.map(function(_2) {
                    return parse(_2, options, void 0, processed, usedNames);
                  }),
                  type: "INTERSECTION"
                };
              case "ANY":
                return __assign(__assign({}, options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY), { comment: schema.description, keyName, standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames) });
              case "ANY_OF":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  params: schema.anyOf.map(function(_2) {
                    return parse(_2, options, void 0, processed, usedNames);
                  }),
                  type: "UNION"
                };
              case "BOOLEAN":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "BOOLEAN"
                };
              case "CUSTOM_TYPE":
                return {
                  comment: schema.description,
                  keyName,
                  params: schema.tsType,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "CUSTOM_TYPE"
                };
              case "NAMED_ENUM":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition !== null && keyNameFromDefinition !== void 0 ? keyNameFromDefinition : keyName, usedNames),
                  params: schema.enum.map(function(_2, n2) {
                    return {
                      ast: parse(_2, options, void 0, processed, usedNames),
                      keyName: schema.tsEnumNames[n2]
                    };
                  }),
                  type: "ENUM"
                };
              case "NAMED_SCHEMA":
                return newInterface(schema, options, processed, usedNames, keyName);
              case "NULL":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "NULL"
                };
              case "NUMBER":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "NUMBER"
                };
              case "OBJECT":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "OBJECT"
                };
              case "ONE_OF":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  params: schema.oneOf.map(function(_2) {
                    return parse(_2, options, void 0, processed, usedNames);
                  }),
                  type: "UNION"
                };
              case "REFERENCE":
                throw Error((0, util_1.format)("Refs should have been resolved by the resolver!", schema));
              case "STRING":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "STRING"
                };
              case "TYPED_ARRAY":
                if (Array.isArray(schema.items)) {
                  var minItems_1 = schema.minItems;
                  var maxItems_1 = schema.maxItems;
                  var arrayType = {
                    comment: schema.description,
                    keyName,
                    maxItems: maxItems_1,
                    minItems: minItems_1,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                    params: schema.items.map(function(_2) {
                      return parse(_2, options, void 0, processed, usedNames);
                    }),
                    type: "TUPLE"
                  };
                  if (schema.additionalItems === true) {
                    arrayType.spreadParam = options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY;
                  } else if (schema.additionalItems) {
                    arrayType.spreadParam = parse(schema.additionalItems, options, void 0, processed, usedNames);
                  }
                  return arrayType;
                } else {
                  return {
                    comment: schema.description,
                    keyName,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                    params: parse(schema.items, options, void 0, processed, usedNames),
                    type: "ARRAY"
                  };
                }
              case "UNION":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  params: schema.type.map(function(type2) {
                    var member = __assign(__assign({}, (0, lodash_1.omit)(schema, "$id", "description", "title")), { type: type2 });
                    return parse((0, utils_1.maybeStripDefault)(member), options, void 0, processed, usedNames);
                  }),
                  type: "UNION"
                };
              case "UNNAMED_ENUM":
                return {
                  comment: schema.description,
                  keyName,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  params: schema.enum.map(function(_2) {
                    return parse(_2, options, void 0, processed, usedNames);
                  }),
                  type: "UNION"
                };
              case "UNNAMED_SCHEMA":
                return newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition);
              case "UNTYPED_ARRAY":
                var minItems = schema.minItems;
                var maxItems = typeof schema.maxItems === "number" ? schema.maxItems : -1;
                var params = options.unknownAny ? AST_1.T_UNKNOWN : AST_1.T_ANY;
                if (minItems > 0 || maxItems >= 0) {
                  return {
                    comment: schema.description,
                    keyName,
                    maxItems: schema.maxItems,
                    minItems,
                    // create a tuple of length N
                    params: Array(Math.max(maxItems, minItems) || 0).fill(params),
                    // if there is no maximum, then add a spread item to collect the rest
                    spreadParam: maxItems >= 0 ? void 0 : params,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                    type: "TUPLE"
                  };
                }
                return {
                  comment: schema.description,
                  keyName,
                  params,
                  standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                  type: "ARRAY"
                };
            }
          }
          function standaloneName(schema, keyNameFromDefinition, usedNames) {
            var name = schema.title || schema.$id || keyNameFromDefinition;
            if (name) {
              return (0, utils_1.generateName)(name, usedNames);
            }
          }
          function newInterface(schema, options, processed, usedNames, keyName, keyNameFromDefinition) {
            var name = standaloneName(schema, keyNameFromDefinition, usedNames);
            return {
              comment: schema.description,
              keyName,
              params: parseSchema(schema, options, processed, usedNames, name),
              standaloneName: name,
              superTypes: parseSuperTypes(schema, options, processed, usedNames),
              type: "INTERFACE"
            };
          }
          function parseSuperTypes(schema, options, processed, usedNames) {
            var superTypes = schema.extends;
            if (!superTypes) {
              return [];
            }
            return superTypes.map(function(_2) {
              return parse(_2, options, void 0, processed, usedNames);
            });
          }
          function parseSchema(schema, options, processed, usedNames, parentSchemaName) {
            var asts = (0, lodash_1.map)(schema.properties, function(value, key) {
              return {
                ast: parse(value, options, key, processed, usedNames),
                isPatternProperty: false,
                isRequired: (0, lodash_1.includes)(schema.required || [], key),
                isUnreachableDefinition: false,
                keyName: key
              };
            });
            var singlePatternProperty = false;
            if (schema.patternProperties) {
              singlePatternProperty = !schema.additionalProperties && Object.keys(schema.patternProperties).length === 1;
              asts = asts.concat((0, lodash_1.map)(schema.patternProperties, function(value, key) {
                var ast = parse(value, options, key, processed, usedNames);
                var comment = "This interface was referenced by `".concat(parentSchemaName, "`'s JSON-Schema definition\nvia the `patternProperty` \"").concat(key, '".');
                ast.comment = ast.comment ? "".concat(ast.comment, "\n\n").concat(comment) : comment;
                return {
                  ast,
                  isPatternProperty: !singlePatternProperty,
                  isRequired: singlePatternProperty || (0, lodash_1.includes)(schema.required || [], key),
                  isUnreachableDefinition: false,
                  keyName: singlePatternProperty ? "[k: string]" : key
                };
              }));
            }
            if (options.unreachableDefinitions) {
              asts = asts.concat((0, lodash_1.map)(schema.$defs, function(value, key) {
                var ast = parse(value, options, key, processed, usedNames);
                var comment = "This interface was referenced by `".concat(parentSchemaName, "`'s JSON-Schema\nvia the `definition` \"").concat(key, '".');
                ast.comment = ast.comment ? "".concat(ast.comment, "\n\n").concat(comment) : comment;
                return {
                  ast,
                  isPatternProperty: false,
                  isRequired: (0, lodash_1.includes)(schema.required || [], key),
                  isUnreachableDefinition: true,
                  keyName: key
                };
              }));
            }
            switch (schema.additionalProperties) {
              case void 0:
              case true:
                if (singlePatternProperty) {
                  return asts;
                }
                return asts.concat({
                  ast: options.unknownAny ? AST_1.T_UNKNOWN_ADDITIONAL_PROPERTIES : AST_1.T_ANY_ADDITIONAL_PROPERTIES,
                  isPatternProperty: false,
                  isRequired: true,
                  isUnreachableDefinition: false,
                  keyName: "[k: string]"
                });
              case false:
                return asts;
              // pass "true" as the last param because in TS, properties
              // defined via index signatures are already optional
              default:
                return asts.concat({
                  ast: parse(schema.additionalProperties, options, "[k: string]", processed, usedNames),
                  isPatternProperty: false,
                  isRequired: true,
                  isUnreachableDefinition: false,
                  keyName: "[k: string]"
                });
            }
          }
          function getDefinitions(schema, isSchema, processed) {
            if (isSchema === void 0) {
              isSchema = true;
            }
            if (processed === void 0) {
              processed = /* @__PURE__ */ new Set();
            }
            if (processed.has(schema)) {
              return {};
            }
            processed.add(schema);
            if (Array.isArray(schema)) {
              return schema.reduce(function(prev, cur) {
                return __assign(__assign({}, prev), getDefinitions(cur, false, processed));
              }, {});
            }
            if ((0, lodash_1.isPlainObject)(schema)) {
              return __assign(__assign({}, isSchema && hasDefinitions(schema) ? schema.$defs : {}), Object.keys(schema).reduce(function(prev, cur) {
                return __assign(__assign({}, prev), getDefinitions(schema[cur], false, processed));
              }, {}));
            }
            return {};
          }
          var getDefinitionsMemoized = (0, lodash_1.memoize)(getDefinitions);
          function hasDefinitions(schema) {
            return "$defs" in schema;
          }
        }, { "./types/AST": 234, "./types/JSONSchema": 235, "./typesOfSchema": 236, "./utils": 237, "lodash": 239, "util": 308 }], 233: [function(require2, module3, exports3) {
          var __assign = this && this.__assign || function() {
            __assign = Object.assign || function(t2) {
              for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                s2 = arguments[i2];
                for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
                  t2[p2] = s2[p2];
              }
              return t2;
            };
            return __assign.apply(this, arguments);
          };
          var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P2, generator) {
            function adopt(value) {
              return value instanceof P2 ? value : new P2(function(resolve) {
                resolve(value);
              });
            }
            return new (P2 || (P2 = Promise))(function(resolve, reject) {
              function fulfilled(value) {
                try {
                  step(generator.next(value));
                } catch (e2) {
                  reject(e2);
                }
              }
              function rejected(value) {
                try {
                  step(generator["throw"](value));
                } catch (e2) {
                  reject(e2);
                }
              }
              function step(result) {
                result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
              }
              step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
          };
          var __generator = this && this.__generator || function(thisArg, body) {
            var _2 = { label: 0, sent: function() {
              if (t2[0] & 1) throw t2[1];
              return t2[1];
            }, trys: [], ops: [] }, f2, y2, t2, g2;
            return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
              return this;
            }), g2;
            function verb(n2) {
              return function(v2) {
                return step([n2, v2]);
              };
            }
            function step(op) {
              if (f2) throw new TypeError("Generator is already executing.");
              while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
                if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
                if (y2 = 0, t2) op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _2.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _2.label++;
                    y2 = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _2.ops.pop();
                    _2.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _2 = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _2.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _2.label < t2[1]) {
                      _2.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _2.label < t2[2]) {
                      _2.label = t2[2];
                      _2.ops.push(op);
                      break;
                    }
                    if (t2[2]) _2.ops.pop();
                    _2.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _2);
              } catch (e2) {
                op = [6, e2];
                y2 = 0;
              } finally {
                f2 = t2 = 0;
              }
              if (op[0] & 5) throw op[1];
              return { value: op[0] ? op[1] : void 0, done: true };
            }
          };
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.dereference = void 0;
          var $RefParser = require2("@bcherny/json-schema-ref-parser");
          var utils_1 = require2("./utils");
          function dereference(schema, _a) {
            var cwd = _a.cwd, $refOptions = _a.$refOptions;
            return __awaiter(this, void 0, void 0, function() {
              var parser, dereferencedPaths, dereferencedSchema;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    (0, utils_1.log)("green", "dereferencer", "Dereferencing input schema:", cwd, schema);
                    parser = new $RefParser();
                    dereferencedPaths = /* @__PURE__ */ new WeakMap();
                    return [4, parser.dereference(cwd, schema, __assign(__assign({}, $refOptions), { dereference: __assign(__assign({}, $refOptions.dereference), { onDereference: function($ref, schema2) {
                      dereferencedPaths.set(schema2, $ref);
                    } }) }))];
                  case 1:
                    dereferencedSchema = _b.sent();
                    return [2, { dereferencedPaths, dereferencedSchema }];
                }
              });
            });
          }
          exports3.dereference = dereference;
        }, { "./utils": 237, "@bcherny/json-schema-ref-parser": 3 }], 234: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.T_UNKNOWN_ADDITIONAL_PROPERTIES = exports3.T_UNKNOWN = exports3.T_ANY_ADDITIONAL_PROPERTIES = exports3.T_ANY = exports3.hasStandaloneName = exports3.hasComment = void 0;
          function hasComment(ast) {
            return "comment" in ast && ast.comment != null && ast.comment !== "";
          }
          exports3.hasComment = hasComment;
          function hasStandaloneName(ast) {
            return "standaloneName" in ast && ast.standaloneName != null && ast.standaloneName !== "";
          }
          exports3.hasStandaloneName = hasStandaloneName;
          exports3.T_ANY = {
            type: "ANY"
          };
          exports3.T_ANY_ADDITIONAL_PROPERTIES = {
            keyName: "[k: string]",
            type: "ANY"
          };
          exports3.T_UNKNOWN = {
            type: "UNKNOWN"
          };
          exports3.T_UNKNOWN_ADDITIONAL_PROPERTIES = {
            keyName: "[k: string]",
            type: "UNKNOWN"
          };
        }, {}], 235: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.isCompound = exports3.isPrimitive = exports3.getRootSchema = exports3.Parent = void 0;
          var lodash_1 = require2("lodash");
          exports3.Parent = Symbol("Parent");
          exports3.getRootSchema = (0, lodash_1.memoize)(function(schema) {
            var parent = schema[exports3.Parent];
            if (!parent) {
              return schema;
            }
            return (0, exports3.getRootSchema)(parent);
          });
          function isPrimitive2(schema) {
            return !(0, lodash_1.isPlainObject)(schema);
          }
          exports3.isPrimitive = isPrimitive2;
          function isCompound(schema) {
            return Array.isArray(schema.type) || "anyOf" in schema || "oneOf" in schema;
          }
          exports3.isCompound = isCompound;
        }, { "lodash": 239 }], 236: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.typesOfSchema = void 0;
          var lodash_1 = require2("lodash");
          var JSONSchema_1 = require2("./types/JSONSchema");
          function typesOfSchema(schema) {
            if (schema.tsType) {
              return ["CUSTOM_TYPE"];
            }
            var matchedTypes = [];
            for (var _i = 0, _a = Object.entries(matchers); _i < _a.length; _i++) {
              var _b = _a[_i], schemaType = _b[0], f2 = _b[1];
              if (f2(schema)) {
                matchedTypes.push(schemaType);
              }
            }
            if (!matchedTypes.length) {
              return ["UNNAMED_SCHEMA"];
            }
            return matchedTypes;
          }
          exports3.typesOfSchema = typesOfSchema;
          var matchers = {
            ALL_OF: function(schema) {
              return "allOf" in schema;
            },
            ANY: function(schema) {
              if (Object.keys(schema).length === 0) {
                return true;
              }
              return schema.type === "any";
            },
            ANY_OF: function(schema) {
              return "anyOf" in schema;
            },
            BOOLEAN: function(schema) {
              if ("enum" in schema) {
                return false;
              }
              if (schema.type === "boolean") {
                return true;
              }
              if (!(0, JSONSchema_1.isCompound)(schema) && typeof schema.default === "boolean") {
                return true;
              }
              return false;
            },
            CUSTOM_TYPE: function() {
              return false;
            },
            NAMED_ENUM: function(schema) {
              return "enum" in schema && "tsEnumNames" in schema;
            },
            NAMED_SCHEMA: function(schema) {
              return "$id" in schema && ("patternProperties" in schema || "properties" in schema);
            },
            NULL: function(schema) {
              return schema.type === "null";
            },
            NUMBER: function(schema) {
              if ("enum" in schema) {
                return false;
              }
              if (schema.type === "integer" || schema.type === "number") {
                return true;
              }
              if (!(0, JSONSchema_1.isCompound)(schema) && typeof schema.default === "number") {
                return true;
              }
              return false;
            },
            OBJECT: function(schema) {
              return schema.type === "object" && !(0, lodash_1.isPlainObject)(schema.additionalProperties) && !schema.allOf && !schema.anyOf && !schema.oneOf && !schema.patternProperties && !schema.properties && !schema.required;
            },
            ONE_OF: function(schema) {
              return "oneOf" in schema;
            },
            REFERENCE: function(schema) {
              return "$ref" in schema;
            },
            STRING: function(schema) {
              if ("enum" in schema) {
                return false;
              }
              if (schema.type === "string") {
                return true;
              }
              if (!(0, JSONSchema_1.isCompound)(schema) && typeof schema.default === "string") {
                return true;
              }
              return false;
            },
            TYPED_ARRAY: function(schema) {
              if (schema.type && schema.type !== "array") {
                return false;
              }
              return "items" in schema;
            },
            UNION: function(schema) {
              return Array.isArray(schema.type);
            },
            UNNAMED_ENUM: function(schema) {
              if ("tsEnumNames" in schema) {
                return false;
              }
              if (schema.type && schema.type !== "boolean" && schema.type !== "integer" && schema.type !== "number" && schema.type !== "string") {
                return false;
              }
              return "enum" in schema;
            },
            UNNAMED_SCHEMA: function() {
              return false;
            },
            UNTYPED_ARRAY: function(schema) {
              return schema.type === "array" && !("items" in schema);
            }
          };
        }, { "./types/JSONSchema": 235, "lodash": 239 }], 237: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
                  if (ar || !(i2 in from)) {
                    if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
                    ar[i2] = from[i2];
                  }
                }
                return to.concat(ar || Array.prototype.slice.call(from));
              };
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.isSchemaLike = exports3.appendToDescription = exports3.maybeStripNameHints = exports3.maybeStripDefault = exports3.pathTransform = exports3.escapeBlockComment = exports3.log = exports3.error = exports3.generateName = exports3.toSafeString = exports3.stripExtension = exports3.justName = exports3.traverse = exports3.Try = void 0;
              var lodash_1 = require2("lodash");
              var path_1 = require2("path");
              var JSONSchema_1 = require2("./types/JSONSchema");
              function Try(fn, err) {
                try {
                  return fn();
                } catch (e2) {
                  return err(e2);
                }
              }
              exports3.Try = Try;
              var BLACKLISTED_KEYS = /* @__PURE__ */ new Set([
                "id",
                "$defs",
                "$id",
                "$schema",
                "title",
                "description",
                "default",
                "multipleOf",
                "maximum",
                "exclusiveMaximum",
                "minimum",
                "exclusiveMinimum",
                "maxLength",
                "minLength",
                "pattern",
                "additionalItems",
                "items",
                "maxItems",
                "minItems",
                "uniqueItems",
                "maxProperties",
                "minProperties",
                "required",
                "additionalProperties",
                "definitions",
                "properties",
                "patternProperties",
                "dependencies",
                "enum",
                "type",
                "allOf",
                "anyOf",
                "oneOf",
                "not"
              ]);
              function traverseObjectKeys(obj, callback, processed) {
                Object.keys(obj).forEach(function(k2) {
                  if (obj[k2] && typeof obj[k2] === "object" && !Array.isArray(obj[k2])) {
                    traverse(obj[k2], callback, processed, k2);
                  }
                });
              }
              function traverseArray(arr, callback, processed) {
                arr.forEach(function(s2, k2) {
                  return traverse(s2, callback, processed, k2.toString());
                });
              }
              function traverse(schema, callback, processed, key) {
                if (processed === void 0) {
                  processed = /* @__PURE__ */ new Set();
                }
                if (processed.has(schema)) {
                  return;
                }
                processed.add(schema);
                callback(schema, key !== null && key !== void 0 ? key : null);
                if (schema.anyOf) {
                  traverseArray(schema.anyOf, callback, processed);
                }
                if (schema.allOf) {
                  traverseArray(schema.allOf, callback, processed);
                }
                if (schema.oneOf) {
                  traverseArray(schema.oneOf, callback, processed);
                }
                if (schema.properties) {
                  traverseObjectKeys(schema.properties, callback, processed);
                }
                if (schema.patternProperties) {
                  traverseObjectKeys(schema.patternProperties, callback, processed);
                }
                if (schema.additionalProperties && typeof schema.additionalProperties === "object") {
                  traverse(schema.additionalProperties, callback, processed);
                }
                if (schema.items) {
                  var items = schema.items;
                  if (Array.isArray(items)) {
                    traverseArray(items, callback, processed);
                  } else {
                    traverse(items, callback, processed);
                  }
                }
                if (schema.additionalItems && typeof schema.additionalItems === "object") {
                  traverse(schema.additionalItems, callback, processed);
                }
                if (schema.dependencies) {
                  if (Array.isArray(schema.dependencies)) {
                    traverseArray(schema.dependencies, callback, processed);
                  } else {
                    traverseObjectKeys(schema.dependencies, callback, processed);
                  }
                }
                if (schema.definitions) {
                  traverseObjectKeys(schema.definitions, callback, processed);
                }
                if (schema.$defs) {
                  traverseObjectKeys(schema.$defs, callback, processed);
                }
                if (schema.not) {
                  traverse(schema.not, callback, processed);
                }
                Object.keys(schema).filter(function(key2) {
                  return !BLACKLISTED_KEYS.has(key2);
                }).forEach(function(key2) {
                  var child = schema[key2];
                  if (child && typeof child === "object") {
                    traverseObjectKeys(child, callback, processed);
                  }
                });
              }
              exports3.traverse = traverse;
              function justName(filename) {
                if (filename === void 0) {
                  filename = "";
                }
                return stripExtension((0, path_1.basename)(filename));
              }
              exports3.justName = justName;
              function stripExtension(filename) {
                return filename.replace((0, path_1.extname)(filename), "");
              }
              exports3.stripExtension = stripExtension;
              function toSafeString(string) {
                return (0, lodash_1.upperFirst)(
                  // remove accents, umlauts, ... by their basic latin letters
                  (0, lodash_1.deburr)(string).replace(/(^\s*[^a-zA-Z_$])|([^a-zA-Z_$\d])/g, " ").replace(/^_[a-z]/g, function(match) {
                    return match.toUpperCase();
                  }).replace(/_[a-z]/g, function(match) {
                    return match.substr(1, match.length).toUpperCase();
                  }).replace(/([\d$]+[a-zA-Z])/g, function(match) {
                    return match.toUpperCase();
                  }).replace(/\s+([a-zA-Z])/g, function(match) {
                    return (0, lodash_1.trim)(match.toUpperCase());
                  }).replace(/\s/g, "")
                );
              }
              exports3.toSafeString = toSafeString;
              function generateName(from, usedNames) {
                var name = toSafeString(from);
                if (!name) {
                  name = "NoName";
                }
                if (usedNames.has(name)) {
                  var counter = 1;
                  var nameWithCounter = "".concat(name).concat(counter);
                  while (usedNames.has(nameWithCounter)) {
                    nameWithCounter = "".concat(name).concat(counter);
                    counter++;
                  }
                  name = nameWithCounter;
                }
                usedNames.add(name);
                return name;
              }
              exports3.generateName = generateName;
              function error() {
                var _a;
                var messages = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  messages[_i] = arguments[_i];
                }
                if (!process.env.VERBOSE) {
                  return console.error(messages);
                }
                console.error.apply(console, __spreadArray([(_a = getStyledTextForLogging("red")) === null || _a === void 0 ? void 0 : _a("error")], messages, false));
              }
              exports3.error = error;
              function log(style, title) {
                var _a;
                var messages = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                  messages[_i - 2] = arguments[_i];
                }
                if (!process.env.VERBOSE) {
                  return;
                }
                var lastMessage = null;
                if (messages.length > 1 && typeof messages[messages.length - 1] !== "string") {
                  lastMessage = messages.splice(messages.length - 1, 1);
                }
                console.info.apply(console, __spreadArray([require2("cli-color").whiteBright.bgCyan("debug"), (_a = getStyledTextForLogging(style)) === null || _a === void 0 ? void 0 : _a(title)], messages, false));
                if (lastMessage) {
                  console.dir(lastMessage, { depth: 6, maxArrayLength: 6 });
                }
              }
              exports3.log = log;
              function getStyledTextForLogging(style) {
                if (!process.env.VERBOSE) {
                  return;
                }
                switch (style) {
                  case "blue":
                    return require2("cli-color").whiteBright.bgBlue;
                  case "cyan":
                    return require2("cli-color").whiteBright.bgCyan;
                  case "green":
                    return require2("cli-color").whiteBright.bgGreen;
                  case "magenta":
                    return require2("cli-color").whiteBright.bgMagenta;
                  case "red":
                    return require2("cli-color").whiteBright.bgRedBright;
                  case "white":
                    return require2("cli-color").black.bgWhite;
                  case "yellow":
                    return require2("cli-color").whiteBright.bgYellow;
                }
              }
              function escapeBlockComment(schema) {
                var replacer = "* /";
                if (schema === null || typeof schema !== "object") {
                  return;
                }
                for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {
                  var key = _a[_i];
                  if (key === "description" && typeof schema[key] === "string") {
                    schema[key] = schema[key].replace(/\*\//g, replacer);
                  }
                }
              }
              exports3.escapeBlockComment = escapeBlockComment;
              function pathTransform(outputPath, inputPath, filePath) {
                var inPathList = (0, path_1.normalize)(inputPath).split(path_1.sep);
                var filePathList = (0, path_1.dirname)((0, path_1.normalize)(filePath)).split(path_1.sep);
                var filePathRel = filePathList.filter(function(f2, i2) {
                  return f2 !== inPathList[i2];
                });
                return path_1.posix.join.apply(path_1.posix, __spreadArray([path_1.posix.normalize(outputPath)], filePathRel, false));
              }
              exports3.pathTransform = pathTransform;
              function maybeStripDefault(schema) {
                if (!("default" in schema)) {
                  return schema;
                }
                switch (schema.type) {
                  case "array":
                    if (Array.isArray(schema.default)) {
                      return schema;
                    }
                    break;
                  case "boolean":
                    if (typeof schema.default === "boolean") {
                      return schema;
                    }
                    break;
                  case "integer":
                  case "number":
                    if (typeof schema.default === "number") {
                      return schema;
                    }
                    break;
                  case "string":
                    if (typeof schema.default === "string") {
                      return schema;
                    }
                    break;
                  case "null":
                    if (schema.default === null) {
                      return schema;
                    }
                    break;
                  case "object":
                    if ((0, lodash_1.isPlainObject)(schema.default)) {
                      return schema;
                    }
                    break;
                }
                delete schema.default;
                return schema;
              }
              exports3.maybeStripDefault = maybeStripDefault;
              function maybeStripNameHints(schema) {
                if ("$id" in schema) {
                  delete schema.$id;
                }
                if ("description" in schema) {
                  delete schema.description;
                }
                if ("name" in schema) {
                  delete schema.name;
                }
                return schema;
              }
              exports3.maybeStripNameHints = maybeStripNameHints;
              function appendToDescription(existingDescription) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  values[_i - 1] = arguments[_i];
                }
                if (existingDescription) {
                  return "".concat(existingDescription, "\n\n").concat(values.join("\n"));
                }
                return values.join("\n");
              }
              exports3.appendToDescription = appendToDescription;
              function isSchemaLike(schema) {
                if (!(0, lodash_1.isPlainObject)(schema)) {
                  return false;
                }
                var parent = schema[JSONSchema_1.Parent];
                if (parent === null) {
                  return true;
                }
                var JSON_SCHEMA_KEYWORDS = [
                  "$defs",
                  "allOf",
                  "anyOf",
                  "definitions",
                  "dependencies",
                  "enum",
                  "not",
                  "oneOf",
                  "patternProperties",
                  "properties",
                  "required"
                ];
                if (JSON_SCHEMA_KEYWORDS.some(function(_2) {
                  return parent[_2] === schema;
                })) {
                  return false;
                }
                return true;
              }
              exports3.isSchemaLike = isSchemaLike;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./types/JSONSchema": 235, "_process": 263, "cli-color": 45, "lodash": 239, "path": 262 }], 238: [function(require2, module3, exports3) {
          Object.defineProperty(exports3, "__esModule", { value: true });
          exports3.validate = void 0;
          var utils_1 = require2("./utils");
          var rules = /* @__PURE__ */ new Map();
          rules.set("Enum members and tsEnumNames must be of the same length", function(schema) {
            if (schema.enum && schema.tsEnumNames && schema.enum.length !== schema.tsEnumNames.length) {
              return false;
            }
          });
          rules.set("tsEnumNames must be an array of strings", function(schema) {
            if (schema.tsEnumNames && schema.tsEnumNames.some(function(_2) {
              return typeof _2 !== "string";
            })) {
              return false;
            }
          });
          rules.set("When both maxItems and minItems are present, maxItems >= minItems", function(schema) {
            var maxItems = schema.maxItems, minItems = schema.minItems;
            if (typeof maxItems === "number" && typeof minItems === "number") {
              return maxItems >= minItems;
            }
          });
          rules.set("When maxItems exists, maxItems >= 0", function(schema) {
            var maxItems = schema.maxItems;
            if (typeof maxItems === "number") {
              return maxItems >= 0;
            }
          });
          rules.set("When minItems exists, minItems >= 0", function(schema) {
            var minItems = schema.minItems;
            if (typeof minItems === "number") {
              return minItems >= 0;
            }
          });
          function validate(schema, filename) {
            var errors = [];
            rules.forEach(function(rule, ruleName) {
              (0, utils_1.traverse)(schema, function(schema2, key) {
                if (rule(schema2) === false) {
                  errors.push('Error at key "'.concat(key, '" in file "').concat(filename, '": ').concat(ruleName));
                }
                return schema2;
              });
            });
            return errors;
          }
          exports3.validate = validate;
        }, { "./utils": 237 }], 239: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              (function() {
                var undefined2;
                var VERSION = "4.17.21";
                var LARGE_ARRAY_SIZE = 200;
                var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
                var HASH_UNDEFINED = "__lodash_hash_undefined__";
                var MAX_MEMOIZE_SIZE = 500;
                var PLACEHOLDER = "__lodash_placeholder__";
                var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
                var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
                var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
                var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
                var HOT_COUNT = 800, HOT_SPAN = 16;
                var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
                var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
                var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
                var wrapFlags = [
                  ["ary", WRAP_ARY_FLAG],
                  ["bind", WRAP_BIND_FLAG],
                  ["bindKey", WRAP_BIND_KEY_FLAG],
                  ["curry", WRAP_CURRY_FLAG],
                  ["curryRight", WRAP_CURRY_RIGHT_FLAG],
                  ["flip", WRAP_FLIP_FLAG],
                  ["partial", WRAP_PARTIAL_FLAG],
                  ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
                  ["rearg", WRAP_REARG_FLAG]
                ];
                var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
                var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
                var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
                var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
                var reTrimStart = /^\s+/;
                var reWhitespace = /\s/;
                var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
                var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
                var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
                var reEscapeChar = /\\(\\)?/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
                var reIsBinary = /^0b[01]+$/i;
                var reIsHostCtor = /^\[object .+?Constructor\]$/;
                var reIsOctal = /^0o[0-7]+$/i;
                var reIsUint = /^(?:0|[1-9]\d*)$/;
                var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
                var reNoMatch = /($^)/;
                var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
                var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
                var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
                var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
                var reApos = RegExp(rsApos, "g");
                var reComboMark = RegExp(rsCombo, "g");
                var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
                var reUnicodeWord = RegExp([
                  rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
                  rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
                  rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
                  rsUpper + "+" + rsOptContrUpper,
                  rsOrdUpper,
                  rsOrdLower,
                  rsDigits,
                  rsEmoji
                ].join("|"), "g");
                var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
                var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
                var contextProps = [
                  "Array",
                  "Buffer",
                  "DataView",
                  "Date",
                  "Error",
                  "Float32Array",
                  "Float64Array",
                  "Function",
                  "Int8Array",
                  "Int16Array",
                  "Int32Array",
                  "Map",
                  "Math",
                  "Object",
                  "Promise",
                  "RegExp",
                  "Set",
                  "String",
                  "Symbol",
                  "TypeError",
                  "Uint8Array",
                  "Uint8ClampedArray",
                  "Uint16Array",
                  "Uint32Array",
                  "WeakMap",
                  "_",
                  "clearTimeout",
                  "isFinite",
                  "parseInt",
                  "setTimeout"
                ];
                var templateCounter = -1;
                var typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
                typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
                var cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
                cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
                var deburredLetters = {
                  // Latin-1 Supplement block.
                  "À": "A",
                  "Á": "A",
                  "Â": "A",
                  "Ã": "A",
                  "Ä": "A",
                  "Å": "A",
                  "à": "a",
                  "á": "a",
                  "â": "a",
                  "ã": "a",
                  "ä": "a",
                  "å": "a",
                  "Ç": "C",
                  "ç": "c",
                  "Ð": "D",
                  "ð": "d",
                  "È": "E",
                  "É": "E",
                  "Ê": "E",
                  "Ë": "E",
                  "è": "e",
                  "é": "e",
                  "ê": "e",
                  "ë": "e",
                  "Ì": "I",
                  "Í": "I",
                  "Î": "I",
                  "Ï": "I",
                  "ì": "i",
                  "í": "i",
                  "î": "i",
                  "ï": "i",
                  "Ñ": "N",
                  "ñ": "n",
                  "Ò": "O",
                  "Ó": "O",
                  "Ô": "O",
                  "Õ": "O",
                  "Ö": "O",
                  "Ø": "O",
                  "ò": "o",
                  "ó": "o",
                  "ô": "o",
                  "õ": "o",
                  "ö": "o",
                  "ø": "o",
                  "Ù": "U",
                  "Ú": "U",
                  "Û": "U",
                  "Ü": "U",
                  "ù": "u",
                  "ú": "u",
                  "û": "u",
                  "ü": "u",
                  "Ý": "Y",
                  "ý": "y",
                  "ÿ": "y",
                  "Æ": "Ae",
                  "æ": "ae",
                  "Þ": "Th",
                  "þ": "th",
                  "ß": "ss",
                  // Latin Extended-A block.
                  "Ā": "A",
                  "Ă": "A",
                  "Ą": "A",
                  "ā": "a",
                  "ă": "a",
                  "ą": "a",
                  "Ć": "C",
                  "Ĉ": "C",
                  "Ċ": "C",
                  "Č": "C",
                  "ć": "c",
                  "ĉ": "c",
                  "ċ": "c",
                  "č": "c",
                  "Ď": "D",
                  "Đ": "D",
                  "ď": "d",
                  "đ": "d",
                  "Ē": "E",
                  "Ĕ": "E",
                  "Ė": "E",
                  "Ę": "E",
                  "Ě": "E",
                  "ē": "e",
                  "ĕ": "e",
                  "ė": "e",
                  "ę": "e",
                  "ě": "e",
                  "Ĝ": "G",
                  "Ğ": "G",
                  "Ġ": "G",
                  "Ģ": "G",
                  "ĝ": "g",
                  "ğ": "g",
                  "ġ": "g",
                  "ģ": "g",
                  "Ĥ": "H",
                  "Ħ": "H",
                  "ĥ": "h",
                  "ħ": "h",
                  "Ĩ": "I",
                  "Ī": "I",
                  "Ĭ": "I",
                  "Į": "I",
                  "İ": "I",
                  "ĩ": "i",
                  "ī": "i",
                  "ĭ": "i",
                  "į": "i",
                  "ı": "i",
                  "Ĵ": "J",
                  "ĵ": "j",
                  "Ķ": "K",
                  "ķ": "k",
                  "ĸ": "k",
                  "Ĺ": "L",
                  "Ļ": "L",
                  "Ľ": "L",
                  "Ŀ": "L",
                  "Ł": "L",
                  "ĺ": "l",
                  "ļ": "l",
                  "ľ": "l",
                  "ŀ": "l",
                  "ł": "l",
                  "Ń": "N",
                  "Ņ": "N",
                  "Ň": "N",
                  "Ŋ": "N",
                  "ń": "n",
                  "ņ": "n",
                  "ň": "n",
                  "ŋ": "n",
                  "Ō": "O",
                  "Ŏ": "O",
                  "Ő": "O",
                  "ō": "o",
                  "ŏ": "o",
                  "ő": "o",
                  "Ŕ": "R",
                  "Ŗ": "R",
                  "Ř": "R",
                  "ŕ": "r",
                  "ŗ": "r",
                  "ř": "r",
                  "Ś": "S",
                  "Ŝ": "S",
                  "Ş": "S",
                  "Š": "S",
                  "ś": "s",
                  "ŝ": "s",
                  "ş": "s",
                  "š": "s",
                  "Ţ": "T",
                  "Ť": "T",
                  "Ŧ": "T",
                  "ţ": "t",
                  "ť": "t",
                  "ŧ": "t",
                  "Ũ": "U",
                  "Ū": "U",
                  "Ŭ": "U",
                  "Ů": "U",
                  "Ű": "U",
                  "Ų": "U",
                  "ũ": "u",
                  "ū": "u",
                  "ŭ": "u",
                  "ů": "u",
                  "ű": "u",
                  "ų": "u",
                  "Ŵ": "W",
                  "ŵ": "w",
                  "Ŷ": "Y",
                  "ŷ": "y",
                  "Ÿ": "Y",
                  "Ź": "Z",
                  "Ż": "Z",
                  "Ž": "Z",
                  "ź": "z",
                  "ż": "z",
                  "ž": "z",
                  "Ĳ": "IJ",
                  "ĳ": "ij",
                  "Œ": "Oe",
                  "œ": "oe",
                  "ŉ": "'n",
                  "ſ": "s"
                };
                var htmlEscapes = {
                  "&": "&amp;",
                  "<": "&lt;",
                  ">": "&gt;",
                  '"': "&quot;",
                  "'": "&#39;"
                };
                var htmlUnescapes = {
                  "&amp;": "&",
                  "&lt;": "<",
                  "&gt;": ">",
                  "&quot;": '"',
                  "&#39;": "'"
                };
                var stringEscapes = {
                  "\\": "\\",
                  "'": "'",
                  "\n": "n",
                  "\r": "r",
                  "\u2028": "u2028",
                  "\u2029": "u2029"
                };
                var freeParseFloat = parseFloat, freeParseInt = parseInt;
                var freeGlobal = typeof global2 == "object" && global2 && global2.Object === Object && global2;
                var freeSelf = typeof self == "object" && self && self.Object === Object && self;
                var root = freeGlobal || freeSelf || Function("return this")();
                var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
                var freeModule = freeExports && typeof module3 == "object" && module3 && !module3.nodeType && module3;
                var moduleExports = freeModule && freeModule.exports === freeExports;
                var freeProcess = moduleExports && freeGlobal.process;
                var nodeUtil = function() {
                  try {
                    var types = freeModule && freeModule.require && freeModule.require("util").types;
                    if (types) {
                      return types;
                    }
                    return freeProcess && freeProcess.binding && freeProcess.binding("util");
                  } catch (e2) {
                  }
                }();
                var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                function apply(func, thisArg, args) {
                  switch (args.length) {
                    case 0:
                      return func.call(thisArg);
                    case 1:
                      return func.call(thisArg, args[0]);
                    case 2:
                      return func.call(thisArg, args[0], args[1]);
                    case 3:
                      return func.call(thisArg, args[0], args[1], args[2]);
                  }
                  return func.apply(thisArg, args);
                }
                function arrayAggregator(array, setter, iteratee, accumulator) {
                  var index = -1, length = array == null ? 0 : array.length;
                  while (++index < length) {
                    var value = array[index];
                    setter(accumulator, value, iteratee(value), array);
                  }
                  return accumulator;
                }
                function arrayEach(array, iteratee) {
                  var index = -1, length = array == null ? 0 : array.length;
                  while (++index < length) {
                    if (iteratee(array[index], index, array) === false) {
                      break;
                    }
                  }
                  return array;
                }
                function arrayEachRight(array, iteratee) {
                  var length = array == null ? 0 : array.length;
                  while (length--) {
                    if (iteratee(array[length], length, array) === false) {
                      break;
                    }
                  }
                  return array;
                }
                function arrayEvery(array, predicate) {
                  var index = -1, length = array == null ? 0 : array.length;
                  while (++index < length) {
                    if (!predicate(array[index], index, array)) {
                      return false;
                    }
                  }
                  return true;
                }
                function arrayFilter(array, predicate) {
                  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
                  while (++index < length) {
                    var value = array[index];
                    if (predicate(value, index, array)) {
                      result[resIndex++] = value;
                    }
                  }
                  return result;
                }
                function arrayIncludes(array, value) {
                  var length = array == null ? 0 : array.length;
                  return !!length && baseIndexOf(array, value, 0) > -1;
                }
                function arrayIncludesWith(array, value, comparator) {
                  var index = -1, length = array == null ? 0 : array.length;
                  while (++index < length) {
                    if (comparator(value, array[index])) {
                      return true;
                    }
                  }
                  return false;
                }
                function arrayMap(array, iteratee) {
                  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
                  while (++index < length) {
                    result[index] = iteratee(array[index], index, array);
                  }
                  return result;
                }
                function arrayPush(array, values) {
                  var index = -1, length = values.length, offset = array.length;
                  while (++index < length) {
                    array[offset + index] = values[index];
                  }
                  return array;
                }
                function arrayReduce(array, iteratee, accumulator, initAccum) {
                  var index = -1, length = array == null ? 0 : array.length;
                  if (initAccum && length) {
                    accumulator = array[++index];
                  }
                  while (++index < length) {
                    accumulator = iteratee(accumulator, array[index], index, array);
                  }
                  return accumulator;
                }
                function arrayReduceRight(array, iteratee, accumulator, initAccum) {
                  var length = array == null ? 0 : array.length;
                  if (initAccum && length) {
                    accumulator = array[--length];
                  }
                  while (length--) {
                    accumulator = iteratee(accumulator, array[length], length, array);
                  }
                  return accumulator;
                }
                function arraySome(array, predicate) {
                  var index = -1, length = array == null ? 0 : array.length;
                  while (++index < length) {
                    if (predicate(array[index], index, array)) {
                      return true;
                    }
                  }
                  return false;
                }
                var asciiSize = baseProperty("length");
                function asciiToArray(string) {
                  return string.split("");
                }
                function asciiWords(string) {
                  return string.match(reAsciiWord) || [];
                }
                function baseFindKey(collection, predicate, eachFunc) {
                  var result;
                  eachFunc(collection, function(value, key, collection2) {
                    if (predicate(value, key, collection2)) {
                      result = key;
                      return false;
                    }
                  });
                  return result;
                }
                function baseFindIndex(array, predicate, fromIndex, fromRight) {
                  var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
                  while (fromRight ? index-- : ++index < length) {
                    if (predicate(array[index], index, array)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function baseIndexOf(array, value, fromIndex) {
                  return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
                }
                function baseIndexOfWith(array, value, fromIndex, comparator) {
                  var index = fromIndex - 1, length = array.length;
                  while (++index < length) {
                    if (comparator(array[index], value)) {
                      return index;
                    }
                  }
                  return -1;
                }
                function baseIsNaN(value) {
                  return value !== value;
                }
                function baseMean(array, iteratee) {
                  var length = array == null ? 0 : array.length;
                  return length ? baseSum(array, iteratee) / length : NAN;
                }
                function baseProperty(key) {
                  return function(object) {
                    return object == null ? undefined2 : object[key];
                  };
                }
                function basePropertyOf(object) {
                  return function(key) {
                    return object == null ? undefined2 : object[key];
                  };
                }
                function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
                  eachFunc(collection, function(value, index, collection2) {
                    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
                  });
                  return accumulator;
                }
                function baseSortBy(array, comparer) {
                  var length = array.length;
                  array.sort(comparer);
                  while (length--) {
                    array[length] = array[length].value;
                  }
                  return array;
                }
                function baseSum(array, iteratee) {
                  var result, index = -1, length = array.length;
                  while (++index < length) {
                    var current = iteratee(array[index]);
                    if (current !== undefined2) {
                      result = result === undefined2 ? current : result + current;
                    }
                  }
                  return result;
                }
                function baseTimes(n2, iteratee) {
                  var index = -1, result = Array(n2);
                  while (++index < n2) {
                    result[index] = iteratee(index);
                  }
                  return result;
                }
                function baseToPairs(object, props) {
                  return arrayMap(props, function(key) {
                    return [key, object[key]];
                  });
                }
                function baseTrim(string) {
                  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
                }
                function baseUnary(func) {
                  return function(value) {
                    return func(value);
                  };
                }
                function baseValues(object, props) {
                  return arrayMap(props, function(key) {
                    return object[key];
                  });
                }
                function cacheHas(cache, key) {
                  return cache.has(key);
                }
                function charsStartIndex(strSymbols, chrSymbols) {
                  var index = -1, length = strSymbols.length;
                  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                  }
                  return index;
                }
                function charsEndIndex(strSymbols, chrSymbols) {
                  var index = strSymbols.length;
                  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
                  }
                  return index;
                }
                function countHolders(array, placeholder) {
                  var length = array.length, result = 0;
                  while (length--) {
                    if (array[length] === placeholder) {
                      ++result;
                    }
                  }
                  return result;
                }
                var deburrLetter = basePropertyOf(deburredLetters);
                var escapeHtmlChar = basePropertyOf(htmlEscapes);
                function escapeStringChar(chr) {
                  return "\\" + stringEscapes[chr];
                }
                function getValue(object, key) {
                  return object == null ? undefined2 : object[key];
                }
                function hasUnicode(string) {
                  return reHasUnicode.test(string);
                }
                function hasUnicodeWord(string) {
                  return reHasUnicodeWord.test(string);
                }
                function iteratorToArray(iterator) {
                  var data, result = [];
                  while (!(data = iterator.next()).done) {
                    result.push(data.value);
                  }
                  return result;
                }
                function mapToArray(map) {
                  var index = -1, result = Array(map.size);
                  map.forEach(function(value, key) {
                    result[++index] = [key, value];
                  });
                  return result;
                }
                function overArg(func, transform) {
                  return function(arg) {
                    return func(transform(arg));
                  };
                }
                function replaceHolders(array, placeholder) {
                  var index = -1, length = array.length, resIndex = 0, result = [];
                  while (++index < length) {
                    var value = array[index];
                    if (value === placeholder || value === PLACEHOLDER) {
                      array[index] = PLACEHOLDER;
                      result[resIndex++] = index;
                    }
                  }
                  return result;
                }
                function setToArray(set) {
                  var index = -1, result = Array(set.size);
                  set.forEach(function(value) {
                    result[++index] = value;
                  });
                  return result;
                }
                function setToPairs(set) {
                  var index = -1, result = Array(set.size);
                  set.forEach(function(value) {
                    result[++index] = [value, value];
                  });
                  return result;
                }
                function strictIndexOf(array, value, fromIndex) {
                  var index = fromIndex - 1, length = array.length;
                  while (++index < length) {
                    if (array[index] === value) {
                      return index;
                    }
                  }
                  return -1;
                }
                function strictLastIndexOf(array, value, fromIndex) {
                  var index = fromIndex + 1;
                  while (index--) {
                    if (array[index] === value) {
                      return index;
                    }
                  }
                  return index;
                }
                function stringSize(string) {
                  return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
                }
                function stringToArray(string) {
                  return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
                }
                function trimmedEndIndex(string) {
                  var index = string.length;
                  while (index-- && reWhitespace.test(string.charAt(index))) {
                  }
                  return index;
                }
                var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
                function unicodeSize(string) {
                  var result = reUnicode.lastIndex = 0;
                  while (reUnicode.test(string)) {
                    ++result;
                  }
                  return result;
                }
                function unicodeToArray(string) {
                  return string.match(reUnicode) || [];
                }
                function unicodeWords(string) {
                  return string.match(reUnicodeWord) || [];
                }
                var runInContext = function runInContext2(context) {
                  context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
                  var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
                  var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
                  var coreJsData = context["__core-js_shared__"];
                  var funcToString = funcProto.toString;
                  var hasOwnProperty2 = objectProto.hasOwnProperty;
                  var idCounter = 0;
                  var maskSrcKey = function() {
                    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                    return uid ? "Symbol(src)_1." + uid : "";
                  }();
                  var nativeObjectToString = objectProto.toString;
                  var objectCtorString = funcToString.call(Object2);
                  var oldDash = root._;
                  var reIsNative = RegExp2(
                    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
                  );
                  var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
                  var defineProperty = function() {
                    try {
                      var func = getNative(Object2, "defineProperty");
                      func({}, "", {});
                      return func;
                    } catch (e2) {
                    }
                  }();
                  var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
                  var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
                  var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
                  var metaMap = WeakMap2 && new WeakMap2();
                  var realNames = {};
                  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
                  var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
                  function lodash(value) {
                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                      if (value instanceof LodashWrapper) {
                        return value;
                      }
                      if (hasOwnProperty2.call(value, "__wrapped__")) {
                        return wrapperClone(value);
                      }
                    }
                    return new LodashWrapper(value);
                  }
                  var baseCreate = /* @__PURE__ */ function() {
                    function object() {
                    }
                    return function(proto) {
                      if (!isObject2(proto)) {
                        return {};
                      }
                      if (objectCreate) {
                        return objectCreate(proto);
                      }
                      object.prototype = proto;
                      var result2 = new object();
                      object.prototype = undefined2;
                      return result2;
                    };
                  }();
                  function baseLodash() {
                  }
                  function LodashWrapper(value, chainAll) {
                    this.__wrapped__ = value;
                    this.__actions__ = [];
                    this.__chain__ = !!chainAll;
                    this.__index__ = 0;
                    this.__values__ = undefined2;
                  }
                  lodash.templateSettings = {
                    /**
                     * Used to detect `data` property values to be HTML-escaped.
                     *
                     * @memberOf _.templateSettings
                     * @type {RegExp}
                     */
                    "escape": reEscape,
                    /**
                     * Used to detect code to be evaluated.
                     *
                     * @memberOf _.templateSettings
                     * @type {RegExp}
                     */
                    "evaluate": reEvaluate,
                    /**
                     * Used to detect `data` property values to inject.
                     *
                     * @memberOf _.templateSettings
                     * @type {RegExp}
                     */
                    "interpolate": reInterpolate,
                    /**
                     * Used to reference the data object in the template text.
                     *
                     * @memberOf _.templateSettings
                     * @type {string}
                     */
                    "variable": "",
                    /**
                     * Used to import variables into the compiled template.
                     *
                     * @memberOf _.templateSettings
                     * @type {Object}
                     */
                    "imports": {
                      /**
                       * A reference to the `lodash` function.
                       *
                       * @memberOf _.templateSettings.imports
                       * @type {Function}
                       */
                      "_": lodash
                    }
                  };
                  lodash.prototype = baseLodash.prototype;
                  lodash.prototype.constructor = lodash;
                  LodashWrapper.prototype = baseCreate(baseLodash.prototype);
                  LodashWrapper.prototype.constructor = LodashWrapper;
                  function LazyWrapper(value) {
                    this.__wrapped__ = value;
                    this.__actions__ = [];
                    this.__dir__ = 1;
                    this.__filtered__ = false;
                    this.__iteratees__ = [];
                    this.__takeCount__ = MAX_ARRAY_LENGTH;
                    this.__views__ = [];
                  }
                  function lazyClone() {
                    var result2 = new LazyWrapper(this.__wrapped__);
                    result2.__actions__ = copyArray(this.__actions__);
                    result2.__dir__ = this.__dir__;
                    result2.__filtered__ = this.__filtered__;
                    result2.__iteratees__ = copyArray(this.__iteratees__);
                    result2.__takeCount__ = this.__takeCount__;
                    result2.__views__ = copyArray(this.__views__);
                    return result2;
                  }
                  function lazyReverse() {
                    if (this.__filtered__) {
                      var result2 = new LazyWrapper(this);
                      result2.__dir__ = -1;
                      result2.__filtered__ = true;
                    } else {
                      result2 = this.clone();
                      result2.__dir__ *= -1;
                    }
                    return result2;
                  }
                  function lazyValue() {
                    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
                    if (!isArr || !isRight && arrLength == length && takeCount == length) {
                      return baseWrapperValue(array, this.__actions__);
                    }
                    var result2 = [];
                    outer:
                      while (length-- && resIndex < takeCount) {
                        index += dir;
                        var iterIndex = -1, value = array[index];
                        while (++iterIndex < iterLength) {
                          var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                          if (type == LAZY_MAP_FLAG) {
                            value = computed;
                          } else if (!computed) {
                            if (type == LAZY_FILTER_FLAG) {
                              continue outer;
                            } else {
                              break outer;
                            }
                          }
                        }
                        result2[resIndex++] = value;
                      }
                    return result2;
                  }
                  LazyWrapper.prototype = baseCreate(baseLodash.prototype);
                  LazyWrapper.prototype.constructor = LazyWrapper;
                  function Hash(entries) {
                    var index = -1, length = entries == null ? 0 : entries.length;
                    this.clear();
                    while (++index < length) {
                      var entry = entries[index];
                      this.set(entry[0], entry[1]);
                    }
                  }
                  function hashClear() {
                    this.__data__ = nativeCreate ? nativeCreate(null) : {};
                    this.size = 0;
                  }
                  function hashDelete(key) {
                    var result2 = this.has(key) && delete this.__data__[key];
                    this.size -= result2 ? 1 : 0;
                    return result2;
                  }
                  function hashGet(key) {
                    var data = this.__data__;
                    if (nativeCreate) {
                      var result2 = data[key];
                      return result2 === HASH_UNDEFINED ? undefined2 : result2;
                    }
                    return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
                  }
                  function hashHas(key) {
                    var data = this.__data__;
                    return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
                  }
                  function hashSet(key, value) {
                    var data = this.__data__;
                    this.size += this.has(key) ? 0 : 1;
                    data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
                    return this;
                  }
                  Hash.prototype.clear = hashClear;
                  Hash.prototype["delete"] = hashDelete;
                  Hash.prototype.get = hashGet;
                  Hash.prototype.has = hashHas;
                  Hash.prototype.set = hashSet;
                  function ListCache(entries) {
                    var index = -1, length = entries == null ? 0 : entries.length;
                    this.clear();
                    while (++index < length) {
                      var entry = entries[index];
                      this.set(entry[0], entry[1]);
                    }
                  }
                  function listCacheClear() {
                    this.__data__ = [];
                    this.size = 0;
                  }
                  function listCacheDelete(key) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    if (index < 0) {
                      return false;
                    }
                    var lastIndex = data.length - 1;
                    if (index == lastIndex) {
                      data.pop();
                    } else {
                      splice.call(data, index, 1);
                    }
                    --this.size;
                    return true;
                  }
                  function listCacheGet(key) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    return index < 0 ? undefined2 : data[index][1];
                  }
                  function listCacheHas(key) {
                    return assocIndexOf(this.__data__, key) > -1;
                  }
                  function listCacheSet(key, value) {
                    var data = this.__data__, index = assocIndexOf(data, key);
                    if (index < 0) {
                      ++this.size;
                      data.push([key, value]);
                    } else {
                      data[index][1] = value;
                    }
                    return this;
                  }
                  ListCache.prototype.clear = listCacheClear;
                  ListCache.prototype["delete"] = listCacheDelete;
                  ListCache.prototype.get = listCacheGet;
                  ListCache.prototype.has = listCacheHas;
                  ListCache.prototype.set = listCacheSet;
                  function MapCache(entries) {
                    var index = -1, length = entries == null ? 0 : entries.length;
                    this.clear();
                    while (++index < length) {
                      var entry = entries[index];
                      this.set(entry[0], entry[1]);
                    }
                  }
                  function mapCacheClear() {
                    this.size = 0;
                    this.__data__ = {
                      "hash": new Hash(),
                      "map": new (Map2 || ListCache)(),
                      "string": new Hash()
                    };
                  }
                  function mapCacheDelete(key) {
                    var result2 = getMapData(this, key)["delete"](key);
                    this.size -= result2 ? 1 : 0;
                    return result2;
                  }
                  function mapCacheGet(key) {
                    return getMapData(this, key).get(key);
                  }
                  function mapCacheHas(key) {
                    return getMapData(this, key).has(key);
                  }
                  function mapCacheSet(key, value) {
                    var data = getMapData(this, key), size2 = data.size;
                    data.set(key, value);
                    this.size += data.size == size2 ? 0 : 1;
                    return this;
                  }
                  MapCache.prototype.clear = mapCacheClear;
                  MapCache.prototype["delete"] = mapCacheDelete;
                  MapCache.prototype.get = mapCacheGet;
                  MapCache.prototype.has = mapCacheHas;
                  MapCache.prototype.set = mapCacheSet;
                  function SetCache(values2) {
                    var index = -1, length = values2 == null ? 0 : values2.length;
                    this.__data__ = new MapCache();
                    while (++index < length) {
                      this.add(values2[index]);
                    }
                  }
                  function setCacheAdd(value) {
                    this.__data__.set(value, HASH_UNDEFINED);
                    return this;
                  }
                  function setCacheHas(value) {
                    return this.__data__.has(value);
                  }
                  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                  SetCache.prototype.has = setCacheHas;
                  function Stack(entries) {
                    var data = this.__data__ = new ListCache(entries);
                    this.size = data.size;
                  }
                  function stackClear() {
                    this.__data__ = new ListCache();
                    this.size = 0;
                  }
                  function stackDelete(key) {
                    var data = this.__data__, result2 = data["delete"](key);
                    this.size = data.size;
                    return result2;
                  }
                  function stackGet(key) {
                    return this.__data__.get(key);
                  }
                  function stackHas(key) {
                    return this.__data__.has(key);
                  }
                  function stackSet(key, value) {
                    var data = this.__data__;
                    if (data instanceof ListCache) {
                      var pairs = data.__data__;
                      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                        pairs.push([key, value]);
                        this.size = ++data.size;
                        return this;
                      }
                      data = this.__data__ = new MapCache(pairs);
                    }
                    data.set(key, value);
                    this.size = data.size;
                    return this;
                  }
                  Stack.prototype.clear = stackClear;
                  Stack.prototype["delete"] = stackDelete;
                  Stack.prototype.get = stackGet;
                  Stack.prototype.has = stackHas;
                  Stack.prototype.set = stackSet;
                  function arrayLikeKeys(value, inherited) {
                    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
                    for (var key in value) {
                      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                      (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                      isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                      isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
                      isIndex(key, length)))) {
                        result2.push(key);
                      }
                    }
                    return result2;
                  }
                  function arraySample(array) {
                    var length = array.length;
                    return length ? array[baseRandom(0, length - 1)] : undefined2;
                  }
                  function arraySampleSize(array, n2) {
                    return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
                  }
                  function arrayShuffle(array) {
                    return shuffleSelf(copyArray(array));
                  }
                  function assignMergeValue(object, key, value) {
                    if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
                      baseAssignValue(object, key, value);
                    }
                  }
                  function assignValue(object, key, value) {
                    var objValue = object[key];
                    if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
                      baseAssignValue(object, key, value);
                    }
                  }
                  function assocIndexOf(array, key) {
                    var length = array.length;
                    while (length--) {
                      if (eq(array[length][0], key)) {
                        return length;
                      }
                    }
                    return -1;
                  }
                  function baseAggregator(collection, setter, iteratee2, accumulator) {
                    baseEach(collection, function(value, key, collection2) {
                      setter(accumulator, value, iteratee2(value), collection2);
                    });
                    return accumulator;
                  }
                  function baseAssign(object, source) {
                    return object && copyObject(source, keys(source), object);
                  }
                  function baseAssignIn(object, source) {
                    return object && copyObject(source, keysIn(source), object);
                  }
                  function baseAssignValue(object, key, value) {
                    if (key == "__proto__" && defineProperty) {
                      defineProperty(object, key, {
                        "configurable": true,
                        "enumerable": true,
                        "value": value,
                        "writable": true
                      });
                    } else {
                      object[key] = value;
                    }
                  }
                  function baseAt(object, paths) {
                    var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                    while (++index < length) {
                      result2[index] = skip ? undefined2 : get2(object, paths[index]);
                    }
                    return result2;
                  }
                  function baseClamp(number, lower, upper) {
                    if (number === number) {
                      if (upper !== undefined2) {
                        number = number <= upper ? number : upper;
                      }
                      if (lower !== undefined2) {
                        number = number >= lower ? number : lower;
                      }
                    }
                    return number;
                  }
                  function baseClone(value, bitmask, customizer, key, object, stack) {
                    var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                    if (customizer) {
                      result2 = object ? customizer(value, key, object, stack) : customizer(value);
                    }
                    if (result2 !== undefined2) {
                      return result2;
                    }
                    if (!isObject2(value)) {
                      return value;
                    }
                    var isArr = isArray(value);
                    if (isArr) {
                      result2 = initCloneArray(value);
                      if (!isDeep) {
                        return copyArray(value, result2);
                      }
                    } else {
                      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
                      if (isBuffer(value)) {
                        return cloneBuffer(value, isDeep);
                      }
                      if (tag == objectTag || tag == argsTag || isFunc && !object) {
                        result2 = isFlat || isFunc ? {} : initCloneObject(value);
                        if (!isDeep) {
                          return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                        }
                      } else {
                        if (!cloneableTags[tag]) {
                          return object ? value : {};
                        }
                        result2 = initCloneByTag(value, tag, isDeep);
                      }
                    }
                    stack || (stack = new Stack());
                    var stacked = stack.get(value);
                    if (stacked) {
                      return stacked;
                    }
                    stack.set(value, result2);
                    if (isSet2(value)) {
                      value.forEach(function(subValue) {
                        result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
                      });
                    } else if (isMap2(value)) {
                      value.forEach(function(subValue, key2) {
                        result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                      });
                    }
                    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
                    var props = isArr ? undefined2 : keysFunc(value);
                    arrayEach(props || value, function(subValue, key2) {
                      if (props) {
                        key2 = subValue;
                        subValue = value[key2];
                      }
                      assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
                    });
                    return result2;
                  }
                  function baseConforms(source) {
                    var props = keys(source);
                    return function(object) {
                      return baseConformsTo(object, source, props);
                    };
                  }
                  function baseConformsTo(object, source, props) {
                    var length = props.length;
                    if (object == null) {
                      return !length;
                    }
                    object = Object2(object);
                    while (length--) {
                      var key = props[length], predicate = source[key], value = object[key];
                      if (value === undefined2 && !(key in object) || !predicate(value)) {
                        return false;
                      }
                    }
                    return true;
                  }
                  function baseDelay(func, wait, args) {
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    return setTimeout2(function() {
                      func.apply(undefined2, args);
                    }, wait);
                  }
                  function baseDifference(array, values2, iteratee2, comparator) {
                    var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                    if (!length) {
                      return result2;
                    }
                    if (iteratee2) {
                      values2 = arrayMap(values2, baseUnary(iteratee2));
                    }
                    if (comparator) {
                      includes2 = arrayIncludesWith;
                      isCommon = false;
                    } else if (values2.length >= LARGE_ARRAY_SIZE) {
                      includes2 = cacheHas;
                      isCommon = false;
                      values2 = new SetCache(values2);
                    }
                    outer:
                      while (++index < length) {
                        var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                        value = comparator || value !== 0 ? value : 0;
                        if (isCommon && computed === computed) {
                          var valuesIndex = valuesLength;
                          while (valuesIndex--) {
                            if (values2[valuesIndex] === computed) {
                              continue outer;
                            }
                          }
                          result2.push(value);
                        } else if (!includes2(values2, computed, comparator)) {
                          result2.push(value);
                        }
                      }
                    return result2;
                  }
                  var baseEach = createBaseEach(baseForOwn);
                  var baseEachRight = createBaseEach(baseForOwnRight, true);
                  function baseEvery(collection, predicate) {
                    var result2 = true;
                    baseEach(collection, function(value, index, collection2) {
                      result2 = !!predicate(value, index, collection2);
                      return result2;
                    });
                    return result2;
                  }
                  function baseExtremum(array, iteratee2, comparator) {
                    var index = -1, length = array.length;
                    while (++index < length) {
                      var value = array[index], current = iteratee2(value);
                      if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                        var computed = current, result2 = value;
                      }
                    }
                    return result2;
                  }
                  function baseFill(array, value, start, end) {
                    var length = array.length;
                    start = toInteger(start);
                    if (start < 0) {
                      start = -start > length ? 0 : length + start;
                    }
                    end = end === undefined2 || end > length ? length : toInteger(end);
                    if (end < 0) {
                      end += length;
                    }
                    end = start > end ? 0 : toLength(end);
                    while (start < end) {
                      array[start++] = value;
                    }
                    return array;
                  }
                  function baseFilter(collection, predicate) {
                    var result2 = [];
                    baseEach(collection, function(value, index, collection2) {
                      if (predicate(value, index, collection2)) {
                        result2.push(value);
                      }
                    });
                    return result2;
                  }
                  function baseFlatten(array, depth, predicate, isStrict, result2) {
                    var index = -1, length = array.length;
                    predicate || (predicate = isFlattenable);
                    result2 || (result2 = []);
                    while (++index < length) {
                      var value = array[index];
                      if (depth > 0 && predicate(value)) {
                        if (depth > 1) {
                          baseFlatten(value, depth - 1, predicate, isStrict, result2);
                        } else {
                          arrayPush(result2, value);
                        }
                      } else if (!isStrict) {
                        result2[result2.length] = value;
                      }
                    }
                    return result2;
                  }
                  var baseFor = createBaseFor();
                  var baseForRight = createBaseFor(true);
                  function baseForOwn(object, iteratee2) {
                    return object && baseFor(object, iteratee2, keys);
                  }
                  function baseForOwnRight(object, iteratee2) {
                    return object && baseForRight(object, iteratee2, keys);
                  }
                  function baseFunctions(object, props) {
                    return arrayFilter(props, function(key) {
                      return isFunction(object[key]);
                    });
                  }
                  function baseGet(object, path) {
                    path = castPath(path, object);
                    var index = 0, length = path.length;
                    while (object != null && index < length) {
                      object = object[toKey(path[index++])];
                    }
                    return index && index == length ? object : undefined2;
                  }
                  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                    var result2 = keysFunc(object);
                    return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
                  }
                  function baseGetTag(value) {
                    if (value == null) {
                      return value === undefined2 ? undefinedTag : nullTag;
                    }
                    return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
                  }
                  function baseGt(value, other) {
                    return value > other;
                  }
                  function baseHas(object, key) {
                    return object != null && hasOwnProperty2.call(object, key);
                  }
                  function baseHasIn(object, key) {
                    return object != null && key in Object2(object);
                  }
                  function baseInRange(number, start, end) {
                    return number >= nativeMin(start, end) && number < nativeMax(start, end);
                  }
                  function baseIntersection(arrays, iteratee2, comparator) {
                    var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                    while (othIndex--) {
                      var array = arrays[othIndex];
                      if (othIndex && iteratee2) {
                        array = arrayMap(array, baseUnary(iteratee2));
                      }
                      maxLength = nativeMin(array.length, maxLength);
                      caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
                    }
                    array = arrays[0];
                    var index = -1, seen = caches[0];
                    outer:
                      while (++index < length && result2.length < maxLength) {
                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                        value = comparator || value !== 0 ? value : 0;
                        if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                          othIndex = othLength;
                          while (--othIndex) {
                            var cache = caches[othIndex];
                            if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                              continue outer;
                            }
                          }
                          if (seen) {
                            seen.push(computed);
                          }
                          result2.push(value);
                        }
                      }
                    return result2;
                  }
                  function baseInverter(object, setter, iteratee2, accumulator) {
                    baseForOwn(object, function(value, key, object2) {
                      setter(accumulator, iteratee2(value), key, object2);
                    });
                    return accumulator;
                  }
                  function baseInvoke(object, path, args) {
                    path = castPath(path, object);
                    object = parent(object, path);
                    var func = object == null ? object : object[toKey(last(path))];
                    return func == null ? undefined2 : apply(func, object, args);
                  }
                  function baseIsArguments(value) {
                    return isObjectLike(value) && baseGetTag(value) == argsTag;
                  }
                  function baseIsArrayBuffer(value) {
                    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
                  }
                  function baseIsDate(value) {
                    return isObjectLike(value) && baseGetTag(value) == dateTag;
                  }
                  function baseIsEqual(value, other, bitmask, customizer, stack) {
                    if (value === other) {
                      return true;
                    }
                    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
                      return value !== value && other !== other;
                    }
                    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
                  }
                  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
                    objTag = objTag == argsTag ? objectTag : objTag;
                    othTag = othTag == argsTag ? objectTag : othTag;
                    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
                    if (isSameTag && isBuffer(object)) {
                      if (!isBuffer(other)) {
                        return false;
                      }
                      objIsArr = true;
                      objIsObj = false;
                    }
                    if (isSameTag && !objIsObj) {
                      stack || (stack = new Stack());
                      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                    }
                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                      var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
                      if (objIsWrapped || othIsWrapped) {
                        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                        stack || (stack = new Stack());
                        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
                      }
                    }
                    if (!isSameTag) {
                      return false;
                    }
                    stack || (stack = new Stack());
                    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
                  }
                  function baseIsMap(value) {
                    return isObjectLike(value) && getTag(value) == mapTag;
                  }
                  function baseIsMatch(object, source, matchData, customizer) {
                    var index = matchData.length, length = index, noCustomizer = !customizer;
                    if (object == null) {
                      return !length;
                    }
                    object = Object2(object);
                    while (index--) {
                      var data = matchData[index];
                      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                        return false;
                      }
                    }
                    while (++index < length) {
                      data = matchData[index];
                      var key = data[0], objValue = object[key], srcValue = data[1];
                      if (noCustomizer && data[2]) {
                        if (objValue === undefined2 && !(key in object)) {
                          return false;
                        }
                      } else {
                        var stack = new Stack();
                        if (customizer) {
                          var result2 = customizer(objValue, srcValue, key, object, source, stack);
                        }
                        if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                          return false;
                        }
                      }
                    }
                    return true;
                  }
                  function baseIsNative(value) {
                    if (!isObject2(value) || isMasked(value)) {
                      return false;
                    }
                    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                    return pattern.test(toSource(value));
                  }
                  function baseIsRegExp(value) {
                    return isObjectLike(value) && baseGetTag(value) == regexpTag;
                  }
                  function baseIsSet(value) {
                    return isObjectLike(value) && getTag(value) == setTag;
                  }
                  function baseIsTypedArray(value) {
                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
                  }
                  function baseIteratee(value) {
                    if (typeof value == "function") {
                      return value;
                    }
                    if (value == null) {
                      return identity;
                    }
                    if (typeof value == "object") {
                      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
                    }
                    return property(value);
                  }
                  function baseKeys(object) {
                    if (!isPrototype(object)) {
                      return nativeKeys(object);
                    }
                    var result2 = [];
                    for (var key in Object2(object)) {
                      if (hasOwnProperty2.call(object, key) && key != "constructor") {
                        result2.push(key);
                      }
                    }
                    return result2;
                  }
                  function baseKeysIn(object) {
                    if (!isObject2(object)) {
                      return nativeKeysIn(object);
                    }
                    var isProto = isPrototype(object), result2 = [];
                    for (var key in object) {
                      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                        result2.push(key);
                      }
                    }
                    return result2;
                  }
                  function baseLt(value, other) {
                    return value < other;
                  }
                  function baseMap(collection, iteratee2) {
                    var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                    baseEach(collection, function(value, key, collection2) {
                      result2[++index] = iteratee2(value, key, collection2);
                    });
                    return result2;
                  }
                  function baseMatches(source) {
                    var matchData = getMatchData(source);
                    if (matchData.length == 1 && matchData[0][2]) {
                      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
                    }
                    return function(object) {
                      return object === source || baseIsMatch(object, source, matchData);
                    };
                  }
                  function baseMatchesProperty(path, srcValue) {
                    if (isKey(path) && isStrictComparable(srcValue)) {
                      return matchesStrictComparable(toKey(path), srcValue);
                    }
                    return function(object) {
                      var objValue = get2(object, path);
                      return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
                    };
                  }
                  function baseMerge(object, source, srcIndex, customizer, stack) {
                    if (object === source) {
                      return;
                    }
                    baseFor(source, function(srcValue, key) {
                      stack || (stack = new Stack());
                      if (isObject2(srcValue)) {
                        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                      } else {
                        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                        if (newValue === undefined2) {
                          newValue = srcValue;
                        }
                        assignMergeValue(object, key, newValue);
                      }
                    }, keysIn);
                  }
                  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
                    if (stacked) {
                      assignMergeValue(object, key, stacked);
                      return;
                    }
                    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
                    var isCommon = newValue === undefined2;
                    if (isCommon) {
                      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                      newValue = srcValue;
                      if (isArr || isBuff || isTyped) {
                        if (isArray(objValue)) {
                          newValue = objValue;
                        } else if (isArrayLikeObject(objValue)) {
                          newValue = copyArray(objValue);
                        } else if (isBuff) {
                          isCommon = false;
                          newValue = cloneBuffer(srcValue, true);
                        } else if (isTyped) {
                          isCommon = false;
                          newValue = cloneTypedArray(srcValue, true);
                        } else {
                          newValue = [];
                        }
                      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                        newValue = objValue;
                        if (isArguments(objValue)) {
                          newValue = toPlainObject(objValue);
                        } else if (!isObject2(objValue) || isFunction(objValue)) {
                          newValue = initCloneObject(srcValue);
                        }
                      } else {
                        isCommon = false;
                      }
                    }
                    if (isCommon) {
                      stack.set(srcValue, newValue);
                      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
                      stack["delete"](srcValue);
                    }
                    assignMergeValue(object, key, newValue);
                  }
                  function baseNth(array, n2) {
                    var length = array.length;
                    if (!length) {
                      return;
                    }
                    n2 += n2 < 0 ? length : 0;
                    return isIndex(n2, length) ? array[n2] : undefined2;
                  }
                  function baseOrderBy(collection, iteratees, orders) {
                    if (iteratees.length) {
                      iteratees = arrayMap(iteratees, function(iteratee2) {
                        if (isArray(iteratee2)) {
                          return function(value) {
                            return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                          };
                        }
                        return iteratee2;
                      });
                    } else {
                      iteratees = [identity];
                    }
                    var index = -1;
                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                    var result2 = baseMap(collection, function(value, key, collection2) {
                      var criteria = arrayMap(iteratees, function(iteratee2) {
                        return iteratee2(value);
                      });
                      return { "criteria": criteria, "index": ++index, "value": value };
                    });
                    return baseSortBy(result2, function(object, other) {
                      return compareMultiple(object, other, orders);
                    });
                  }
                  function basePick(object, paths) {
                    return basePickBy(object, paths, function(value, path) {
                      return hasIn(object, path);
                    });
                  }
                  function basePickBy(object, paths, predicate) {
                    var index = -1, length = paths.length, result2 = {};
                    while (++index < length) {
                      var path = paths[index], value = baseGet(object, path);
                      if (predicate(value, path)) {
                        baseSet(result2, castPath(path, object), value);
                      }
                    }
                    return result2;
                  }
                  function basePropertyDeep(path) {
                    return function(object) {
                      return baseGet(object, path);
                    };
                  }
                  function basePullAll(array, values2, iteratee2, comparator) {
                    var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
                    if (array === values2) {
                      values2 = copyArray(values2);
                    }
                    if (iteratee2) {
                      seen = arrayMap(array, baseUnary(iteratee2));
                    }
                    while (++index < length) {
                      var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
                      while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                        if (seen !== array) {
                          splice.call(seen, fromIndex, 1);
                        }
                        splice.call(array, fromIndex, 1);
                      }
                    }
                    return array;
                  }
                  function basePullAt(array, indexes) {
                    var length = array ? indexes.length : 0, lastIndex = length - 1;
                    while (length--) {
                      var index = indexes[length];
                      if (length == lastIndex || index !== previous) {
                        var previous = index;
                        if (isIndex(index)) {
                          splice.call(array, index, 1);
                        } else {
                          baseUnset(array, index);
                        }
                      }
                    }
                    return array;
                  }
                  function baseRandom(lower, upper) {
                    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
                  }
                  function baseRange(start, end, step, fromRight) {
                    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                    while (length--) {
                      result2[fromRight ? length : ++index] = start;
                      start += step;
                    }
                    return result2;
                  }
                  function baseRepeat(string, n2) {
                    var result2 = "";
                    if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
                      return result2;
                    }
                    do {
                      if (n2 % 2) {
                        result2 += string;
                      }
                      n2 = nativeFloor(n2 / 2);
                      if (n2) {
                        string += string;
                      }
                    } while (n2);
                    return result2;
                  }
                  function baseRest(func, start) {
                    return setToString(overRest(func, start, identity), func + "");
                  }
                  function baseSample(collection) {
                    return arraySample(values(collection));
                  }
                  function baseSampleSize(collection, n2) {
                    var array = values(collection);
                    return shuffleSelf(array, baseClamp(n2, 0, array.length));
                  }
                  function baseSet(object, path, value, customizer) {
                    if (!isObject2(object)) {
                      return object;
                    }
                    path = castPath(path, object);
                    var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                    while (nested != null && ++index < length) {
                      var key = toKey(path[index]), newValue = value;
                      if (key === "__proto__" || key === "constructor" || key === "prototype") {
                        return object;
                      }
                      if (index != lastIndex) {
                        var objValue = nested[key];
                        newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                        if (newValue === undefined2) {
                          newValue = isObject2(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                        }
                      }
                      assignValue(nested, key, newValue);
                      nested = nested[key];
                    }
                    return object;
                  }
                  var baseSetData = !metaMap ? identity : function(func, data) {
                    metaMap.set(func, data);
                    return func;
                  };
                  var baseSetToString = !defineProperty ? identity : function(func, string) {
                    return defineProperty(func, "toString", {
                      "configurable": true,
                      "enumerable": false,
                      "value": constant(string),
                      "writable": true
                    });
                  };
                  function baseShuffle(collection) {
                    return shuffleSelf(values(collection));
                  }
                  function baseSlice(array, start, end) {
                    var index = -1, length = array.length;
                    if (start < 0) {
                      start = -start > length ? 0 : length + start;
                    }
                    end = end > length ? length : end;
                    if (end < 0) {
                      end += length;
                    }
                    length = start > end ? 0 : end - start >>> 0;
                    start >>>= 0;
                    var result2 = Array2(length);
                    while (++index < length) {
                      result2[index] = array[index + start];
                    }
                    return result2;
                  }
                  function baseSome(collection, predicate) {
                    var result2;
                    baseEach(collection, function(value, index, collection2) {
                      result2 = predicate(value, index, collection2);
                      return !result2;
                    });
                    return !!result2;
                  }
                  function baseSortedIndex(array, value, retHighest) {
                    var low = 0, high = array == null ? low : array.length;
                    if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                      while (low < high) {
                        var mid = low + high >>> 1, computed = array[mid];
                        if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                          low = mid + 1;
                        } else {
                          high = mid;
                        }
                      }
                      return high;
                    }
                    return baseSortedIndexBy(array, value, identity, retHighest);
                  }
                  function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                    var low = 0, high = array == null ? 0 : array.length;
                    if (high === 0) {
                      return 0;
                    }
                    value = iteratee2(value);
                    var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
                    while (low < high) {
                      var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
                      if (valIsNaN) {
                        var setLow = retHighest || othIsReflexive;
                      } else if (valIsUndefined) {
                        setLow = othIsReflexive && (retHighest || othIsDefined);
                      } else if (valIsNull) {
                        setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                      } else if (valIsSymbol) {
                        setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                      } else if (othIsNull || othIsSymbol) {
                        setLow = false;
                      } else {
                        setLow = retHighest ? computed <= value : computed < value;
                      }
                      if (setLow) {
                        low = mid + 1;
                      } else {
                        high = mid;
                      }
                    }
                    return nativeMin(high, MAX_ARRAY_INDEX);
                  }
                  function baseSortedUniq(array, iteratee2) {
                    var index = -1, length = array.length, resIndex = 0, result2 = [];
                    while (++index < length) {
                      var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                      if (!index || !eq(computed, seen)) {
                        var seen = computed;
                        result2[resIndex++] = value === 0 ? 0 : value;
                      }
                    }
                    return result2;
                  }
                  function baseToNumber(value) {
                    if (typeof value == "number") {
                      return value;
                    }
                    if (isSymbol(value)) {
                      return NAN;
                    }
                    return +value;
                  }
                  function baseToString(value) {
                    if (typeof value == "string") {
                      return value;
                    }
                    if (isArray(value)) {
                      return arrayMap(value, baseToString) + "";
                    }
                    if (isSymbol(value)) {
                      return symbolToString ? symbolToString.call(value) : "";
                    }
                    var result2 = value + "";
                    return result2 == "0" && 1 / value == -Infinity ? "-0" : result2;
                  }
                  function baseUniq(array, iteratee2, comparator) {
                    var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
                    if (comparator) {
                      isCommon = false;
                      includes2 = arrayIncludesWith;
                    } else if (length >= LARGE_ARRAY_SIZE) {
                      var set2 = iteratee2 ? null : createSet(array);
                      if (set2) {
                        return setToArray(set2);
                      }
                      isCommon = false;
                      includes2 = cacheHas;
                      seen = new SetCache();
                    } else {
                      seen = iteratee2 ? [] : result2;
                    }
                    outer:
                      while (++index < length) {
                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                        value = comparator || value !== 0 ? value : 0;
                        if (isCommon && computed === computed) {
                          var seenIndex = seen.length;
                          while (seenIndex--) {
                            if (seen[seenIndex] === computed) {
                              continue outer;
                            }
                          }
                          if (iteratee2) {
                            seen.push(computed);
                          }
                          result2.push(value);
                        } else if (!includes2(seen, computed, comparator)) {
                          if (seen !== result2) {
                            seen.push(computed);
                          }
                          result2.push(value);
                        }
                      }
                    return result2;
                  }
                  function baseUnset(object, path) {
                    path = castPath(path, object);
                    object = parent(object, path);
                    return object == null || delete object[toKey(last(path))];
                  }
                  function baseUpdate(object, path, updater, customizer) {
                    return baseSet(object, path, updater(baseGet(object, path)), customizer);
                  }
                  function baseWhile(array, predicate, isDrop, fromRight) {
                    var length = array.length, index = fromRight ? length : -1;
                    while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                    }
                    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
                  }
                  function baseWrapperValue(value, actions) {
                    var result2 = value;
                    if (result2 instanceof LazyWrapper) {
                      result2 = result2.value();
                    }
                    return arrayReduce(actions, function(result3, action2) {
                      return action2.func.apply(action2.thisArg, arrayPush([result3], action2.args));
                    }, result2);
                  }
                  function baseXor(arrays, iteratee2, comparator) {
                    var length = arrays.length;
                    if (length < 2) {
                      return length ? baseUniq(arrays[0]) : [];
                    }
                    var index = -1, result2 = Array2(length);
                    while (++index < length) {
                      var array = arrays[index], othIndex = -1;
                      while (++othIndex < length) {
                        if (othIndex != index) {
                          result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                        }
                      }
                    }
                    return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
                  }
                  function baseZipObject(props, values2, assignFunc) {
                    var index = -1, length = props.length, valsLength = values2.length, result2 = {};
                    while (++index < length) {
                      var value = index < valsLength ? values2[index] : undefined2;
                      assignFunc(result2, props[index], value);
                    }
                    return result2;
                  }
                  function castArrayLikeObject(value) {
                    return isArrayLikeObject(value) ? value : [];
                  }
                  function castFunction(value) {
                    return typeof value == "function" ? value : identity;
                  }
                  function castPath(value, object) {
                    if (isArray(value)) {
                      return value;
                    }
                    return isKey(value, object) ? [value] : stringToPath(toString2(value));
                  }
                  var castRest = baseRest;
                  function castSlice(array, start, end) {
                    var length = array.length;
                    end = end === undefined2 ? length : end;
                    return !start && end >= length ? array : baseSlice(array, start, end);
                  }
                  var clearTimeout2 = ctxClearTimeout || function(id) {
                    return root.clearTimeout(id);
                  };
                  function cloneBuffer(buffer, isDeep) {
                    if (isDeep) {
                      return buffer.slice();
                    }
                    var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                    buffer.copy(result2);
                    return result2;
                  }
                  function cloneArrayBuffer(arrayBuffer) {
                    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
                    return result2;
                  }
                  function cloneDataView(dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
                  }
                  function cloneRegExp(regexp) {
                    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    result2.lastIndex = regexp.lastIndex;
                    return result2;
                  }
                  function cloneSymbol(symbol) {
                    return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
                  }
                  function cloneTypedArray(typedArray, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
                  }
                  function compareAscending(value, other) {
                    if (value !== other) {
                      var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
                      var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
                      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                        return 1;
                      }
                      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                        return -1;
                      }
                    }
                    return 0;
                  }
                  function compareMultiple(object, other, orders) {
                    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                    while (++index < length) {
                      var result2 = compareAscending(objCriteria[index], othCriteria[index]);
                      if (result2) {
                        if (index >= ordersLength) {
                          return result2;
                        }
                        var order = orders[index];
                        return result2 * (order == "desc" ? -1 : 1);
                      }
                    }
                    return object.index - other.index;
                  }
                  function composeArgs(args, partials, holders, isCurried) {
                    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                    while (++leftIndex < leftLength) {
                      result2[leftIndex] = partials[leftIndex];
                    }
                    while (++argsIndex < holdersLength) {
                      if (isUncurried || argsIndex < argsLength) {
                        result2[holders[argsIndex]] = args[argsIndex];
                      }
                    }
                    while (rangeLength--) {
                      result2[leftIndex++] = args[argsIndex++];
                    }
                    return result2;
                  }
                  function composeArgsRight(args, partials, holders, isCurried) {
                    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                    while (++argsIndex < rangeLength) {
                      result2[argsIndex] = args[argsIndex];
                    }
                    var offset = argsIndex;
                    while (++rightIndex < rightLength) {
                      result2[offset + rightIndex] = partials[rightIndex];
                    }
                    while (++holdersIndex < holdersLength) {
                      if (isUncurried || argsIndex < argsLength) {
                        result2[offset + holders[holdersIndex]] = args[argsIndex++];
                      }
                    }
                    return result2;
                  }
                  function copyArray(source, array) {
                    var index = -1, length = source.length;
                    array || (array = Array2(length));
                    while (++index < length) {
                      array[index] = source[index];
                    }
                    return array;
                  }
                  function copyObject(source, props, object, customizer) {
                    var isNew = !object;
                    object || (object = {});
                    var index = -1, length = props.length;
                    while (++index < length) {
                      var key = props[index];
                      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
                      if (newValue === undefined2) {
                        newValue = source[key];
                      }
                      if (isNew) {
                        baseAssignValue(object, key, newValue);
                      } else {
                        assignValue(object, key, newValue);
                      }
                    }
                    return object;
                  }
                  function copySymbols(source, object) {
                    return copyObject(source, getSymbols(source), object);
                  }
                  function copySymbolsIn(source, object) {
                    return copyObject(source, getSymbolsIn(source), object);
                  }
                  function createAggregator(setter, initializer) {
                    return function(collection, iteratee2) {
                      var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                      return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                    };
                  }
                  function createAssigner(assigner) {
                    return baseRest(function(object, sources) {
                      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
                      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
                      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                        customizer = length < 3 ? undefined2 : customizer;
                        length = 1;
                      }
                      object = Object2(object);
                      while (++index < length) {
                        var source = sources[index];
                        if (source) {
                          assigner(object, source, index, customizer);
                        }
                      }
                      return object;
                    });
                  }
                  function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee2) {
                      if (collection == null) {
                        return collection;
                      }
                      if (!isArrayLike(collection)) {
                        return eachFunc(collection, iteratee2);
                      }
                      var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
                      while (fromRight ? index-- : ++index < length) {
                        if (iteratee2(iterable[index], index, iterable) === false) {
                          break;
                        }
                      }
                      return collection;
                    };
                  }
                  function createBaseFor(fromRight) {
                    return function(object, iteratee2, keysFunc) {
                      var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                      while (length--) {
                        var key = props[fromRight ? length : ++index];
                        if (iteratee2(iterable[key], key, iterable) === false) {
                          break;
                        }
                      }
                      return object;
                    };
                  }
                  function createBind(func, bitmask, thisArg) {
                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                    function wrapper() {
                      var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                      return fn.apply(isBind ? thisArg : this, arguments);
                    }
                    return wrapper;
                  }
                  function createCaseFirst(methodName) {
                    return function(string) {
                      string = toString2(string);
                      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
                      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
                      var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                      return chr[methodName]() + trailing;
                    };
                  }
                  function createCompounder(callback) {
                    return function(string) {
                      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
                    };
                  }
                  function createCtor(Ctor) {
                    return function() {
                      var args = arguments;
                      switch (args.length) {
                        case 0:
                          return new Ctor();
                        case 1:
                          return new Ctor(args[0]);
                        case 2:
                          return new Ctor(args[0], args[1]);
                        case 3:
                          return new Ctor(args[0], args[1], args[2]);
                        case 4:
                          return new Ctor(args[0], args[1], args[2], args[3]);
                        case 5:
                          return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                        case 6:
                          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                        case 7:
                          return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                      }
                      var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                      return isObject2(result2) ? result2 : thisBinding;
                    };
                  }
                  function createCurry(func, bitmask, arity) {
                    var Ctor = createCtor(func);
                    function wrapper() {
                      var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
                      while (index--) {
                        args[index] = arguments[index];
                      }
                      var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                      length -= holders.length;
                      if (length < arity) {
                        return createRecurry(
                          func,
                          bitmask,
                          createHybrid,
                          wrapper.placeholder,
                          undefined2,
                          args,
                          holders,
                          undefined2,
                          undefined2,
                          arity - length
                        );
                      }
                      var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                      return apply(fn, this, args);
                    }
                    return wrapper;
                  }
                  function createFind(findIndexFunc) {
                    return function(collection, predicate, fromIndex) {
                      var iterable = Object2(collection);
                      if (!isArrayLike(collection)) {
                        var iteratee2 = getIteratee(predicate, 3);
                        collection = keys(collection);
                        predicate = function(key) {
                          return iteratee2(iterable[key], key, iterable);
                        };
                      }
                      var index = findIndexFunc(collection, predicate, fromIndex);
                      return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
                    };
                  }
                  function createFlow(fromRight) {
                    return flatRest(function(funcs) {
                      var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                      if (fromRight) {
                        funcs.reverse();
                      }
                      while (index--) {
                        var func = funcs[index];
                        if (typeof func != "function") {
                          throw new TypeError2(FUNC_ERROR_TEXT);
                        }
                        if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                          var wrapper = new LodashWrapper([], true);
                        }
                      }
                      index = wrapper ? index : length;
                      while (++index < length) {
                        func = funcs[index];
                        var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                        if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                          wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                        } else {
                          wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                        }
                      }
                      return function() {
                        var args = arguments, value = args[0];
                        if (wrapper && args.length == 1 && isArray(value)) {
                          return wrapper.plant(value).value();
                        }
                        var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                        while (++index2 < length) {
                          result2 = funcs[index2].call(this, result2);
                        }
                        return result2;
                      };
                    });
                  }
                  function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                    var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
                    function wrapper() {
                      var length = arguments.length, args = Array2(length), index = length;
                      while (index--) {
                        args[index] = arguments[index];
                      }
                      if (isCurried) {
                        var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                      }
                      if (partials) {
                        args = composeArgs(args, partials, holders, isCurried);
                      }
                      if (partialsRight) {
                        args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                      }
                      length -= holdersCount;
                      if (isCurried && length < arity) {
                        var newHolders = replaceHolders(args, placeholder);
                        return createRecurry(
                          func,
                          bitmask,
                          createHybrid,
                          wrapper.placeholder,
                          thisArg,
                          args,
                          newHolders,
                          argPos,
                          ary2,
                          arity - length
                        );
                      }
                      var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                      length = args.length;
                      if (argPos) {
                        args = reorder(args, argPos);
                      } else if (isFlip && length > 1) {
                        args.reverse();
                      }
                      if (isAry && ary2 < length) {
                        args.length = ary2;
                      }
                      if (this && this !== root && this instanceof wrapper) {
                        fn = Ctor || createCtor(fn);
                      }
                      return fn.apply(thisBinding, args);
                    }
                    return wrapper;
                  }
                  function createInverter(setter, toIteratee) {
                    return function(object, iteratee2) {
                      return baseInverter(object, setter, toIteratee(iteratee2), {});
                    };
                  }
                  function createMathOperation(operator, defaultValue) {
                    return function(value, other) {
                      var result2;
                      if (value === undefined2 && other === undefined2) {
                        return defaultValue;
                      }
                      if (value !== undefined2) {
                        result2 = value;
                      }
                      if (other !== undefined2) {
                        if (result2 === undefined2) {
                          return other;
                        }
                        if (typeof value == "string" || typeof other == "string") {
                          value = baseToString(value);
                          other = baseToString(other);
                        } else {
                          value = baseToNumber(value);
                          other = baseToNumber(other);
                        }
                        result2 = operator(value, other);
                      }
                      return result2;
                    };
                  }
                  function createOver(arrayFunc) {
                    return flatRest(function(iteratees) {
                      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
                      return baseRest(function(args) {
                        var thisArg = this;
                        return arrayFunc(iteratees, function(iteratee2) {
                          return apply(iteratee2, thisArg, args);
                        });
                      });
                    });
                  }
                  function createPadding(length, chars) {
                    chars = chars === undefined2 ? " " : baseToString(chars);
                    var charsLength = chars.length;
                    if (charsLength < 2) {
                      return charsLength ? baseRepeat(chars, length) : chars;
                    }
                    var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                    return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
                  }
                  function createPartial(func, bitmask, thisArg, partials) {
                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                    function wrapper() {
                      var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                      while (++leftIndex < leftLength) {
                        args[leftIndex] = partials[leftIndex];
                      }
                      while (argsLength--) {
                        args[leftIndex++] = arguments[++argsIndex];
                      }
                      return apply(fn, isBind ? thisArg : this, args);
                    }
                    return wrapper;
                  }
                  function createRange(fromRight) {
                    return function(start, end, step) {
                      if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
                        end = step = undefined2;
                      }
                      start = toFinite(start);
                      if (end === undefined2) {
                        end = start;
                        start = 0;
                      } else {
                        end = toFinite(end);
                      }
                      step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
                      return baseRange(start, end, step, fromRight);
                    };
                  }
                  function createRelationalOperation(operator) {
                    return function(value, other) {
                      if (!(typeof value == "string" && typeof other == "string")) {
                        value = toNumber(value);
                        other = toNumber(other);
                      }
                      return operator(value, other);
                    };
                  }
                  function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                    var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
                    bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                      bitmask &= -4;
                    }
                    var newData = [
                      func,
                      bitmask,
                      thisArg,
                      newPartials,
                      newHolders,
                      newPartialsRight,
                      newHoldersRight,
                      argPos,
                      ary2,
                      arity
                    ];
                    var result2 = wrapFunc.apply(undefined2, newData);
                    if (isLaziable(func)) {
                      setData(result2, newData);
                    }
                    result2.placeholder = placeholder;
                    return setWrapToString(result2, func, bitmask);
                  }
                  function createRound(methodName) {
                    var func = Math2[methodName];
                    return function(number, precision) {
                      number = toNumber(number);
                      precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
                      if (precision && nativeIsFinite(number)) {
                        var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                        pair = (toString2(value) + "e").split("e");
                        return +(pair[0] + "e" + (+pair[1] - precision));
                      }
                      return func(number);
                    };
                  }
                  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
                    return new Set2(values2);
                  };
                  function createToPairs(keysFunc) {
                    return function(object) {
                      var tag = getTag(object);
                      if (tag == mapTag) {
                        return mapToArray(object);
                      }
                      if (tag == setTag) {
                        return setToPairs(object);
                      }
                      return baseToPairs(object, keysFunc(object));
                    };
                  }
                  function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                    if (!isBindKey && typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    var length = partials ? partials.length : 0;
                    if (!length) {
                      bitmask &= -97;
                      partials = holders = undefined2;
                    }
                    ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
                    arity = arity === undefined2 ? arity : toInteger(arity);
                    length -= holders ? holders.length : 0;
                    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                      var partialsRight = partials, holdersRight = holders;
                      partials = holders = undefined2;
                    }
                    var data = isBindKey ? undefined2 : getData(func);
                    var newData = [
                      func,
                      bitmask,
                      thisArg,
                      partials,
                      holders,
                      partialsRight,
                      holdersRight,
                      argPos,
                      ary2,
                      arity
                    ];
                    if (data) {
                      mergeData(newData, data);
                    }
                    func = newData[0];
                    bitmask = newData[1];
                    thisArg = newData[2];
                    partials = newData[3];
                    holders = newData[4];
                    arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
                    if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                      bitmask &= -25;
                    }
                    if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                      var result2 = createBind(func, bitmask, thisArg);
                    } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                      result2 = createCurry(func, bitmask, arity);
                    } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                      result2 = createPartial(func, bitmask, thisArg, partials);
                    } else {
                      result2 = createHybrid.apply(undefined2, newData);
                    }
                    var setter = data ? baseSetData : setData;
                    return setWrapToString(setter(result2, newData), func, bitmask);
                  }
                  function customDefaultsAssignIn(objValue, srcValue, key, object) {
                    if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                      return srcValue;
                    }
                    return objValue;
                  }
                  function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                    if (isObject2(objValue) && isObject2(srcValue)) {
                      stack.set(srcValue, objValue);
                      baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
                      stack["delete"](srcValue);
                    }
                    return objValue;
                  }
                  function customOmitClone(value) {
                    return isPlainObject(value) ? undefined2 : value;
                  }
                  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                      return false;
                    }
                    var arrStacked = stack.get(array);
                    var othStacked = stack.get(other);
                    if (arrStacked && othStacked) {
                      return arrStacked == other && othStacked == array;
                    }
                    var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
                    stack.set(array, other);
                    stack.set(other, array);
                    while (++index < arrLength) {
                      var arrValue = array[index], othValue = other[index];
                      if (customizer) {
                        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                      }
                      if (compared !== undefined2) {
                        if (compared) {
                          continue;
                        }
                        result2 = false;
                        break;
                      }
                      if (seen) {
                        if (!arraySome(other, function(othValue2, othIndex) {
                          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                            return seen.push(othIndex);
                          }
                        })) {
                          result2 = false;
                          break;
                        }
                      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        result2 = false;
                        break;
                      }
                    }
                    stack["delete"](array);
                    stack["delete"](other);
                    return result2;
                  }
                  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                    switch (tag) {
                      case dataViewTag:
                        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                          return false;
                        }
                        object = object.buffer;
                        other = other.buffer;
                      case arrayBufferTag:
                        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                          return false;
                        }
                        return true;
                      case boolTag:
                      case dateTag:
                      case numberTag:
                        return eq(+object, +other);
                      case errorTag:
                        return object.name == other.name && object.message == other.message;
                      case regexpTag:
                      case stringTag:
                        return object == other + "";
                      case mapTag:
                        var convert = mapToArray;
                      case setTag:
                        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                        convert || (convert = setToArray);
                        if (object.size != other.size && !isPartial) {
                          return false;
                        }
                        var stacked = stack.get(object);
                        if (stacked) {
                          return stacked == other;
                        }
                        bitmask |= COMPARE_UNORDERED_FLAG;
                        stack.set(object, other);
                        var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                        stack["delete"](object);
                        return result2;
                      case symbolTag:
                        if (symbolValueOf) {
                          return symbolValueOf.call(object) == symbolValueOf.call(other);
                        }
                    }
                    return false;
                  }
                  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
                    if (objLength != othLength && !isPartial) {
                      return false;
                    }
                    var index = objLength;
                    while (index--) {
                      var key = objProps[index];
                      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                        return false;
                      }
                    }
                    var objStacked = stack.get(object);
                    var othStacked = stack.get(other);
                    if (objStacked && othStacked) {
                      return objStacked == other && othStacked == object;
                    }
                    var result2 = true;
                    stack.set(object, other);
                    stack.set(other, object);
                    var skipCtor = isPartial;
                    while (++index < objLength) {
                      key = objProps[index];
                      var objValue = object[key], othValue = other[key];
                      if (customizer) {
                        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                      }
                      if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                        result2 = false;
                        break;
                      }
                      skipCtor || (skipCtor = key == "constructor");
                    }
                    if (result2 && !skipCtor) {
                      var objCtor = object.constructor, othCtor = other.constructor;
                      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                        result2 = false;
                      }
                    }
                    stack["delete"](object);
                    stack["delete"](other);
                    return result2;
                  }
                  function flatRest(func) {
                    return setToString(overRest(func, undefined2, flatten), func + "");
                  }
                  function getAllKeys(object) {
                    return baseGetAllKeys(object, keys, getSymbols);
                  }
                  function getAllKeysIn(object) {
                    return baseGetAllKeys(object, keysIn, getSymbolsIn);
                  }
                  var getData = !metaMap ? noop2 : function(func) {
                    return metaMap.get(func);
                  };
                  function getFuncName(func) {
                    var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
                    while (length--) {
                      var data = array[length], otherFunc = data.func;
                      if (otherFunc == null || otherFunc == func) {
                        return data.name;
                      }
                    }
                    return result2;
                  }
                  function getHolder(func) {
                    var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
                    return object.placeholder;
                  }
                  function getIteratee() {
                    var result2 = lodash.iteratee || iteratee;
                    result2 = result2 === iteratee ? baseIteratee : result2;
                    return arguments.length ? result2(arguments[0], arguments[1]) : result2;
                  }
                  function getMapData(map2, key) {
                    var data = map2.__data__;
                    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
                  }
                  function getMatchData(object) {
                    var result2 = keys(object), length = result2.length;
                    while (length--) {
                      var key = result2[length], value = object[key];
                      result2[length] = [key, value, isStrictComparable(value)];
                    }
                    return result2;
                  }
                  function getNative(object, key) {
                    var value = getValue(object, key);
                    return baseIsNative(value) ? value : undefined2;
                  }
                  function getRawTag(value) {
                    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
                    try {
                      value[symToStringTag] = undefined2;
                      var unmasked = true;
                    } catch (e2) {
                    }
                    var result2 = nativeObjectToString.call(value);
                    if (unmasked) {
                      if (isOwn) {
                        value[symToStringTag] = tag;
                      } else {
                        delete value[symToStringTag];
                      }
                    }
                    return result2;
                  }
                  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
                    if (object == null) {
                      return [];
                    }
                    object = Object2(object);
                    return arrayFilter(nativeGetSymbols(object), function(symbol) {
                      return propertyIsEnumerable.call(object, symbol);
                    });
                  };
                  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
                    var result2 = [];
                    while (object) {
                      arrayPush(result2, getSymbols(object));
                      object = getPrototype(object);
                    }
                    return result2;
                  };
                  var getTag = baseGetTag;
                  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
                    getTag = function(value) {
                      var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
                      if (ctorString) {
                        switch (ctorString) {
                          case dataViewCtorString:
                            return dataViewTag;
                          case mapCtorString:
                            return mapTag;
                          case promiseCtorString:
                            return promiseTag;
                          case setCtorString:
                            return setTag;
                          case weakMapCtorString:
                            return weakMapTag;
                        }
                      }
                      return result2;
                    };
                  }
                  function getView(start, end, transforms) {
                    var index = -1, length = transforms.length;
                    while (++index < length) {
                      var data = transforms[index], size2 = data.size;
                      switch (data.type) {
                        case "drop":
                          start += size2;
                          break;
                        case "dropRight":
                          end -= size2;
                          break;
                        case "take":
                          end = nativeMin(end, start + size2);
                          break;
                        case "takeRight":
                          start = nativeMax(start, end - size2);
                          break;
                      }
                    }
                    return { "start": start, "end": end };
                  }
                  function getWrapDetails(source) {
                    var match = source.match(reWrapDetails);
                    return match ? match[1].split(reSplitDetails) : [];
                  }
                  function hasPath(object, path, hasFunc) {
                    path = castPath(path, object);
                    var index = -1, length = path.length, result2 = false;
                    while (++index < length) {
                      var key = toKey(path[index]);
                      if (!(result2 = object != null && hasFunc(object, key))) {
                        break;
                      }
                      object = object[key];
                    }
                    if (result2 || ++index != length) {
                      return result2;
                    }
                    length = object == null ? 0 : object.length;
                    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
                  }
                  function initCloneArray(array) {
                    var length = array.length, result2 = new array.constructor(length);
                    if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
                      result2.index = array.index;
                      result2.input = array.input;
                    }
                    return result2;
                  }
                  function initCloneObject(object) {
                    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
                  }
                  function initCloneByTag(object, tag, isDeep) {
                    var Ctor = object.constructor;
                    switch (tag) {
                      case arrayBufferTag:
                        return cloneArrayBuffer(object);
                      case boolTag:
                      case dateTag:
                        return new Ctor(+object);
                      case dataViewTag:
                        return cloneDataView(object, isDeep);
                      case float32Tag:
                      case float64Tag:
                      case int8Tag:
                      case int16Tag:
                      case int32Tag:
                      case uint8Tag:
                      case uint8ClampedTag:
                      case uint16Tag:
                      case uint32Tag:
                        return cloneTypedArray(object, isDeep);
                      case mapTag:
                        return new Ctor();
                      case numberTag:
                      case stringTag:
                        return new Ctor(object);
                      case regexpTag:
                        return cloneRegExp(object);
                      case setTag:
                        return new Ctor();
                      case symbolTag:
                        return cloneSymbol(object);
                    }
                  }
                  function insertWrapDetails(source, details) {
                    var length = details.length;
                    if (!length) {
                      return source;
                    }
                    var lastIndex = length - 1;
                    details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                    details = details.join(length > 2 ? ", " : " ");
                    return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
                  }
                  function isFlattenable(value) {
                    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
                  }
                  function isIndex(value, length) {
                    var type = typeof value;
                    length = length == null ? MAX_SAFE_INTEGER : length;
                    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
                  }
                  function isIterateeCall(value, index, object) {
                    if (!isObject2(object)) {
                      return false;
                    }
                    var type = typeof index;
                    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
                      return eq(object[index], value);
                    }
                    return false;
                  }
                  function isKey(value, object) {
                    if (isArray(value)) {
                      return false;
                    }
                    var type = typeof value;
                    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
                      return true;
                    }
                    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
                  }
                  function isKeyable(value) {
                    var type = typeof value;
                    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
                  }
                  function isLaziable(func) {
                    var funcName = getFuncName(func), other = lodash[funcName];
                    if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                      return false;
                    }
                    if (func === other) {
                      return true;
                    }
                    var data = getData(other);
                    return !!data && func === data[0];
                  }
                  function isMasked(func) {
                    return !!maskSrcKey && maskSrcKey in func;
                  }
                  var isMaskable = coreJsData ? isFunction : stubFalse;
                  function isPrototype(value) {
                    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
                    return value === proto;
                  }
                  function isStrictComparable(value) {
                    return value === value && !isObject2(value);
                  }
                  function matchesStrictComparable(key, srcValue) {
                    return function(object) {
                      if (object == null) {
                        return false;
                      }
                      return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
                    };
                  }
                  function memoizeCapped(func) {
                    var result2 = memoize(func, function(key) {
                      if (cache.size === MAX_MEMOIZE_SIZE) {
                        cache.clear();
                      }
                      return key;
                    });
                    var cache = result2.cache;
                    return result2;
                  }
                  function mergeData(data, source) {
                    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                    var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                    if (!(isCommon || isCombo)) {
                      return data;
                    }
                    if (srcBitmask & WRAP_BIND_FLAG) {
                      data[2] = source[2];
                      newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                    }
                    var value = source[3];
                    if (value) {
                      var partials = data[3];
                      data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                      data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                    }
                    value = source[5];
                    if (value) {
                      partials = data[5];
                      data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                      data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                    }
                    value = source[7];
                    if (value) {
                      data[7] = value;
                    }
                    if (srcBitmask & WRAP_ARY_FLAG) {
                      data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
                    }
                    if (data[9] == null) {
                      data[9] = source[9];
                    }
                    data[0] = source[0];
                    data[1] = newBitmask;
                    return data;
                  }
                  function nativeKeysIn(object) {
                    var result2 = [];
                    if (object != null) {
                      for (var key in Object2(object)) {
                        result2.push(key);
                      }
                    }
                    return result2;
                  }
                  function objectToString(value) {
                    return nativeObjectToString.call(value);
                  }
                  function overRest(func, start, transform2) {
                    start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
                    return function() {
                      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
                      while (++index < length) {
                        array[index] = args[start + index];
                      }
                      index = -1;
                      var otherArgs = Array2(start + 1);
                      while (++index < start) {
                        otherArgs[index] = args[index];
                      }
                      otherArgs[start] = transform2(array);
                      return apply(func, this, otherArgs);
                    };
                  }
                  function parent(object, path) {
                    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
                  }
                  function reorder(array, indexes) {
                    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
                    while (length--) {
                      var index = indexes[length];
                      array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
                    }
                    return array;
                  }
                  function safeGet(object, key) {
                    if (key === "constructor" && typeof object[key] === "function") {
                      return;
                    }
                    if (key == "__proto__") {
                      return;
                    }
                    return object[key];
                  }
                  var setData = shortOut(baseSetData);
                  var setTimeout2 = ctxSetTimeout || function(func, wait) {
                    return root.setTimeout(func, wait);
                  };
                  var setToString = shortOut(baseSetToString);
                  function setWrapToString(wrapper, reference, bitmask) {
                    var source = reference + "";
                    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
                  }
                  function shortOut(func) {
                    var count = 0, lastCalled = 0;
                    return function() {
                      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
                      lastCalled = stamp;
                      if (remaining > 0) {
                        if (++count >= HOT_COUNT) {
                          return arguments[0];
                        }
                      } else {
                        count = 0;
                      }
                      return func.apply(undefined2, arguments);
                    };
                  }
                  function shuffleSelf(array, size2) {
                    var index = -1, length = array.length, lastIndex = length - 1;
                    size2 = size2 === undefined2 ? length : size2;
                    while (++index < size2) {
                      var rand = baseRandom(index, lastIndex), value = array[rand];
                      array[rand] = array[index];
                      array[index] = value;
                    }
                    array.length = size2;
                    return array;
                  }
                  var stringToPath = memoizeCapped(function(string) {
                    var result2 = [];
                    if (string.charCodeAt(0) === 46) {
                      result2.push("");
                    }
                    string.replace(rePropName, function(match, number, quote, subString) {
                      result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
                    });
                    return result2;
                  });
                  function toKey(value) {
                    if (typeof value == "string" || isSymbol(value)) {
                      return value;
                    }
                    var result2 = value + "";
                    return result2 == "0" && 1 / value == -Infinity ? "-0" : result2;
                  }
                  function toSource(func) {
                    if (func != null) {
                      try {
                        return funcToString.call(func);
                      } catch (e2) {
                      }
                      try {
                        return func + "";
                      } catch (e2) {
                      }
                    }
                    return "";
                  }
                  function updateWrapDetails(details, bitmask) {
                    arrayEach(wrapFlags, function(pair) {
                      var value = "_." + pair[0];
                      if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                        details.push(value);
                      }
                    });
                    return details.sort();
                  }
                  function wrapperClone(wrapper) {
                    if (wrapper instanceof LazyWrapper) {
                      return wrapper.clone();
                    }
                    var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                    result2.__actions__ = copyArray(wrapper.__actions__);
                    result2.__index__ = wrapper.__index__;
                    result2.__values__ = wrapper.__values__;
                    return result2;
                  }
                  function chunk(array, size2, guard) {
                    if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
                      size2 = 1;
                    } else {
                      size2 = nativeMax(toInteger(size2), 0);
                    }
                    var length = array == null ? 0 : array.length;
                    if (!length || size2 < 1) {
                      return [];
                    }
                    var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
                    while (index < length) {
                      result2[resIndex++] = baseSlice(array, index, index += size2);
                    }
                    return result2;
                  }
                  function compact(array) {
                    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                    while (++index < length) {
                      var value = array[index];
                      if (value) {
                        result2[resIndex++] = value;
                      }
                    }
                    return result2;
                  }
                  function concat() {
                    var length = arguments.length;
                    if (!length) {
                      return [];
                    }
                    var args = Array2(length - 1), array = arguments[0], index = length;
                    while (index--) {
                      args[index - 1] = arguments[index];
                    }
                    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
                  }
                  var difference = baseRest(function(array, values2) {
                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
                  });
                  var differenceBy = baseRest(function(array, values2) {
                    var iteratee2 = last(values2);
                    if (isArrayLikeObject(iteratee2)) {
                      iteratee2 = undefined2;
                    }
                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
                  });
                  var differenceWith = baseRest(function(array, values2) {
                    var comparator = last(values2);
                    if (isArrayLikeObject(comparator)) {
                      comparator = undefined2;
                    }
                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
                  });
                  function drop(array, n2, guard) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return [];
                    }
                    n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
                    return baseSlice(array, n2 < 0 ? 0 : n2, length);
                  }
                  function dropRight(array, n2, guard) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return [];
                    }
                    n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
                    n2 = length - n2;
                    return baseSlice(array, 0, n2 < 0 ? 0 : n2);
                  }
                  function dropRightWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
                  }
                  function dropWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
                  }
                  function fill(array, value, start, end) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return [];
                    }
                    if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
                      start = 0;
                      end = length;
                    }
                    return baseFill(array, value, start, end);
                  }
                  function findIndex(array, predicate, fromIndex) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return -1;
                    }
                    var index = fromIndex == null ? 0 : toInteger(fromIndex);
                    if (index < 0) {
                      index = nativeMax(length + index, 0);
                    }
                    return baseFindIndex(array, getIteratee(predicate, 3), index);
                  }
                  function findLastIndex(array, predicate, fromIndex) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return -1;
                    }
                    var index = length - 1;
                    if (fromIndex !== undefined2) {
                      index = toInteger(fromIndex);
                      index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                    }
                    return baseFindIndex(array, getIteratee(predicate, 3), index, true);
                  }
                  function flatten(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? baseFlatten(array, 1) : [];
                  }
                  function flattenDeep(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? baseFlatten(array, INFINITY) : [];
                  }
                  function flattenDepth(array, depth) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return [];
                    }
                    depth = depth === undefined2 ? 1 : toInteger(depth);
                    return baseFlatten(array, depth);
                  }
                  function fromPairs(pairs) {
                    var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                    while (++index < length) {
                      var pair = pairs[index];
                      result2[pair[0]] = pair[1];
                    }
                    return result2;
                  }
                  function head(array) {
                    return array && array.length ? array[0] : undefined2;
                  }
                  function indexOf(array, value, fromIndex) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return -1;
                    }
                    var index = fromIndex == null ? 0 : toInteger(fromIndex);
                    if (index < 0) {
                      index = nativeMax(length + index, 0);
                    }
                    return baseIndexOf(array, value, index);
                  }
                  function initial(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? baseSlice(array, 0, -1) : [];
                  }
                  var intersection = baseRest(function(arrays) {
                    var mapped = arrayMap(arrays, castArrayLikeObject);
                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
                  });
                  var intersectionBy = baseRest(function(arrays) {
                    var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                    if (iteratee2 === last(mapped)) {
                      iteratee2 = undefined2;
                    } else {
                      mapped.pop();
                    }
                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
                  });
                  var intersectionWith = baseRest(function(arrays) {
                    var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
                    comparator = typeof comparator == "function" ? comparator : undefined2;
                    if (comparator) {
                      mapped.pop();
                    }
                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
                  });
                  function join(array, separator) {
                    return array == null ? "" : nativeJoin.call(array, separator);
                  }
                  function last(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? array[length - 1] : undefined2;
                  }
                  function lastIndexOf(array, value, fromIndex) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return -1;
                    }
                    var index = length;
                    if (fromIndex !== undefined2) {
                      index = toInteger(fromIndex);
                      index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
                    }
                    return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
                  }
                  function nth(array, n2) {
                    return array && array.length ? baseNth(array, toInteger(n2)) : undefined2;
                  }
                  var pull = baseRest(pullAll);
                  function pullAll(array, values2) {
                    return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
                  }
                  function pullAllBy(array, values2, iteratee2) {
                    return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
                  }
                  function pullAllWith(array, values2, comparator) {
                    return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
                  }
                  var pullAt = flatRest(function(array, indexes) {
                    var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                    basePullAt(array, arrayMap(indexes, function(index) {
                      return isIndex(index, length) ? +index : index;
                    }).sort(compareAscending));
                    return result2;
                  });
                  function remove(array, predicate) {
                    var result2 = [];
                    if (!(array && array.length)) {
                      return result2;
                    }
                    var index = -1, indexes = [], length = array.length;
                    predicate = getIteratee(predicate, 3);
                    while (++index < length) {
                      var value = array[index];
                      if (predicate(value, index, array)) {
                        result2.push(value);
                        indexes.push(index);
                      }
                    }
                    basePullAt(array, indexes);
                    return result2;
                  }
                  function reverse(array) {
                    return array == null ? array : nativeReverse.call(array);
                  }
                  function slice(array, start, end) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return [];
                    }
                    if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
                      start = 0;
                      end = length;
                    } else {
                      start = start == null ? 0 : toInteger(start);
                      end = end === undefined2 ? length : toInteger(end);
                    }
                    return baseSlice(array, start, end);
                  }
                  function sortedIndex(array, value) {
                    return baseSortedIndex(array, value);
                  }
                  function sortedIndexBy(array, value, iteratee2) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
                  }
                  function sortedIndexOf(array, value) {
                    var length = array == null ? 0 : array.length;
                    if (length) {
                      var index = baseSortedIndex(array, value);
                      if (index < length && eq(array[index], value)) {
                        return index;
                      }
                    }
                    return -1;
                  }
                  function sortedLastIndex(array, value) {
                    return baseSortedIndex(array, value, true);
                  }
                  function sortedLastIndexBy(array, value, iteratee2) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
                  }
                  function sortedLastIndexOf(array, value) {
                    var length = array == null ? 0 : array.length;
                    if (length) {
                      var index = baseSortedIndex(array, value, true) - 1;
                      if (eq(array[index], value)) {
                        return index;
                      }
                    }
                    return -1;
                  }
                  function sortedUniq(array) {
                    return array && array.length ? baseSortedUniq(array) : [];
                  }
                  function sortedUniqBy(array, iteratee2) {
                    return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
                  }
                  function tail(array) {
                    var length = array == null ? 0 : array.length;
                    return length ? baseSlice(array, 1, length) : [];
                  }
                  function take(array, n2, guard) {
                    if (!(array && array.length)) {
                      return [];
                    }
                    n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
                    return baseSlice(array, 0, n2 < 0 ? 0 : n2);
                  }
                  function takeRight(array, n2, guard) {
                    var length = array == null ? 0 : array.length;
                    if (!length) {
                      return [];
                    }
                    n2 = guard || n2 === undefined2 ? 1 : toInteger(n2);
                    n2 = length - n2;
                    return baseSlice(array, n2 < 0 ? 0 : n2, length);
                  }
                  function takeRightWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
                  }
                  function takeWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
                  }
                  var union = baseRest(function(arrays) {
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
                  });
                  var unionBy = baseRest(function(arrays) {
                    var iteratee2 = last(arrays);
                    if (isArrayLikeObject(iteratee2)) {
                      iteratee2 = undefined2;
                    }
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
                  });
                  var unionWith = baseRest(function(arrays) {
                    var comparator = last(arrays);
                    comparator = typeof comparator == "function" ? comparator : undefined2;
                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
                  });
                  function uniq(array) {
                    return array && array.length ? baseUniq(array) : [];
                  }
                  function uniqBy(array, iteratee2) {
                    return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
                  }
                  function uniqWith(array, comparator) {
                    comparator = typeof comparator == "function" ? comparator : undefined2;
                    return array && array.length ? baseUniq(array, undefined2, comparator) : [];
                  }
                  function unzip(array) {
                    if (!(array && array.length)) {
                      return [];
                    }
                    var length = 0;
                    array = arrayFilter(array, function(group) {
                      if (isArrayLikeObject(group)) {
                        length = nativeMax(group.length, length);
                        return true;
                      }
                    });
                    return baseTimes(length, function(index) {
                      return arrayMap(array, baseProperty(index));
                    });
                  }
                  function unzipWith(array, iteratee2) {
                    if (!(array && array.length)) {
                      return [];
                    }
                    var result2 = unzip(array);
                    if (iteratee2 == null) {
                      return result2;
                    }
                    return arrayMap(result2, function(group) {
                      return apply(iteratee2, undefined2, group);
                    });
                  }
                  var without = baseRest(function(array, values2) {
                    return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
                  });
                  var xor = baseRest(function(arrays) {
                    return baseXor(arrayFilter(arrays, isArrayLikeObject));
                  });
                  var xorBy = baseRest(function(arrays) {
                    var iteratee2 = last(arrays);
                    if (isArrayLikeObject(iteratee2)) {
                      iteratee2 = undefined2;
                    }
                    return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
                  });
                  var xorWith = baseRest(function(arrays) {
                    var comparator = last(arrays);
                    comparator = typeof comparator == "function" ? comparator : undefined2;
                    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
                  });
                  var zip = baseRest(unzip);
                  function zipObject(props, values2) {
                    return baseZipObject(props || [], values2 || [], assignValue);
                  }
                  function zipObjectDeep(props, values2) {
                    return baseZipObject(props || [], values2 || [], baseSet);
                  }
                  var zipWith = baseRest(function(arrays) {
                    var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
                    iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
                    return unzipWith(arrays, iteratee2);
                  });
                  function chain(value) {
                    var result2 = lodash(value);
                    result2.__chain__ = true;
                    return result2;
                  }
                  function tap(value, interceptor) {
                    interceptor(value);
                    return value;
                  }
                  function thru(value, interceptor) {
                    return interceptor(value);
                  }
                  var wrapperAt = flatRest(function(paths) {
                    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                      return baseAt(object, paths);
                    };
                    if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
                      return this.thru(interceptor);
                    }
                    value = value.slice(start, +start + (length ? 1 : 0));
                    value.__actions__.push({
                      "func": thru,
                      "args": [interceptor],
                      "thisArg": undefined2
                    });
                    return new LodashWrapper(value, this.__chain__).thru(function(array) {
                      if (length && !array.length) {
                        array.push(undefined2);
                      }
                      return array;
                    });
                  });
                  function wrapperChain() {
                    return chain(this);
                  }
                  function wrapperCommit() {
                    return new LodashWrapper(this.value(), this.__chain__);
                  }
                  function wrapperNext() {
                    if (this.__values__ === undefined2) {
                      this.__values__ = toArray(this.value());
                    }
                    var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
                    return { "done": done, "value": value };
                  }
                  function wrapperToIterator() {
                    return this;
                  }
                  function wrapperPlant(value) {
                    var result2, parent2 = this;
                    while (parent2 instanceof baseLodash) {
                      var clone2 = wrapperClone(parent2);
                      clone2.__index__ = 0;
                      clone2.__values__ = undefined2;
                      if (result2) {
                        previous.__wrapped__ = clone2;
                      } else {
                        result2 = clone2;
                      }
                      var previous = clone2;
                      parent2 = parent2.__wrapped__;
                    }
                    previous.__wrapped__ = value;
                    return result2;
                  }
                  function wrapperReverse() {
                    var value = this.__wrapped__;
                    if (value instanceof LazyWrapper) {
                      var wrapped = value;
                      if (this.__actions__.length) {
                        wrapped = new LazyWrapper(this);
                      }
                      wrapped = wrapped.reverse();
                      wrapped.__actions__.push({
                        "func": thru,
                        "args": [reverse],
                        "thisArg": undefined2
                      });
                      return new LodashWrapper(wrapped, this.__chain__);
                    }
                    return this.thru(reverse);
                  }
                  function wrapperValue() {
                    return baseWrapperValue(this.__wrapped__, this.__actions__);
                  }
                  var countBy = createAggregator(function(result2, value, key) {
                    if (hasOwnProperty2.call(result2, key)) {
                      ++result2[key];
                    } else {
                      baseAssignValue(result2, key, 1);
                    }
                  });
                  function every(collection, predicate, guard) {
                    var func = isArray(collection) ? arrayEvery : baseEvery;
                    if (guard && isIterateeCall(collection, predicate, guard)) {
                      predicate = undefined2;
                    }
                    return func(collection, getIteratee(predicate, 3));
                  }
                  function filter(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    return func(collection, getIteratee(predicate, 3));
                  }
                  var find = createFind(findIndex);
                  var findLast = createFind(findLastIndex);
                  function flatMap(collection, iteratee2) {
                    return baseFlatten(map(collection, iteratee2), 1);
                  }
                  function flatMapDeep(collection, iteratee2) {
                    return baseFlatten(map(collection, iteratee2), INFINITY);
                  }
                  function flatMapDepth(collection, iteratee2, depth) {
                    depth = depth === undefined2 ? 1 : toInteger(depth);
                    return baseFlatten(map(collection, iteratee2), depth);
                  }
                  function forEach(collection, iteratee2) {
                    var func = isArray(collection) ? arrayEach : baseEach;
                    return func(collection, getIteratee(iteratee2, 3));
                  }
                  function forEachRight(collection, iteratee2) {
                    var func = isArray(collection) ? arrayEachRight : baseEachRight;
                    return func(collection, getIteratee(iteratee2, 3));
                  }
                  var groupBy = createAggregator(function(result2, value, key) {
                    if (hasOwnProperty2.call(result2, key)) {
                      result2[key].push(value);
                    } else {
                      baseAssignValue(result2, key, [value]);
                    }
                  });
                  function includes(collection, value, fromIndex, guard) {
                    collection = isArrayLike(collection) ? collection : values(collection);
                    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                    var length = collection.length;
                    if (fromIndex < 0) {
                      fromIndex = nativeMax(length + fromIndex, 0);
                    }
                    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
                  }
                  var invokeMap = baseRest(function(collection, path, args) {
                    var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
                    baseEach(collection, function(value) {
                      result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
                    });
                    return result2;
                  });
                  var keyBy = createAggregator(function(result2, value, key) {
                    baseAssignValue(result2, key, value);
                  });
                  function map(collection, iteratee2) {
                    var func = isArray(collection) ? arrayMap : baseMap;
                    return func(collection, getIteratee(iteratee2, 3));
                  }
                  function orderBy(collection, iteratees, orders, guard) {
                    if (collection == null) {
                      return [];
                    }
                    if (!isArray(iteratees)) {
                      iteratees = iteratees == null ? [] : [iteratees];
                    }
                    orders = guard ? undefined2 : orders;
                    if (!isArray(orders)) {
                      orders = orders == null ? [] : [orders];
                    }
                    return baseOrderBy(collection, iteratees, orders);
                  }
                  var partition = createAggregator(function(result2, value, key) {
                    result2[key ? 0 : 1].push(value);
                  }, function() {
                    return [[], []];
                  });
                  function reduce(collection, iteratee2, accumulator) {
                    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                    return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
                  }
                  function reduceRight(collection, iteratee2, accumulator) {
                    var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                    return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
                  }
                  function reject(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    return func(collection, negate(getIteratee(predicate, 3)));
                  }
                  function sample(collection) {
                    var func = isArray(collection) ? arraySample : baseSample;
                    return func(collection);
                  }
                  function sampleSize(collection, n2, guard) {
                    if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined2) {
                      n2 = 1;
                    } else {
                      n2 = toInteger(n2);
                    }
                    var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                    return func(collection, n2);
                  }
                  function shuffle(collection) {
                    var func = isArray(collection) ? arrayShuffle : baseShuffle;
                    return func(collection);
                  }
                  function size(collection) {
                    if (collection == null) {
                      return 0;
                    }
                    if (isArrayLike(collection)) {
                      return isString(collection) ? stringSize(collection) : collection.length;
                    }
                    var tag = getTag(collection);
                    if (tag == mapTag || tag == setTag) {
                      return collection.size;
                    }
                    return baseKeys(collection).length;
                  }
                  function some(collection, predicate, guard) {
                    var func = isArray(collection) ? arraySome : baseSome;
                    if (guard && isIterateeCall(collection, predicate, guard)) {
                      predicate = undefined2;
                    }
                    return func(collection, getIteratee(predicate, 3));
                  }
                  var sortBy = baseRest(function(collection, iteratees) {
                    if (collection == null) {
                      return [];
                    }
                    var length = iteratees.length;
                    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
                      iteratees = [];
                    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
                      iteratees = [iteratees[0]];
                    }
                    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
                  });
                  var now = ctxNow || function() {
                    return root.Date.now();
                  };
                  function after(n2, func) {
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    n2 = toInteger(n2);
                    return function() {
                      if (--n2 < 1) {
                        return func.apply(this, arguments);
                      }
                    };
                  }
                  function ary(func, n2, guard) {
                    n2 = guard ? undefined2 : n2;
                    n2 = func && n2 == null ? func.length : n2;
                    return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n2);
                  }
                  function before(n2, func) {
                    var result2;
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    n2 = toInteger(n2);
                    return function() {
                      if (--n2 > 0) {
                        result2 = func.apply(this, arguments);
                      }
                      if (n2 <= 1) {
                        func = undefined2;
                      }
                      return result2;
                    };
                  }
                  var bind = baseRest(function(func, thisArg, partials) {
                    var bitmask = WRAP_BIND_FLAG;
                    if (partials.length) {
                      var holders = replaceHolders(partials, getHolder(bind));
                      bitmask |= WRAP_PARTIAL_FLAG;
                    }
                    return createWrap(func, bitmask, thisArg, partials, holders);
                  });
                  var bindKey = baseRest(function(object, key, partials) {
                    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                    if (partials.length) {
                      var holders = replaceHolders(partials, getHolder(bindKey));
                      bitmask |= WRAP_PARTIAL_FLAG;
                    }
                    return createWrap(key, bitmask, object, partials, holders);
                  });
                  function curry(func, arity, guard) {
                    arity = guard ? undefined2 : arity;
                    var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                    result2.placeholder = curry.placeholder;
                    return result2;
                  }
                  function curryRight(func, arity, guard) {
                    arity = guard ? undefined2 : arity;
                    var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
                    result2.placeholder = curryRight.placeholder;
                    return result2;
                  }
                  function debounce(func, wait, options) {
                    var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    wait = toNumber(wait) || 0;
                    if (isObject2(options)) {
                      leading = !!options.leading;
                      maxing = "maxWait" in options;
                      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                      trailing = "trailing" in options ? !!options.trailing : trailing;
                    }
                    function invokeFunc(time) {
                      var args = lastArgs, thisArg = lastThis;
                      lastArgs = lastThis = undefined2;
                      lastInvokeTime = time;
                      result2 = func.apply(thisArg, args);
                      return result2;
                    }
                    function leadingEdge(time) {
                      lastInvokeTime = time;
                      timerId = setTimeout2(timerExpired, wait);
                      return leading ? invokeFunc(time) : result2;
                    }
                    function remainingWait(time) {
                      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                      return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                    }
                    function shouldInvoke(time) {
                      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                      return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                    }
                    function timerExpired() {
                      var time = now();
                      if (shouldInvoke(time)) {
                        return trailingEdge(time);
                      }
                      timerId = setTimeout2(timerExpired, remainingWait(time));
                    }
                    function trailingEdge(time) {
                      timerId = undefined2;
                      if (trailing && lastArgs) {
                        return invokeFunc(time);
                      }
                      lastArgs = lastThis = undefined2;
                      return result2;
                    }
                    function cancel() {
                      if (timerId !== undefined2) {
                        clearTimeout2(timerId);
                      }
                      lastInvokeTime = 0;
                      lastArgs = lastCallTime = lastThis = timerId = undefined2;
                    }
                    function flush2() {
                      return timerId === undefined2 ? result2 : trailingEdge(now());
                    }
                    function debounced() {
                      var time = now(), isInvoking = shouldInvoke(time);
                      lastArgs = arguments;
                      lastThis = this;
                      lastCallTime = time;
                      if (isInvoking) {
                        if (timerId === undefined2) {
                          return leadingEdge(lastCallTime);
                        }
                        if (maxing) {
                          clearTimeout2(timerId);
                          timerId = setTimeout2(timerExpired, wait);
                          return invokeFunc(lastCallTime);
                        }
                      }
                      if (timerId === undefined2) {
                        timerId = setTimeout2(timerExpired, wait);
                      }
                      return result2;
                    }
                    debounced.cancel = cancel;
                    debounced.flush = flush2;
                    return debounced;
                  }
                  var defer = baseRest(function(func, args) {
                    return baseDelay(func, 1, args);
                  });
                  var delay = baseRest(function(func, wait, args) {
                    return baseDelay(func, toNumber(wait) || 0, args);
                  });
                  function flip(func) {
                    return createWrap(func, WRAP_FLIP_FLAG);
                  }
                  function memoize(func, resolver) {
                    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    var memoized = function() {
                      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
                      if (cache.has(key)) {
                        return cache.get(key);
                      }
                      var result2 = func.apply(this, args);
                      memoized.cache = cache.set(key, result2) || cache;
                      return result2;
                    };
                    memoized.cache = new (memoize.Cache || MapCache)();
                    return memoized;
                  }
                  memoize.Cache = MapCache;
                  function negate(predicate) {
                    if (typeof predicate != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    return function() {
                      var args = arguments;
                      switch (args.length) {
                        case 0:
                          return !predicate.call(this);
                        case 1:
                          return !predicate.call(this, args[0]);
                        case 2:
                          return !predicate.call(this, args[0], args[1]);
                        case 3:
                          return !predicate.call(this, args[0], args[1], args[2]);
                      }
                      return !predicate.apply(this, args);
                    };
                  }
                  function once(func) {
                    return before(2, func);
                  }
                  var overArgs = castRest(function(func, transforms) {
                    transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                    var funcsLength = transforms.length;
                    return baseRest(function(args) {
                      var index = -1, length = nativeMin(args.length, funcsLength);
                      while (++index < length) {
                        args[index] = transforms[index].call(this, args[index]);
                      }
                      return apply(func, this, args);
                    });
                  });
                  var partial = baseRest(function(func, partials) {
                    var holders = replaceHolders(partials, getHolder(partial));
                    return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
                  });
                  var partialRight = baseRest(function(func, partials) {
                    var holders = replaceHolders(partials, getHolder(partialRight));
                    return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
                  });
                  var rearg = flatRest(function(func, indexes) {
                    return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
                  });
                  function rest(func, start) {
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    start = start === undefined2 ? start : toInteger(start);
                    return baseRest(func, start);
                  }
                  function spread(func, start) {
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    start = start == null ? 0 : nativeMax(toInteger(start), 0);
                    return baseRest(function(args) {
                      var array = args[start], otherArgs = castSlice(args, 0, start);
                      if (array) {
                        arrayPush(otherArgs, array);
                      }
                      return apply(func, this, otherArgs);
                    });
                  }
                  function throttle(func, wait, options) {
                    var leading = true, trailing = true;
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT);
                    }
                    if (isObject2(options)) {
                      leading = "leading" in options ? !!options.leading : leading;
                      trailing = "trailing" in options ? !!options.trailing : trailing;
                    }
                    return debounce(func, wait, {
                      "leading": leading,
                      "maxWait": wait,
                      "trailing": trailing
                    });
                  }
                  function unary(func) {
                    return ary(func, 1);
                  }
                  function wrap(value, wrapper) {
                    return partial(castFunction(wrapper), value);
                  }
                  function castArray() {
                    if (!arguments.length) {
                      return [];
                    }
                    var value = arguments[0];
                    return isArray(value) ? value : [value];
                  }
                  function clone(value) {
                    return baseClone(value, CLONE_SYMBOLS_FLAG);
                  }
                  function cloneWith(value, customizer) {
                    customizer = typeof customizer == "function" ? customizer : undefined2;
                    return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
                  }
                  function cloneDeep(value) {
                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
                  }
                  function cloneDeepWith(value, customizer) {
                    customizer = typeof customizer == "function" ? customizer : undefined2;
                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
                  }
                  function conformsTo(object, source) {
                    return source == null || baseConformsTo(object, source, keys(source));
                  }
                  function eq(value, other) {
                    return value === other || value !== value && other !== other;
                  }
                  var gt = createRelationalOperation(baseGt);
                  var gte = createRelationalOperation(function(value, other) {
                    return value >= other;
                  });
                  var isArguments = baseIsArguments(/* @__PURE__ */ function() {
                    return arguments;
                  }()) ? baseIsArguments : function(value) {
                    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
                  };
                  var isArray = Array2.isArray;
                  var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
                  function isArrayLike(value) {
                    return value != null && isLength(value.length) && !isFunction(value);
                  }
                  function isArrayLikeObject(value) {
                    return isObjectLike(value) && isArrayLike(value);
                  }
                  function isBoolean(value) {
                    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
                  }
                  var isBuffer = nativeIsBuffer || stubFalse;
                  var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
                  function isElement(value) {
                    return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
                  }
                  function isEmpty(value) {
                    if (value == null) {
                      return true;
                    }
                    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
                      return !value.length;
                    }
                    var tag = getTag(value);
                    if (tag == mapTag || tag == setTag) {
                      return !value.size;
                    }
                    if (isPrototype(value)) {
                      return !baseKeys(value).length;
                    }
                    for (var key in value) {
                      if (hasOwnProperty2.call(value, key)) {
                        return false;
                      }
                    }
                    return true;
                  }
                  function isEqual(value, other) {
                    return baseIsEqual(value, other);
                  }
                  function isEqualWith(value, other, customizer) {
                    customizer = typeof customizer == "function" ? customizer : undefined2;
                    var result2 = customizer ? customizer(value, other) : undefined2;
                    return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
                  }
                  function isError(value) {
                    if (!isObjectLike(value)) {
                      return false;
                    }
                    var tag = baseGetTag(value);
                    return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
                  }
                  function isFinite2(value) {
                    return typeof value == "number" && nativeIsFinite(value);
                  }
                  function isFunction(value) {
                    if (!isObject2(value)) {
                      return false;
                    }
                    var tag = baseGetTag(value);
                    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
                  }
                  function isInteger(value) {
                    return typeof value == "number" && value == toInteger(value);
                  }
                  function isLength(value) {
                    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
                  }
                  function isObject2(value) {
                    var type = typeof value;
                    return value != null && (type == "object" || type == "function");
                  }
                  function isObjectLike(value) {
                    return value != null && typeof value == "object";
                  }
                  var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                  function isMatch(object, source) {
                    return object === source || baseIsMatch(object, source, getMatchData(source));
                  }
                  function isMatchWith(object, source, customizer) {
                    customizer = typeof customizer == "function" ? customizer : undefined2;
                    return baseIsMatch(object, source, getMatchData(source), customizer);
                  }
                  function isNaN2(value) {
                    return isNumber(value) && value != +value;
                  }
                  function isNative(value) {
                    if (isMaskable(value)) {
                      throw new Error2(CORE_ERROR_TEXT);
                    }
                    return baseIsNative(value);
                  }
                  function isNull(value) {
                    return value === null;
                  }
                  function isNil(value) {
                    return value == null;
                  }
                  function isNumber(value) {
                    return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
                  }
                  function isPlainObject(value) {
                    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
                      return false;
                    }
                    var proto = getPrototype(value);
                    if (proto === null) {
                      return true;
                    }
                    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
                    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
                  }
                  var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
                  function isSafeInteger(value) {
                    return isInteger(value) && value >= -9007199254740991 && value <= MAX_SAFE_INTEGER;
                  }
                  var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                  function isString(value) {
                    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
                  }
                  function isSymbol(value) {
                    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
                  }
                  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                  function isUndefined(value) {
                    return value === undefined2;
                  }
                  function isWeakMap(value) {
                    return isObjectLike(value) && getTag(value) == weakMapTag;
                  }
                  function isWeakSet(value) {
                    return isObjectLike(value) && baseGetTag(value) == weakSetTag;
                  }
                  var lt = createRelationalOperation(baseLt);
                  var lte = createRelationalOperation(function(value, other) {
                    return value <= other;
                  });
                  function toArray(value) {
                    if (!value) {
                      return [];
                    }
                    if (isArrayLike(value)) {
                      return isString(value) ? stringToArray(value) : copyArray(value);
                    }
                    if (symIterator && value[symIterator]) {
                      return iteratorToArray(value[symIterator]());
                    }
                    var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                    return func(value);
                  }
                  function toFinite(value) {
                    if (!value) {
                      return value === 0 ? value : 0;
                    }
                    value = toNumber(value);
                    if (value === INFINITY || value === -Infinity) {
                      var sign = value < 0 ? -1 : 1;
                      return sign * MAX_INTEGER;
                    }
                    return value === value ? value : 0;
                  }
                  function toInteger(value) {
                    var result2 = toFinite(value), remainder = result2 % 1;
                    return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
                  }
                  function toLength(value) {
                    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
                  }
                  function toNumber(value) {
                    if (typeof value == "number") {
                      return value;
                    }
                    if (isSymbol(value)) {
                      return NAN;
                    }
                    if (isObject2(value)) {
                      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                      value = isObject2(other) ? other + "" : other;
                    }
                    if (typeof value != "string") {
                      return value === 0 ? value : +value;
                    }
                    value = baseTrim(value);
                    var isBinary = reIsBinary.test(value);
                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
                  }
                  function toPlainObject(value) {
                    return copyObject(value, keysIn(value));
                  }
                  function toSafeInteger(value) {
                    return value ? baseClamp(toInteger(value), -9007199254740991, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
                  }
                  function toString2(value) {
                    return value == null ? "" : baseToString(value);
                  }
                  var assign = createAssigner(function(object, source) {
                    if (isPrototype(source) || isArrayLike(source)) {
                      copyObject(source, keys(source), object);
                      return;
                    }
                    for (var key in source) {
                      if (hasOwnProperty2.call(source, key)) {
                        assignValue(object, key, source[key]);
                      }
                    }
                  });
                  var assignIn = createAssigner(function(object, source) {
                    copyObject(source, keysIn(source), object);
                  });
                  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                    copyObject(source, keysIn(source), object, customizer);
                  });
                  var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                    copyObject(source, keys(source), object, customizer);
                  });
                  var at = flatRest(baseAt);
                  function create(prototype, properties) {
                    var result2 = baseCreate(prototype);
                    return properties == null ? result2 : baseAssign(result2, properties);
                  }
                  var defaults2 = baseRest(function(object, sources) {
                    object = Object2(object);
                    var index = -1;
                    var length = sources.length;
                    var guard = length > 2 ? sources[2] : undefined2;
                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                      length = 1;
                    }
                    while (++index < length) {
                      var source = sources[index];
                      var props = keysIn(source);
                      var propsIndex = -1;
                      var propsLength = props.length;
                      while (++propsIndex < propsLength) {
                        var key = props[propsIndex];
                        var value = object[key];
                        if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                          object[key] = source[key];
                        }
                      }
                    }
                    return object;
                  });
                  var defaultsDeep = baseRest(function(args) {
                    args.push(undefined2, customDefaultsMerge);
                    return apply(mergeWith, undefined2, args);
                  });
                  function findKey(object, predicate) {
                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
                  }
                  function findLastKey(object, predicate) {
                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
                  }
                  function forIn(object, iteratee2) {
                    return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
                  }
                  function forInRight(object, iteratee2) {
                    return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
                  }
                  function forOwn(object, iteratee2) {
                    return object && baseForOwn(object, getIteratee(iteratee2, 3));
                  }
                  function forOwnRight(object, iteratee2) {
                    return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
                  }
                  function functions(object) {
                    return object == null ? [] : baseFunctions(object, keys(object));
                  }
                  function functionsIn(object) {
                    return object == null ? [] : baseFunctions(object, keysIn(object));
                  }
                  function get2(object, path, defaultValue) {
                    var result2 = object == null ? undefined2 : baseGet(object, path);
                    return result2 === undefined2 ? defaultValue : result2;
                  }
                  function has2(object, path) {
                    return object != null && hasPath(object, path, baseHas);
                  }
                  function hasIn(object, path) {
                    return object != null && hasPath(object, path, baseHasIn);
                  }
                  var invert = createInverter(function(result2, value, key) {
                    if (value != null && typeof value.toString != "function") {
                      value = nativeObjectToString.call(value);
                    }
                    result2[value] = key;
                  }, constant(identity));
                  var invertBy = createInverter(function(result2, value, key) {
                    if (value != null && typeof value.toString != "function") {
                      value = nativeObjectToString.call(value);
                    }
                    if (hasOwnProperty2.call(result2, value)) {
                      result2[value].push(key);
                    } else {
                      result2[value] = [key];
                    }
                  }, getIteratee);
                  var invoke = baseRest(baseInvoke);
                  function keys(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
                  }
                  function keysIn(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
                  }
                  function mapKeys(object, iteratee2) {
                    var result2 = {};
                    iteratee2 = getIteratee(iteratee2, 3);
                    baseForOwn(object, function(value, key, object2) {
                      baseAssignValue(result2, iteratee2(value, key, object2), value);
                    });
                    return result2;
                  }
                  function mapValues(object, iteratee2) {
                    var result2 = {};
                    iteratee2 = getIteratee(iteratee2, 3);
                    baseForOwn(object, function(value, key, object2) {
                      baseAssignValue(result2, key, iteratee2(value, key, object2));
                    });
                    return result2;
                  }
                  var merge = createAssigner(function(object, source, srcIndex) {
                    baseMerge(object, source, srcIndex);
                  });
                  var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                    baseMerge(object, source, srcIndex, customizer);
                  });
                  var omit = flatRest(function(object, paths) {
                    var result2 = {};
                    if (object == null) {
                      return result2;
                    }
                    var isDeep = false;
                    paths = arrayMap(paths, function(path) {
                      path = castPath(path, object);
                      isDeep || (isDeep = path.length > 1);
                      return path;
                    });
                    copyObject(object, getAllKeysIn(object), result2);
                    if (isDeep) {
                      result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                    }
                    var length = paths.length;
                    while (length--) {
                      baseUnset(result2, paths[length]);
                    }
                    return result2;
                  });
                  function omitBy(object, predicate) {
                    return pickBy(object, negate(getIteratee(predicate)));
                  }
                  var pick = flatRest(function(object, paths) {
                    return object == null ? {} : basePick(object, paths);
                  });
                  function pickBy(object, predicate) {
                    if (object == null) {
                      return {};
                    }
                    var props = arrayMap(getAllKeysIn(object), function(prop) {
                      return [prop];
                    });
                    predicate = getIteratee(predicate);
                    return basePickBy(object, props, function(value, path) {
                      return predicate(value, path[0]);
                    });
                  }
                  function result(object, path, defaultValue) {
                    path = castPath(path, object);
                    var index = -1, length = path.length;
                    if (!length) {
                      length = 1;
                      object = undefined2;
                    }
                    while (++index < length) {
                      var value = object == null ? undefined2 : object[toKey(path[index])];
                      if (value === undefined2) {
                        index = length;
                        value = defaultValue;
                      }
                      object = isFunction(value) ? value.call(object) : value;
                    }
                    return object;
                  }
                  function set(object, path, value) {
                    return object == null ? object : baseSet(object, path, value);
                  }
                  function setWith(object, path, value, customizer) {
                    customizer = typeof customizer == "function" ? customizer : undefined2;
                    return object == null ? object : baseSet(object, path, value, customizer);
                  }
                  var toPairs = createToPairs(keys);
                  var toPairsIn = createToPairs(keysIn);
                  function transform(object, iteratee2, accumulator) {
                    var isArr = isArray(object), isArrLike2 = isArr || isBuffer(object) || isTypedArray(object);
                    iteratee2 = getIteratee(iteratee2, 4);
                    if (accumulator == null) {
                      var Ctor = object && object.constructor;
                      if (isArrLike2) {
                        accumulator = isArr ? new Ctor() : [];
                      } else if (isObject2(object)) {
                        accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
                      } else {
                        accumulator = {};
                      }
                    }
                    (isArrLike2 ? arrayEach : baseForOwn)(object, function(value, index, object2) {
                      return iteratee2(accumulator, value, index, object2);
                    });
                    return accumulator;
                  }
                  function unset(object, path) {
                    return object == null ? true : baseUnset(object, path);
                  }
                  function update(object, path, updater) {
                    return object == null ? object : baseUpdate(object, path, castFunction(updater));
                  }
                  function updateWith(object, path, updater, customizer) {
                    customizer = typeof customizer == "function" ? customizer : undefined2;
                    return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
                  }
                  function values(object) {
                    return object == null ? [] : baseValues(object, keys(object));
                  }
                  function valuesIn(object) {
                    return object == null ? [] : baseValues(object, keysIn(object));
                  }
                  function clamp(number, lower, upper) {
                    if (upper === undefined2) {
                      upper = lower;
                      lower = undefined2;
                    }
                    if (upper !== undefined2) {
                      upper = toNumber(upper);
                      upper = upper === upper ? upper : 0;
                    }
                    if (lower !== undefined2) {
                      lower = toNumber(lower);
                      lower = lower === lower ? lower : 0;
                    }
                    return baseClamp(toNumber(number), lower, upper);
                  }
                  function inRange(number, start, end) {
                    start = toFinite(start);
                    if (end === undefined2) {
                      end = start;
                      start = 0;
                    } else {
                      end = toFinite(end);
                    }
                    number = toNumber(number);
                    return baseInRange(number, start, end);
                  }
                  function random(lower, upper, floating) {
                    if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
                      upper = floating = undefined2;
                    }
                    if (floating === undefined2) {
                      if (typeof upper == "boolean") {
                        floating = upper;
                        upper = undefined2;
                      } else if (typeof lower == "boolean") {
                        floating = lower;
                        lower = undefined2;
                      }
                    }
                    if (lower === undefined2 && upper === undefined2) {
                      lower = 0;
                      upper = 1;
                    } else {
                      lower = toFinite(lower);
                      if (upper === undefined2) {
                        upper = lower;
                        lower = 0;
                      } else {
                        upper = toFinite(upper);
                      }
                    }
                    if (lower > upper) {
                      var temp = lower;
                      lower = upper;
                      upper = temp;
                    }
                    if (floating || lower % 1 || upper % 1) {
                      var rand = nativeRandom();
                      return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                    }
                    return baseRandom(lower, upper);
                  }
                  var camelCase = createCompounder(function(result2, word, index) {
                    word = word.toLowerCase();
                    return result2 + (index ? capitalize(word) : word);
                  });
                  function capitalize(string) {
                    return upperFirst(toString2(string).toLowerCase());
                  }
                  function deburr(string) {
                    string = toString2(string);
                    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
                  }
                  function endsWith(string, target, position) {
                    string = toString2(string);
                    target = baseToString(target);
                    var length = string.length;
                    position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
                    var end = position;
                    position -= target.length;
                    return position >= 0 && string.slice(position, end) == target;
                  }
                  function escape2(string) {
                    string = toString2(string);
                    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
                  }
                  function escapeRegExp(string) {
                    string = toString2(string);
                    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
                  }
                  var kebabCase = createCompounder(function(result2, word, index) {
                    return result2 + (index ? "-" : "") + word.toLowerCase();
                  });
                  var lowerCase = createCompounder(function(result2, word, index) {
                    return result2 + (index ? " " : "") + word.toLowerCase();
                  });
                  var lowerFirst = createCaseFirst("toLowerCase");
                  function pad(string, length, chars) {
                    string = toString2(string);
                    length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    if (!length || strLength >= length) {
                      return string;
                    }
                    var mid = (length - strLength) / 2;
                    return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
                  }
                  function padEnd(string, length, chars) {
                    string = toString2(string);
                    length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
                  }
                  function padStart(string, length, chars) {
                    string = toString2(string);
                    length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
                  }
                  function parseInt2(string, radix, guard) {
                    if (guard || radix == null) {
                      radix = 0;
                    } else if (radix) {
                      radix = +radix;
                    }
                    return nativeParseInt(toString2(string).replace(reTrimStart, ""), radix || 0);
                  }
                  function repeat(string, n2, guard) {
                    if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined2) {
                      n2 = 1;
                    } else {
                      n2 = toInteger(n2);
                    }
                    return baseRepeat(toString2(string), n2);
                  }
                  function replace() {
                    var args = arguments, string = toString2(args[0]);
                    return args.length < 3 ? string : string.replace(args[1], args[2]);
                  }
                  var snakeCase = createCompounder(function(result2, word, index) {
                    return result2 + (index ? "_" : "") + word.toLowerCase();
                  });
                  function split(string, separator, limit) {
                    if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
                      separator = limit = undefined2;
                    }
                    limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
                    if (!limit) {
                      return [];
                    }
                    string = toString2(string);
                    if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                      separator = baseToString(separator);
                      if (!separator && hasUnicode(string)) {
                        return castSlice(stringToArray(string), 0, limit);
                      }
                    }
                    return string.split(separator, limit);
                  }
                  var startCase = createCompounder(function(result2, word, index) {
                    return result2 + (index ? " " : "") + upperFirst(word);
                  });
                  function startsWith(string, target, position) {
                    string = toString2(string);
                    position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
                    target = baseToString(target);
                    return string.slice(position, position + target.length) == target;
                  }
                  function template(string, options, guard) {
                    var settings = lodash.templateSettings;
                    if (guard && isIterateeCall(string, options, guard)) {
                      options = undefined2;
                    }
                    string = toString2(string);
                    options = assignInWith({}, options, settings, customDefaultsAssignIn);
                    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
                    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                    var reDelimiters = RegExp2(
                      (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                      "g"
                    );
                    var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                      interpolateValue || (interpolateValue = esTemplateValue);
                      source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                      if (escapeValue) {
                        isEscaping = true;
                        source += "' +\n__e(" + escapeValue + ") +\n'";
                      }
                      if (evaluateValue) {
                        isEvaluating = true;
                        source += "';\n" + evaluateValue + ";\n__p += '";
                      }
                      if (interpolateValue) {
                        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                      }
                      index = offset + match.length;
                      return match;
                    });
                    source += "';\n";
                    var variable = hasOwnProperty2.call(options, "variable") && options.variable;
                    if (!variable) {
                      source = "with (obj) {\n" + source + "\n}\n";
                    } else if (reForbiddenIdentifierChars.test(variable)) {
                      throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                    }
                    source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                    source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                    var result2 = attempt(function() {
                      return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
                    });
                    result2.source = source;
                    if (isError(result2)) {
                      throw result2;
                    }
                    return result2;
                  }
                  function toLower(value) {
                    return toString2(value).toLowerCase();
                  }
                  function toUpper(value) {
                    return toString2(value).toUpperCase();
                  }
                  function trim(string, chars, guard) {
                    string = toString2(string);
                    if (string && (guard || chars === undefined2)) {
                      return baseTrim(string);
                    }
                    if (!string || !(chars = baseToString(chars))) {
                      return string;
                    }
                    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                    return castSlice(strSymbols, start, end).join("");
                  }
                  function trimEnd(string, chars, guard) {
                    string = toString2(string);
                    if (string && (guard || chars === undefined2)) {
                      return string.slice(0, trimmedEndIndex(string) + 1);
                    }
                    if (!string || !(chars = baseToString(chars))) {
                      return string;
                    }
                    var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                    return castSlice(strSymbols, 0, end).join("");
                  }
                  function trimStart(string, chars, guard) {
                    string = toString2(string);
                    if (string && (guard || chars === undefined2)) {
                      return string.replace(reTrimStart, "");
                    }
                    if (!string || !(chars = baseToString(chars))) {
                      return string;
                    }
                    var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
                    return castSlice(strSymbols, start).join("");
                  }
                  function truncate(string, options) {
                    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                    if (isObject2(options)) {
                      var separator = "separator" in options ? options.separator : separator;
                      length = "length" in options ? toInteger(options.length) : length;
                      omission = "omission" in options ? baseToString(options.omission) : omission;
                    }
                    string = toString2(string);
                    var strLength = string.length;
                    if (hasUnicode(string)) {
                      var strSymbols = stringToArray(string);
                      strLength = strSymbols.length;
                    }
                    if (length >= strLength) {
                      return string;
                    }
                    var end = length - stringSize(omission);
                    if (end < 1) {
                      return omission;
                    }
                    var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                    if (separator === undefined2) {
                      return result2 + omission;
                    }
                    if (strSymbols) {
                      end += result2.length - end;
                    }
                    if (isRegExp(separator)) {
                      if (string.slice(end).search(separator)) {
                        var match, substring = result2;
                        if (!separator.global) {
                          separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                        }
                        separator.lastIndex = 0;
                        while (match = separator.exec(substring)) {
                          var newEnd = match.index;
                        }
                        result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
                      }
                    } else if (string.indexOf(baseToString(separator), end) != end) {
                      var index = result2.lastIndexOf(separator);
                      if (index > -1) {
                        result2 = result2.slice(0, index);
                      }
                    }
                    return result2 + omission;
                  }
                  function unescape(string) {
                    string = toString2(string);
                    return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
                  }
                  var upperCase = createCompounder(function(result2, word, index) {
                    return result2 + (index ? " " : "") + word.toUpperCase();
                  });
                  var upperFirst = createCaseFirst("toUpperCase");
                  function words(string, pattern, guard) {
                    string = toString2(string);
                    pattern = guard ? undefined2 : pattern;
                    if (pattern === undefined2) {
                      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
                    }
                    return string.match(pattern) || [];
                  }
                  var attempt = baseRest(function(func, args) {
                    try {
                      return apply(func, undefined2, args);
                    } catch (e2) {
                      return isError(e2) ? e2 : new Error2(e2);
                    }
                  });
                  var bindAll = flatRest(function(object, methodNames) {
                    arrayEach(methodNames, function(key) {
                      key = toKey(key);
                      baseAssignValue(object, key, bind(object[key], object));
                    });
                    return object;
                  });
                  function cond(pairs) {
                    var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                    pairs = !length ? [] : arrayMap(pairs, function(pair) {
                      if (typeof pair[1] != "function") {
                        throw new TypeError2(FUNC_ERROR_TEXT);
                      }
                      return [toIteratee(pair[0]), pair[1]];
                    });
                    return baseRest(function(args) {
                      var index = -1;
                      while (++index < length) {
                        var pair = pairs[index];
                        if (apply(pair[0], this, args)) {
                          return apply(pair[1], this, args);
                        }
                      }
                    });
                  }
                  function conforms(source) {
                    return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
                  }
                  function constant(value) {
                    return function() {
                      return value;
                    };
                  }
                  function defaultTo(value, defaultValue) {
                    return value == null || value !== value ? defaultValue : value;
                  }
                  var flow = createFlow();
                  var flowRight = createFlow(true);
                  function identity(value) {
                    return value;
                  }
                  function iteratee(func) {
                    return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
                  }
                  function matches(source) {
                    return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
                  }
                  function matchesProperty(path, srcValue) {
                    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
                  }
                  var method = baseRest(function(path, args) {
                    return function(object) {
                      return baseInvoke(object, path, args);
                    };
                  });
                  var methodOf = baseRest(function(object, args) {
                    return function(path) {
                      return baseInvoke(object, path, args);
                    };
                  });
                  function mixin(object, source, options) {
                    var props = keys(source), methodNames = baseFunctions(source, props);
                    if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
                      options = source;
                      source = object;
                      object = this;
                      methodNames = baseFunctions(source, keys(source));
                    }
                    var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
                    arrayEach(methodNames, function(methodName) {
                      var func = source[methodName];
                      object[methodName] = func;
                      if (isFunc) {
                        object.prototype[methodName] = function() {
                          var chainAll = this.__chain__;
                          if (chain2 || chainAll) {
                            var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                            actions.push({ "func": func, "args": arguments, "thisArg": object });
                            result2.__chain__ = chainAll;
                            return result2;
                          }
                          return func.apply(object, arrayPush([this.value()], arguments));
                        };
                      }
                    });
                    return object;
                  }
                  function noConflict() {
                    if (root._ === this) {
                      root._ = oldDash;
                    }
                    return this;
                  }
                  function noop2() {
                  }
                  function nthArg(n2) {
                    n2 = toInteger(n2);
                    return baseRest(function(args) {
                      return baseNth(args, n2);
                    });
                  }
                  var over = createOver(arrayMap);
                  var overEvery = createOver(arrayEvery);
                  var overSome = createOver(arraySome);
                  function property(path) {
                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
                  }
                  function propertyOf(object) {
                    return function(path) {
                      return object == null ? undefined2 : baseGet(object, path);
                    };
                  }
                  var range = createRange();
                  var rangeRight = createRange(true);
                  function stubArray() {
                    return [];
                  }
                  function stubFalse() {
                    return false;
                  }
                  function stubObject() {
                    return {};
                  }
                  function stubString() {
                    return "";
                  }
                  function stubTrue() {
                    return true;
                  }
                  function times(n2, iteratee2) {
                    n2 = toInteger(n2);
                    if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
                      return [];
                    }
                    var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
                    iteratee2 = getIteratee(iteratee2);
                    n2 -= MAX_ARRAY_LENGTH;
                    var result2 = baseTimes(length, iteratee2);
                    while (++index < n2) {
                      iteratee2(index);
                    }
                    return result2;
                  }
                  function toPath(value) {
                    if (isArray(value)) {
                      return arrayMap(value, toKey);
                    }
                    return isSymbol(value) ? [value] : copyArray(stringToPath(toString2(value)));
                  }
                  function uniqueId(prefix) {
                    var id = ++idCounter;
                    return toString2(prefix) + id;
                  }
                  var add = createMathOperation(function(augend, addend) {
                    return augend + addend;
                  }, 0);
                  var ceil = createRound("ceil");
                  var divide = createMathOperation(function(dividend, divisor) {
                    return dividend / divisor;
                  }, 1);
                  var floor = createRound("floor");
                  function max(array) {
                    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
                  }
                  function maxBy(array, iteratee2) {
                    return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
                  }
                  function mean(array) {
                    return baseMean(array, identity);
                  }
                  function meanBy(array, iteratee2) {
                    return baseMean(array, getIteratee(iteratee2, 2));
                  }
                  function min(array) {
                    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
                  }
                  function minBy(array, iteratee2) {
                    return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
                  }
                  var multiply = createMathOperation(function(multiplier, multiplicand) {
                    return multiplier * multiplicand;
                  }, 1);
                  var round = createRound("round");
                  var subtract = createMathOperation(function(minuend, subtrahend) {
                    return minuend - subtrahend;
                  }, 0);
                  function sum(array) {
                    return array && array.length ? baseSum(array, identity) : 0;
                  }
                  function sumBy(array, iteratee2) {
                    return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
                  }
                  lodash.after = after;
                  lodash.ary = ary;
                  lodash.assign = assign;
                  lodash.assignIn = assignIn;
                  lodash.assignInWith = assignInWith;
                  lodash.assignWith = assignWith;
                  lodash.at = at;
                  lodash.before = before;
                  lodash.bind = bind;
                  lodash.bindAll = bindAll;
                  lodash.bindKey = bindKey;
                  lodash.castArray = castArray;
                  lodash.chain = chain;
                  lodash.chunk = chunk;
                  lodash.compact = compact;
                  lodash.concat = concat;
                  lodash.cond = cond;
                  lodash.conforms = conforms;
                  lodash.constant = constant;
                  lodash.countBy = countBy;
                  lodash.create = create;
                  lodash.curry = curry;
                  lodash.curryRight = curryRight;
                  lodash.debounce = debounce;
                  lodash.defaults = defaults2;
                  lodash.defaultsDeep = defaultsDeep;
                  lodash.defer = defer;
                  lodash.delay = delay;
                  lodash.difference = difference;
                  lodash.differenceBy = differenceBy;
                  lodash.differenceWith = differenceWith;
                  lodash.drop = drop;
                  lodash.dropRight = dropRight;
                  lodash.dropRightWhile = dropRightWhile;
                  lodash.dropWhile = dropWhile;
                  lodash.fill = fill;
                  lodash.filter = filter;
                  lodash.flatMap = flatMap;
                  lodash.flatMapDeep = flatMapDeep;
                  lodash.flatMapDepth = flatMapDepth;
                  lodash.flatten = flatten;
                  lodash.flattenDeep = flattenDeep;
                  lodash.flattenDepth = flattenDepth;
                  lodash.flip = flip;
                  lodash.flow = flow;
                  lodash.flowRight = flowRight;
                  lodash.fromPairs = fromPairs;
                  lodash.functions = functions;
                  lodash.functionsIn = functionsIn;
                  lodash.groupBy = groupBy;
                  lodash.initial = initial;
                  lodash.intersection = intersection;
                  lodash.intersectionBy = intersectionBy;
                  lodash.intersectionWith = intersectionWith;
                  lodash.invert = invert;
                  lodash.invertBy = invertBy;
                  lodash.invokeMap = invokeMap;
                  lodash.iteratee = iteratee;
                  lodash.keyBy = keyBy;
                  lodash.keys = keys;
                  lodash.keysIn = keysIn;
                  lodash.map = map;
                  lodash.mapKeys = mapKeys;
                  lodash.mapValues = mapValues;
                  lodash.matches = matches;
                  lodash.matchesProperty = matchesProperty;
                  lodash.memoize = memoize;
                  lodash.merge = merge;
                  lodash.mergeWith = mergeWith;
                  lodash.method = method;
                  lodash.methodOf = methodOf;
                  lodash.mixin = mixin;
                  lodash.negate = negate;
                  lodash.nthArg = nthArg;
                  lodash.omit = omit;
                  lodash.omitBy = omitBy;
                  lodash.once = once;
                  lodash.orderBy = orderBy;
                  lodash.over = over;
                  lodash.overArgs = overArgs;
                  lodash.overEvery = overEvery;
                  lodash.overSome = overSome;
                  lodash.partial = partial;
                  lodash.partialRight = partialRight;
                  lodash.partition = partition;
                  lodash.pick = pick;
                  lodash.pickBy = pickBy;
                  lodash.property = property;
                  lodash.propertyOf = propertyOf;
                  lodash.pull = pull;
                  lodash.pullAll = pullAll;
                  lodash.pullAllBy = pullAllBy;
                  lodash.pullAllWith = pullAllWith;
                  lodash.pullAt = pullAt;
                  lodash.range = range;
                  lodash.rangeRight = rangeRight;
                  lodash.rearg = rearg;
                  lodash.reject = reject;
                  lodash.remove = remove;
                  lodash.rest = rest;
                  lodash.reverse = reverse;
                  lodash.sampleSize = sampleSize;
                  lodash.set = set;
                  lodash.setWith = setWith;
                  lodash.shuffle = shuffle;
                  lodash.slice = slice;
                  lodash.sortBy = sortBy;
                  lodash.sortedUniq = sortedUniq;
                  lodash.sortedUniqBy = sortedUniqBy;
                  lodash.split = split;
                  lodash.spread = spread;
                  lodash.tail = tail;
                  lodash.take = take;
                  lodash.takeRight = takeRight;
                  lodash.takeRightWhile = takeRightWhile;
                  lodash.takeWhile = takeWhile;
                  lodash.tap = tap;
                  lodash.throttle = throttle;
                  lodash.thru = thru;
                  lodash.toArray = toArray;
                  lodash.toPairs = toPairs;
                  lodash.toPairsIn = toPairsIn;
                  lodash.toPath = toPath;
                  lodash.toPlainObject = toPlainObject;
                  lodash.transform = transform;
                  lodash.unary = unary;
                  lodash.union = union;
                  lodash.unionBy = unionBy;
                  lodash.unionWith = unionWith;
                  lodash.uniq = uniq;
                  lodash.uniqBy = uniqBy;
                  lodash.uniqWith = uniqWith;
                  lodash.unset = unset;
                  lodash.unzip = unzip;
                  lodash.unzipWith = unzipWith;
                  lodash.update = update;
                  lodash.updateWith = updateWith;
                  lodash.values = values;
                  lodash.valuesIn = valuesIn;
                  lodash.without = without;
                  lodash.words = words;
                  lodash.wrap = wrap;
                  lodash.xor = xor;
                  lodash.xorBy = xorBy;
                  lodash.xorWith = xorWith;
                  lodash.zip = zip;
                  lodash.zipObject = zipObject;
                  lodash.zipObjectDeep = zipObjectDeep;
                  lodash.zipWith = zipWith;
                  lodash.entries = toPairs;
                  lodash.entriesIn = toPairsIn;
                  lodash.extend = assignIn;
                  lodash.extendWith = assignInWith;
                  mixin(lodash, lodash);
                  lodash.add = add;
                  lodash.attempt = attempt;
                  lodash.camelCase = camelCase;
                  lodash.capitalize = capitalize;
                  lodash.ceil = ceil;
                  lodash.clamp = clamp;
                  lodash.clone = clone;
                  lodash.cloneDeep = cloneDeep;
                  lodash.cloneDeepWith = cloneDeepWith;
                  lodash.cloneWith = cloneWith;
                  lodash.conformsTo = conformsTo;
                  lodash.deburr = deburr;
                  lodash.defaultTo = defaultTo;
                  lodash.divide = divide;
                  lodash.endsWith = endsWith;
                  lodash.eq = eq;
                  lodash.escape = escape2;
                  lodash.escapeRegExp = escapeRegExp;
                  lodash.every = every;
                  lodash.find = find;
                  lodash.findIndex = findIndex;
                  lodash.findKey = findKey;
                  lodash.findLast = findLast;
                  lodash.findLastIndex = findLastIndex;
                  lodash.findLastKey = findLastKey;
                  lodash.floor = floor;
                  lodash.forEach = forEach;
                  lodash.forEachRight = forEachRight;
                  lodash.forIn = forIn;
                  lodash.forInRight = forInRight;
                  lodash.forOwn = forOwn;
                  lodash.forOwnRight = forOwnRight;
                  lodash.get = get2;
                  lodash.gt = gt;
                  lodash.gte = gte;
                  lodash.has = has2;
                  lodash.hasIn = hasIn;
                  lodash.head = head;
                  lodash.identity = identity;
                  lodash.includes = includes;
                  lodash.indexOf = indexOf;
                  lodash.inRange = inRange;
                  lodash.invoke = invoke;
                  lodash.isArguments = isArguments;
                  lodash.isArray = isArray;
                  lodash.isArrayBuffer = isArrayBuffer;
                  lodash.isArrayLike = isArrayLike;
                  lodash.isArrayLikeObject = isArrayLikeObject;
                  lodash.isBoolean = isBoolean;
                  lodash.isBuffer = isBuffer;
                  lodash.isDate = isDate;
                  lodash.isElement = isElement;
                  lodash.isEmpty = isEmpty;
                  lodash.isEqual = isEqual;
                  lodash.isEqualWith = isEqualWith;
                  lodash.isError = isError;
                  lodash.isFinite = isFinite2;
                  lodash.isFunction = isFunction;
                  lodash.isInteger = isInteger;
                  lodash.isLength = isLength;
                  lodash.isMap = isMap2;
                  lodash.isMatch = isMatch;
                  lodash.isMatchWith = isMatchWith;
                  lodash.isNaN = isNaN2;
                  lodash.isNative = isNative;
                  lodash.isNil = isNil;
                  lodash.isNull = isNull;
                  lodash.isNumber = isNumber;
                  lodash.isObject = isObject2;
                  lodash.isObjectLike = isObjectLike;
                  lodash.isPlainObject = isPlainObject;
                  lodash.isRegExp = isRegExp;
                  lodash.isSafeInteger = isSafeInteger;
                  lodash.isSet = isSet2;
                  lodash.isString = isString;
                  lodash.isSymbol = isSymbol;
                  lodash.isTypedArray = isTypedArray;
                  lodash.isUndefined = isUndefined;
                  lodash.isWeakMap = isWeakMap;
                  lodash.isWeakSet = isWeakSet;
                  lodash.join = join;
                  lodash.kebabCase = kebabCase;
                  lodash.last = last;
                  lodash.lastIndexOf = lastIndexOf;
                  lodash.lowerCase = lowerCase;
                  lodash.lowerFirst = lowerFirst;
                  lodash.lt = lt;
                  lodash.lte = lte;
                  lodash.max = max;
                  lodash.maxBy = maxBy;
                  lodash.mean = mean;
                  lodash.meanBy = meanBy;
                  lodash.min = min;
                  lodash.minBy = minBy;
                  lodash.stubArray = stubArray;
                  lodash.stubFalse = stubFalse;
                  lodash.stubObject = stubObject;
                  lodash.stubString = stubString;
                  lodash.stubTrue = stubTrue;
                  lodash.multiply = multiply;
                  lodash.nth = nth;
                  lodash.noConflict = noConflict;
                  lodash.noop = noop2;
                  lodash.now = now;
                  lodash.pad = pad;
                  lodash.padEnd = padEnd;
                  lodash.padStart = padStart;
                  lodash.parseInt = parseInt2;
                  lodash.random = random;
                  lodash.reduce = reduce;
                  lodash.reduceRight = reduceRight;
                  lodash.repeat = repeat;
                  lodash.replace = replace;
                  lodash.result = result;
                  lodash.round = round;
                  lodash.runInContext = runInContext2;
                  lodash.sample = sample;
                  lodash.size = size;
                  lodash.snakeCase = snakeCase;
                  lodash.some = some;
                  lodash.sortedIndex = sortedIndex;
                  lodash.sortedIndexBy = sortedIndexBy;
                  lodash.sortedIndexOf = sortedIndexOf;
                  lodash.sortedLastIndex = sortedLastIndex;
                  lodash.sortedLastIndexBy = sortedLastIndexBy;
                  lodash.sortedLastIndexOf = sortedLastIndexOf;
                  lodash.startCase = startCase;
                  lodash.startsWith = startsWith;
                  lodash.subtract = subtract;
                  lodash.sum = sum;
                  lodash.sumBy = sumBy;
                  lodash.template = template;
                  lodash.times = times;
                  lodash.toFinite = toFinite;
                  lodash.toInteger = toInteger;
                  lodash.toLength = toLength;
                  lodash.toLower = toLower;
                  lodash.toNumber = toNumber;
                  lodash.toSafeInteger = toSafeInteger;
                  lodash.toString = toString2;
                  lodash.toUpper = toUpper;
                  lodash.trim = trim;
                  lodash.trimEnd = trimEnd;
                  lodash.trimStart = trimStart;
                  lodash.truncate = truncate;
                  lodash.unescape = unescape;
                  lodash.uniqueId = uniqueId;
                  lodash.upperCase = upperCase;
                  lodash.upperFirst = upperFirst;
                  lodash.each = forEach;
                  lodash.eachRight = forEachRight;
                  lodash.first = head;
                  mixin(lodash, function() {
                    var source = {};
                    baseForOwn(lodash, function(func, methodName) {
                      if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
                        source[methodName] = func;
                      }
                    });
                    return source;
                  }(), { "chain": false });
                  lodash.VERSION = VERSION;
                  arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                    lodash[methodName].placeholder = lodash;
                  });
                  arrayEach(["drop", "take"], function(methodName, index) {
                    LazyWrapper.prototype[methodName] = function(n2) {
                      n2 = n2 === undefined2 ? 1 : nativeMax(toInteger(n2), 0);
                      var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                      if (result2.__filtered__) {
                        result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
                      } else {
                        result2.__views__.push({
                          "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                          "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                        });
                      }
                      return result2;
                    };
                    LazyWrapper.prototype[methodName + "Right"] = function(n2) {
                      return this.reverse()[methodName](n2).reverse();
                    };
                  });
                  arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
                    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                    LazyWrapper.prototype[methodName] = function(iteratee2) {
                      var result2 = this.clone();
                      result2.__iteratees__.push({
                        "iteratee": getIteratee(iteratee2, 3),
                        "type": type
                      });
                      result2.__filtered__ = result2.__filtered__ || isFilter;
                      return result2;
                    };
                  });
                  arrayEach(["head", "last"], function(methodName, index) {
                    var takeName = "take" + (index ? "Right" : "");
                    LazyWrapper.prototype[methodName] = function() {
                      return this[takeName](1).value()[0];
                    };
                  });
                  arrayEach(["initial", "tail"], function(methodName, index) {
                    var dropName = "drop" + (index ? "" : "Right");
                    LazyWrapper.prototype[methodName] = function() {
                      return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                    };
                  });
                  LazyWrapper.prototype.compact = function() {
                    return this.filter(identity);
                  };
                  LazyWrapper.prototype.find = function(predicate) {
                    return this.filter(predicate).head();
                  };
                  LazyWrapper.prototype.findLast = function(predicate) {
                    return this.reverse().find(predicate);
                  };
                  LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                    if (typeof path == "function") {
                      return new LazyWrapper(this);
                    }
                    return this.map(function(value) {
                      return baseInvoke(value, path, args);
                    });
                  });
                  LazyWrapper.prototype.reject = function(predicate) {
                    return this.filter(negate(getIteratee(predicate)));
                  };
                  LazyWrapper.prototype.slice = function(start, end) {
                    start = toInteger(start);
                    var result2 = this;
                    if (result2.__filtered__ && (start > 0 || end < 0)) {
                      return new LazyWrapper(result2);
                    }
                    if (start < 0) {
                      result2 = result2.takeRight(-start);
                    } else if (start) {
                      result2 = result2.drop(start);
                    }
                    if (end !== undefined2) {
                      end = toInteger(end);
                      result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                    }
                    return result2;
                  };
                  LazyWrapper.prototype.takeRightWhile = function(predicate) {
                    return this.reverse().takeWhile(predicate).reverse();
                  };
                  LazyWrapper.prototype.toArray = function() {
                    return this.take(MAX_ARRAY_LENGTH);
                  };
                  baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                    if (!lodashFunc) {
                      return;
                    }
                    lodash.prototype[methodName] = function() {
                      var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
                      var interceptor = function(value2) {
                        var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                        return isTaker && chainAll ? result3[0] : result3;
                      };
                      if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                        isLazy = useLazy = false;
                      }
                      var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                      if (!retUnwrapped && useLazy) {
                        value = onlyLazy ? value : new LazyWrapper(this);
                        var result2 = func.apply(value, args);
                        result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                        return new LodashWrapper(result2, chainAll);
                      }
                      if (isUnwrapped && onlyLazy) {
                        return func.apply(this, args);
                      }
                      result2 = this.thru(interceptor);
                      return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                    };
                  });
                  arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                    var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                    lodash.prototype[methodName] = function() {
                      var args = arguments;
                      if (retUnwrapped && !this.__chain__) {
                        var value = this.value();
                        return func.apply(isArray(value) ? value : [], args);
                      }
                      return this[chainName](function(value2) {
                        return func.apply(isArray(value2) ? value2 : [], args);
                      });
                    };
                  });
                  baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var lodashFunc = lodash[methodName];
                    if (lodashFunc) {
                      var key = lodashFunc.name + "";
                      if (!hasOwnProperty2.call(realNames, key)) {
                        realNames[key] = [];
                      }
                      realNames[key].push({ "name": methodName, "func": lodashFunc });
                    }
                  });
                  realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
                    "name": "wrapper",
                    "func": undefined2
                  }];
                  LazyWrapper.prototype.clone = lazyClone;
                  LazyWrapper.prototype.reverse = lazyReverse;
                  LazyWrapper.prototype.value = lazyValue;
                  lodash.prototype.at = wrapperAt;
                  lodash.prototype.chain = wrapperChain;
                  lodash.prototype.commit = wrapperCommit;
                  lodash.prototype.next = wrapperNext;
                  lodash.prototype.plant = wrapperPlant;
                  lodash.prototype.reverse = wrapperReverse;
                  lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
                  lodash.prototype.first = lodash.prototype.head;
                  if (symIterator) {
                    lodash.prototype[symIterator] = wrapperToIterator;
                  }
                  return lodash;
                };
                var _2 = runInContext();
                if (freeModule) {
                  (freeModule.exports = _2)._ = _2;
                  freeExports._ = _2;
                } else {
                  root._ = _2;
                }
              }).call(this);
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 240: [function(require2, module3, exports3) {
          var toPosInt = require2("es5-ext/number/to-pos-integer"), create = Object.create, hasOwnProperty2 = Object.prototype.hasOwnProperty;
          module3.exports = function(limit) {
            var size = 0, base = 1, queue = create(null), map = create(null), index = 0, del;
            limit = toPosInt(limit);
            return {
              hit: function(id) {
                var oldIndex = map[id], nuIndex = ++index;
                queue[nuIndex] = id;
                map[id] = nuIndex;
                if (!oldIndex) {
                  ++size;
                  if (size <= limit) return;
                  id = queue[base];
                  del(id);
                  return id;
                }
                delete queue[oldIndex];
                if (base !== oldIndex) return;
                while (!hasOwnProperty2.call(queue, ++base)) continue;
              },
              delete: del = function(id) {
                var oldIndex = map[id];
                if (!oldIndex) return;
                delete queue[oldIndex];
                delete map[id];
                --size;
                if (base !== oldIndex) return;
                if (!size) {
                  index = 0;
                  base = 1;
                  return;
                }
                while (!hasOwnProperty2.call(queue, ++base)) continue;
              },
              clear: function() {
                size = 0;
                base = 1;
                queue = create(null);
                map = create(null);
                index = 0;
              }
            };
          };
        }, { "es5-ext/number/to-pos-integer": 135 }], 241: [function(require2, module3, exports3) {
          var aFrom = require2("es5-ext/array/from"), objectMap = require2("es5-ext/object/map"), mixin = require2("es5-ext/object/mixin"), defineLength = require2("es5-ext/function/_define-length"), nextTick = require2("next-tick");
          var slice = Array.prototype.slice, apply = Function.prototype.apply, create = Object.create;
          require2("../lib/registered-extensions").async = function(tbi, conf2) {
            var waiting = create(null), cache = create(null), base = conf2.memoized, original = conf2.original, currentCallback, currentContext, currentArgs;
            conf2.memoized = defineLength(function(arg) {
              var args = arguments, last = args[args.length - 1];
              if (typeof last === "function") {
                currentCallback = last;
                args = slice.call(args, 0, -1);
              }
              return base.apply(currentContext = this, currentArgs = args);
            }, base);
            try {
              mixin(conf2.memoized, base);
            } catch (ignore) {
            }
            conf2.on("get", function(id) {
              var cb, context, args;
              if (!currentCallback) return;
              if (waiting[id]) {
                if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback];
                else waiting[id].push(currentCallback);
                currentCallback = null;
                return;
              }
              cb = currentCallback;
              context = currentContext;
              args = currentArgs;
              currentCallback = currentContext = currentArgs = null;
              nextTick(function() {
                var data;
                if (hasOwnProperty.call(cache, id)) {
                  data = cache[id];
                  conf2.emit("getasync", id, args, context);
                  apply.call(cb, data.context, data.args);
                } else {
                  currentCallback = cb;
                  currentContext = context;
                  currentArgs = args;
                  base.apply(context, args);
                }
              });
            });
            conf2.original = function() {
              var args, cb, origCb, result;
              if (!currentCallback) return apply.call(original, this, arguments);
              args = aFrom(arguments);
              cb = function self2(err) {
                var cb2, args2, id = self2.id;
                if (id == null) {
                  nextTick(apply.bind(self2, this, arguments));
                  return void 0;
                }
                delete self2.id;
                cb2 = waiting[id];
                delete waiting[id];
                if (!cb2) {
                  return void 0;
                }
                args2 = aFrom(arguments);
                if (conf2.has(id)) {
                  if (err) {
                    conf2.delete(id);
                  } else {
                    cache[id] = { context: this, args: args2 };
                    conf2.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
                  }
                }
                if (typeof cb2 === "function") {
                  result = apply.call(cb2, this, args2);
                } else {
                  cb2.forEach(function(cb3) {
                    result = apply.call(cb3, this, args2);
                  }, this);
                }
                return result;
              };
              origCb = currentCallback;
              currentCallback = currentContext = currentArgs = null;
              args.push(cb);
              result = apply.call(original, this, args);
              cb.cb = origCb;
              currentCallback = cb;
              return result;
            };
            conf2.on("set", function(id) {
              if (!currentCallback) {
                conf2.delete(id);
                return;
              }
              if (waiting[id]) {
                if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
                else waiting[id].push(currentCallback.cb);
              } else {
                waiting[id] = currentCallback.cb;
              }
              delete currentCallback.cb;
              currentCallback.id = id;
              currentCallback = null;
            });
            conf2.on("delete", function(id) {
              var result;
              if (hasOwnProperty.call(waiting, id)) return;
              if (!cache[id]) return;
              result = cache[id];
              delete cache[id];
              conf2.emit("deleteasync", id, slice.call(result.args, 1));
            });
            conf2.on("clear", function() {
              var oldCache = cache;
              cache = create(null);
              conf2.emit(
                "clearasync",
                objectMap(oldCache, function(data) {
                  return slice.call(data.args, 1);
                })
              );
            });
          };
        }, { "../lib/registered-extensions": 250, "es5-ext/array/from": 119, "es5-ext/function/_define-length": 124, "es5-ext/object/map": 149, "es5-ext/object/mixin": 150, "next-tick": 261 }], 242: [function(require2, module3, exports3) {
          var callable = require2("es5-ext/object/valid-callable"), forEach = require2("es5-ext/object/for-each"), extensions = require2("../lib/registered-extensions"), apply = Function.prototype.apply;
          extensions.dispose = function(dispose, conf2, options) {
            var del;
            callable(dispose);
            if (options.async && extensions.async || options.promise && extensions.promise) {
              conf2.on("deleteasync", del = function(id, resultArray) {
                apply.call(dispose, null, resultArray);
              });
              conf2.on("clearasync", function(cache) {
                forEach(cache, function(result, id) {
                  del(id, result);
                });
              });
              return;
            }
            conf2.on("delete", del = function(id, result) {
              dispose(result);
            });
            conf2.on("clear", function(cache) {
              forEach(cache, function(result, id) {
                del(id, result);
              });
            });
          };
        }, { "../lib/registered-extensions": 250, "es5-ext/object/for-each": 142, "es5-ext/object/valid-callable": 156 }], 243: [function(require2, module3, exports3) {
          var aFrom = require2("es5-ext/array/from"), forEach = require2("es5-ext/object/for-each"), nextTick = require2("next-tick"), isPromise = require2("is-promise"), timeout = require2("timers-ext/valid-timeout"), extensions = require2("../lib/registered-extensions");
          var noop2 = Function.prototype, max = Math.max, min = Math.min, create = Object.create;
          extensions.maxAge = function(maxAge, conf2, options) {
            var timeouts, postfix, preFetchAge, preFetchTimeouts;
            maxAge = timeout(maxAge);
            if (!maxAge) return;
            timeouts = create(null);
            postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
            conf2.on("set" + postfix, function(id) {
              timeouts[id] = setTimeout(function() {
                conf2.delete(id);
              }, maxAge);
              if (typeof timeouts[id].unref === "function") timeouts[id].unref();
              if (!preFetchTimeouts) return;
              if (preFetchTimeouts[id]) {
                if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
              }
              preFetchTimeouts[id] = setTimeout(function() {
                delete preFetchTimeouts[id];
              }, preFetchAge);
              if (typeof preFetchTimeouts[id].unref === "function") preFetchTimeouts[id].unref();
            });
            conf2.on("delete" + postfix, function(id) {
              clearTimeout(timeouts[id]);
              delete timeouts[id];
              if (!preFetchTimeouts) return;
              if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
              delete preFetchTimeouts[id];
            });
            if (options.preFetch) {
              if (options.preFetch === true || isNaN(options.preFetch)) {
                preFetchAge = 0.333;
              } else {
                preFetchAge = max(min(Number(options.preFetch), 1), 0);
              }
              if (preFetchAge) {
                preFetchTimeouts = {};
                preFetchAge = (1 - preFetchAge) * maxAge;
                conf2.on("get" + postfix, function(id, args, context) {
                  if (!preFetchTimeouts[id]) {
                    preFetchTimeouts[id] = "nextTick";
                    nextTick(function() {
                      var result;
                      if (preFetchTimeouts[id] !== "nextTick") return;
                      delete preFetchTimeouts[id];
                      conf2.delete(id);
                      if (options.async) {
                        args = aFrom(args);
                        args.push(noop2);
                      }
                      result = conf2.memoized.apply(context, args);
                      if (options.promise) {
                        if (isPromise(result)) {
                          if (typeof result.done === "function") result.done(noop2, noop2);
                          else result.then(noop2, noop2);
                        }
                      }
                    });
                  }
                });
              }
            }
            conf2.on("clear" + postfix, function() {
              forEach(timeouts, function(id) {
                clearTimeout(id);
              });
              timeouts = {};
              if (preFetchTimeouts) {
                forEach(preFetchTimeouts, function(id) {
                  if (id !== "nextTick") clearTimeout(id);
                });
                preFetchTimeouts = {};
              }
            });
          };
        }, { "../lib/registered-extensions": 250, "es5-ext/array/from": 119, "es5-ext/object/for-each": 142, "is-promise": 199, "next-tick": 261, "timers-ext/valid-timeout": 291 }], 244: [function(require2, module3, exports3) {
          var toPosInteger = require2("es5-ext/number/to-pos-integer"), lruQueue = require2("lru-queue"), extensions = require2("../lib/registered-extensions");
          extensions.max = function(max, conf2, options) {
            var postfix, queue, hit;
            max = toPosInteger(max);
            if (!max) return;
            queue = lruQueue(max);
            postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
            conf2.on("set" + postfix, hit = function(id) {
              id = queue.hit(id);
              if (id === void 0) return;
              conf2.delete(id);
            });
            conf2.on("get" + postfix, hit);
            conf2.on("delete" + postfix, queue.delete);
            conf2.on("clear" + postfix, queue.clear);
          };
        }, { "../lib/registered-extensions": 250, "es5-ext/number/to-pos-integer": 135, "lru-queue": 240 }], 245: [function(require2, module3, exports3) {
          var objectMap = require2("es5-ext/object/map"), primitiveSet = require2("es5-ext/object/primitive-set"), ensureString = require2("es5-ext/object/validate-stringifiable-value"), toShortString = require2("es5-ext/to-short-string-representation"), isPromise = require2("is-promise"), nextTick = require2("next-tick");
          var create = Object.create, supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");
          require2("../lib/registered-extensions").promise = function(mode, conf2) {
            var waiting = create(null), cache = create(null), promises = create(null);
            if (mode === true) {
              mode = null;
            } else {
              mode = ensureString(mode);
              if (!supportedModes[mode]) {
                throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
              }
            }
            conf2.on("set", function(id, ignore, promise) {
              var isFailed = false;
              if (!isPromise(promise)) {
                cache[id] = promise;
                conf2.emit("setasync", id, 1);
                return;
              }
              waiting[id] = 1;
              promises[id] = promise;
              var onSuccess = function(result) {
                var count = waiting[id];
                if (isFailed) {
                  throw new Error(
                    "Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead."
                  );
                }
                if (!count) return;
                delete waiting[id];
                cache[id] = result;
                conf2.emit("setasync", id, count);
              };
              var onFailure = function() {
                isFailed = true;
                if (!waiting[id]) return;
                delete waiting[id];
                delete promises[id];
                conf2.delete(id);
              };
              var resolvedMode = mode;
              if (!resolvedMode) resolvedMode = "then";
              if (resolvedMode === "then") {
                var nextTickFailure = function() {
                  nextTick(onFailure);
                };
                promise = promise.then(function(result) {
                  nextTick(onSuccess.bind(this, result));
                }, nextTickFailure);
                if (typeof promise.finally === "function") {
                  promise.finally(nextTickFailure);
                }
              } else if (resolvedMode === "done") {
                if (typeof promise.done !== "function") {
                  throw new Error(
                    "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode"
                  );
                }
                promise.done(onSuccess, onFailure);
              } else if (resolvedMode === "done:finally") {
                if (typeof promise.done !== "function") {
                  throw new Error(
                    "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode"
                  );
                }
                if (typeof promise.finally !== "function") {
                  throw new Error(
                    "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode"
                  );
                }
                promise.done(onSuccess);
                promise.finally(onFailure);
              }
            });
            conf2.on("get", function(id, args, context) {
              var promise;
              if (waiting[id]) {
                ++waiting[id];
                return;
              }
              promise = promises[id];
              var emit2 = function() {
                conf2.emit("getasync", id, args, context);
              };
              if (isPromise(promise)) {
                if (typeof promise.done === "function") promise.done(emit2);
                else {
                  promise.then(function() {
                    nextTick(emit2);
                  });
                }
              } else {
                emit2();
              }
            });
            conf2.on("delete", function(id) {
              delete promises[id];
              if (waiting[id]) {
                delete waiting[id];
                return;
              }
              if (!hasOwnProperty.call(cache, id)) return;
              var result = cache[id];
              delete cache[id];
              conf2.emit("deleteasync", id, [result]);
            });
            conf2.on("clear", function() {
              var oldCache = cache;
              cache = create(null);
              waiting = create(null);
              promises = create(null);
              conf2.emit("clearasync", objectMap(oldCache, function(data) {
                return [data];
              }));
            });
          };
        }, { "../lib/registered-extensions": 250, "es5-ext/object/map": 149, "es5-ext/object/primitive-set": 152, "es5-ext/object/validate-stringifiable-value": 158, "es5-ext/to-short-string-representation": 165, "is-promise": 199, "next-tick": 261 }], 246: [function(require2, module3, exports3) {
          var d2 = require2("d"), extensions = require2("../lib/registered-extensions"), create = Object.create, defineProperties = Object.defineProperties;
          extensions.refCounter = function(ignore, conf2, options) {
            var cache, postfix;
            cache = create(null);
            postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
            conf2.on("set" + postfix, function(id, length) {
              cache[id] = length || 1;
            });
            conf2.on("get" + postfix, function(id) {
              ++cache[id];
            });
            conf2.on("delete" + postfix, function(id) {
              delete cache[id];
            });
            conf2.on("clear" + postfix, function() {
              cache = {};
            });
            defineProperties(conf2.memoized, {
              deleteRef: d2(function() {
                var id = conf2.get(arguments);
                if (id === null) return null;
                if (!cache[id]) return null;
                if (!--cache[id]) {
                  conf2.delete(id);
                  return true;
                }
                return false;
              }),
              getRefCount: d2(function() {
                var id = conf2.get(arguments);
                if (id === null) return 0;
                if (!cache[id]) return 0;
                return cache[id];
              })
            });
          };
        }, { "../lib/registered-extensions": 250, "d": 113 }], 247: [function(require2, module3, exports3) {
          var normalizeOpts = require2("es5-ext/object/normalize-options"), resolveLength = require2("./lib/resolve-length"), plain = require2("./plain");
          module3.exports = function(fn) {
            var options = normalizeOpts(arguments[1]), length;
            if (!options.normalizer) {
              length = options.length = resolveLength(options.length, fn.length, options.async);
              if (length !== 0) {
                if (options.primitive) {
                  if (length === false) {
                    options.normalizer = require2("./normalizers/primitive");
                  } else if (length > 1) {
                    options.normalizer = require2("./normalizers/get-primitive-fixed")(length);
                  }
                } else if (length === false) options.normalizer = require2("./normalizers/get")();
                else if (length === 1) options.normalizer = require2("./normalizers/get-1")();
                else options.normalizer = require2("./normalizers/get-fixed")(length);
              }
            }
            if (options.async) require2("./ext/async");
            if (options.promise) require2("./ext/promise");
            if (options.dispose) require2("./ext/dispose");
            if (options.maxAge) require2("./ext/max-age");
            if (options.max) require2("./ext/max");
            if (options.refCounter) require2("./ext/ref-counter");
            return plain(fn, options);
          };
        }, { "./ext/async": 241, "./ext/dispose": 242, "./ext/max": 244, "./ext/max-age": 243, "./ext/promise": 245, "./ext/ref-counter": 246, "./lib/resolve-length": 251, "./normalizers/get": 258, "./normalizers/get-1": 255, "./normalizers/get-fixed": 256, "./normalizers/get-primitive-fixed": 257, "./normalizers/primitive": 259, "./plain": 260, "es5-ext/object/normalize-options": 151 }], 248: [function(require2, module3, exports3) {
          var customError = require2("es5-ext/error/custom"), defineLength = require2("es5-ext/function/_define-length"), d2 = require2("d"), ee2 = require2("event-emitter").methods, resolveResolve = require2("./resolve-resolve"), resolveNormalize = require2("./resolve-normalize");
          var apply = Function.prototype.apply, call = Function.prototype.call, create = Object.create, defineProperties = Object.defineProperties, on2 = ee2.on, emit2 = ee2.emit;
          module3.exports = function(original, length, options) {
            var cache = create(null), conf2, memLength, get2, set, del, clear, extDel, extGet, extHas, normalizer, getListeners, setListeners, deleteListeners, memoized, resolve;
            if (length !== false) memLength = length;
            else if (isNaN(original.length)) memLength = 1;
            else memLength = original.length;
            if (options.normalizer) {
              normalizer = resolveNormalize(options.normalizer);
              get2 = normalizer.get;
              set = normalizer.set;
              del = normalizer.delete;
              clear = normalizer.clear;
            }
            if (options.resolvers != null) resolve = resolveResolve(options.resolvers);
            if (get2) {
              memoized = defineLength(function(arg) {
                var id, result, args = arguments;
                if (resolve) args = resolve(args);
                id = get2(args);
                if (id !== null) {
                  if (hasOwnProperty.call(cache, id)) {
                    if (getListeners) conf2.emit("get", id, args, this);
                    return cache[id];
                  }
                }
                if (args.length === 1) result = call.call(original, this, args[0]);
                else result = apply.call(original, this, args);
                if (id === null) {
                  id = get2(args);
                  if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
                  id = set(args);
                } else if (hasOwnProperty.call(cache, id)) {
                  throw customError("Circular invocation", "CIRCULAR_INVOCATION");
                }
                cache[id] = result;
                if (setListeners) conf2.emit("set", id, null, result);
                return result;
              }, memLength);
            } else if (length === 0) {
              memoized = function() {
                var result;
                if (hasOwnProperty.call(cache, "data")) {
                  if (getListeners) conf2.emit("get", "data", arguments, this);
                  return cache.data;
                }
                if (arguments.length) result = apply.call(original, this, arguments);
                else result = call.call(original, this);
                if (hasOwnProperty.call(cache, "data")) {
                  throw customError("Circular invocation", "CIRCULAR_INVOCATION");
                }
                cache.data = result;
                if (setListeners) conf2.emit("set", "data", null, result);
                return result;
              };
            } else {
              memoized = function(arg) {
                var result, args = arguments, id;
                if (resolve) args = resolve(arguments);
                id = String(args[0]);
                if (hasOwnProperty.call(cache, id)) {
                  if (getListeners) conf2.emit("get", id, args, this);
                  return cache[id];
                }
                if (args.length === 1) result = call.call(original, this, args[0]);
                else result = apply.call(original, this, args);
                if (hasOwnProperty.call(cache, id)) {
                  throw customError("Circular invocation", "CIRCULAR_INVOCATION");
                }
                cache[id] = result;
                if (setListeners) conf2.emit("set", id, null, result);
                return result;
              };
            }
            conf2 = {
              original,
              memoized,
              profileName: options.profileName,
              get: function(args) {
                if (resolve) args = resolve(args);
                if (get2) return get2(args);
                return String(args[0]);
              },
              has: function(id) {
                return hasOwnProperty.call(cache, id);
              },
              delete: function(id) {
                var result;
                if (!hasOwnProperty.call(cache, id)) return;
                if (del) del(id);
                result = cache[id];
                delete cache[id];
                if (deleteListeners) conf2.emit("delete", id, result);
              },
              clear: function() {
                var oldCache = cache;
                if (clear) clear();
                cache = create(null);
                conf2.emit("clear", oldCache);
              },
              on: function(type, listener) {
                if (type === "get") getListeners = true;
                else if (type === "set") setListeners = true;
                else if (type === "delete") deleteListeners = true;
                return on2.call(this, type, listener);
              },
              emit: emit2,
              updateEnv: function() {
                original = conf2.original;
              }
            };
            if (get2) {
              extDel = defineLength(function(arg) {
                var id, args = arguments;
                if (resolve) args = resolve(args);
                id = get2(args);
                if (id === null) return;
                conf2.delete(id);
              }, memLength);
            } else if (length === 0) {
              extDel = function() {
                return conf2.delete("data");
              };
            } else {
              extDel = function(arg) {
                if (resolve) arg = resolve(arguments)[0];
                return conf2.delete(arg);
              };
            }
            extGet = defineLength(function() {
              var id, args = arguments;
              if (length === 0) return cache.data;
              if (resolve) args = resolve(args);
              if (get2) id = get2(args);
              else id = String(args[0]);
              return cache[id];
            });
            extHas = defineLength(function() {
              var id, args = arguments;
              if (length === 0) return conf2.has("data");
              if (resolve) args = resolve(args);
              if (get2) id = get2(args);
              else id = String(args[0]);
              if (id === null) return false;
              return conf2.has(id);
            });
            defineProperties(memoized, {
              __memoized__: d2(true),
              delete: d2(extDel),
              clear: d2(conf2.clear),
              _get: d2(extGet),
              _has: d2(extHas)
            });
            return conf2;
          };
        }, { "./resolve-normalize": 252, "./resolve-resolve": 253, "d": 113, "es5-ext/error/custom": 123, "es5-ext/function/_define-length": 124, "event-emitter": 181 }], 249: [function(require2, module3, exports3) {
          var forEach = require2("es5-ext/object/for-each"), normalizeOpts = require2("es5-ext/object/normalize-options"), callable = require2("es5-ext/object/valid-callable"), lazy = require2("d/lazy"), resolveLength = require2("./resolve-length"), extensions = require2("./registered-extensions");
          module3.exports = function(memoize) {
            return function(props) {
              forEach(props, function(desc) {
                var fn = callable(desc.value), length;
                desc.value = function(options) {
                  if (options.getNormalizer) {
                    options = normalizeOpts(options);
                    if (length === void 0) {
                      length = resolveLength(
                        options.length,
                        fn.length,
                        options.async && extensions.async
                      );
                    }
                    options.normalizer = options.getNormalizer(length);
                    delete options.getNormalizer;
                  }
                  return memoize(fn.bind(this), options);
                };
              });
              return lazy(props);
            };
          };
        }, { "./registered-extensions": 250, "./resolve-length": 251, "d/lazy": 114, "es5-ext/object/for-each": 142, "es5-ext/object/normalize-options": 151, "es5-ext/object/valid-callable": 156 }], 250: [function(require2, module3, exports3) {
        }, {}], 251: [function(require2, module3, exports3) {
          var toPosInt = require2("es5-ext/number/to-pos-integer");
          module3.exports = function(optsLength, fnLength, isAsync) {
            var length;
            if (isNaN(optsLength)) {
              length = fnLength;
              if (!(length >= 0)) return 1;
              if (isAsync && length) return length - 1;
              return length;
            }
            if (optsLength === false) return false;
            return toPosInt(optsLength);
          };
        }, { "es5-ext/number/to-pos-integer": 135 }], 252: [function(require2, module3, exports3) {
          var callable = require2("es5-ext/object/valid-callable");
          module3.exports = function(userNormalizer) {
            var normalizer;
            if (typeof userNormalizer === "function") return { set: userNormalizer, get: userNormalizer };
            normalizer = { get: callable(userNormalizer.get) };
            if (userNormalizer.set !== void 0) {
              normalizer.set = callable(userNormalizer.set);
              if (userNormalizer.delete) normalizer.delete = callable(userNormalizer.delete);
              if (userNormalizer.clear) normalizer.clear = callable(userNormalizer.clear);
              return normalizer;
            }
            normalizer.set = normalizer.get;
            return normalizer;
          };
        }, { "es5-ext/object/valid-callable": 156 }], 253: [function(require2, module3, exports3) {
          var toArray = require2("es5-ext/array/to-array"), isValue = require2("es5-ext/object/is-value"), callable = require2("es5-ext/object/valid-callable");
          var slice = Array.prototype.slice, resolveArgs;
          resolveArgs = function(args) {
            return this.map(function(resolve, i2) {
              return resolve ? resolve(args[i2]) : args[i2];
            }).concat(slice.call(args, this.length));
          };
          module3.exports = function(resolvers) {
            resolvers = toArray(resolvers);
            resolvers.forEach(function(resolve) {
              if (isValue(resolve)) callable(resolve);
            });
            return resolveArgs.bind(resolvers);
          };
        }, { "es5-ext/array/to-array": 122, "es5-ext/object/is-value": 145, "es5-ext/object/valid-callable": 156 }], 254: [function(require2, module3, exports3) {
          module3.exports = require2("./lib/methods")(require2("./"));
        }, { "./": 247, "./lib/methods": 249 }], 255: [function(require2, module3, exports3) {
          var indexOf = require2("es5-ext/array/#/e-index-of");
          module3.exports = function() {
            var lastId = 0, argsMap = [], cache = [];
            return {
              get: function(args) {
                var index = indexOf.call(argsMap, args[0]);
                return index === -1 ? null : cache[index];
              },
              set: function(args) {
                argsMap.push(args[0]);
                cache.push(++lastId);
                return lastId;
              },
              delete: function(id) {
                var index = indexOf.call(cache, id);
                if (index !== -1) {
                  argsMap.splice(index, 1);
                  cache.splice(index, 1);
                }
              },
              clear: function() {
                argsMap = [];
                cache = [];
              }
            };
          };
        }, { "es5-ext/array/#/e-index-of": 118 }], 256: [function(require2, module3, exports3) {
          var indexOf = require2("es5-ext/array/#/e-index-of"), create = Object.create;
          module3.exports = function(length) {
            var lastId = 0, map = [[], []], cache = create(null);
            return {
              get: function(args) {
                var index = 0, set = map, i2;
                while (index < length - 1) {
                  i2 = indexOf.call(set[0], args[index]);
                  if (i2 === -1) return null;
                  set = set[1][i2];
                  ++index;
                }
                i2 = indexOf.call(set[0], args[index]);
                if (i2 === -1) return null;
                return set[1][i2] || null;
              },
              set: function(args) {
                var index = 0, set = map, i2;
                while (index < length - 1) {
                  i2 = indexOf.call(set[0], args[index]);
                  if (i2 === -1) {
                    i2 = set[0].push(args[index]) - 1;
                    set[1].push([[], []]);
                  }
                  set = set[1][i2];
                  ++index;
                }
                i2 = indexOf.call(set[0], args[index]);
                if (i2 === -1) {
                  i2 = set[0].push(args[index]) - 1;
                }
                set[1][i2] = ++lastId;
                cache[lastId] = args;
                return lastId;
              },
              delete: function(id) {
                var index = 0, set = map, i2, path = [], args = cache[id];
                while (index < length - 1) {
                  i2 = indexOf.call(set[0], args[index]);
                  if (i2 === -1) {
                    return;
                  }
                  path.push(set, i2);
                  set = set[1][i2];
                  ++index;
                }
                i2 = indexOf.call(set[0], args[index]);
                if (i2 === -1) {
                  return;
                }
                id = set[1][i2];
                set[0].splice(i2, 1);
                set[1].splice(i2, 1);
                while (!set[0].length && path.length) {
                  i2 = path.pop();
                  set = path.pop();
                  set[0].splice(i2, 1);
                  set[1].splice(i2, 1);
                }
                delete cache[id];
              },
              clear: function() {
                map = [[], []];
                cache = create(null);
              }
            };
          };
        }, { "es5-ext/array/#/e-index-of": 118 }], 257: [function(require2, module3, exports3) {
          module3.exports = function(length) {
            if (!length) {
              return function() {
                return "";
              };
            }
            return function(args) {
              var id = String(args[0]), i2 = 0, currentLength = length;
              while (--currentLength) {
                id += "" + args[++i2];
              }
              return id;
            };
          };
        }, {}], 258: [function(require2, module3, exports3) {
          var indexOf = require2("es5-ext/array/#/e-index-of");
          var create = Object.create;
          module3.exports = function() {
            var lastId = 0, map = [], cache = create(null);
            return {
              get: function(args) {
                var index = 0, set = map, i2, length = args.length;
                if (length === 0) return set[length] || null;
                if (set = set[length]) {
                  while (index < length - 1) {
                    i2 = indexOf.call(set[0], args[index]);
                    if (i2 === -1) return null;
                    set = set[1][i2];
                    ++index;
                  }
                  i2 = indexOf.call(set[0], args[index]);
                  if (i2 === -1) return null;
                  return set[1][i2] || null;
                }
                return null;
              },
              set: function(args) {
                var index = 0, set = map, i2, length = args.length;
                if (length === 0) {
                  set[length] = ++lastId;
                } else {
                  if (!set[length]) {
                    set[length] = [[], []];
                  }
                  set = set[length];
                  while (index < length - 1) {
                    i2 = indexOf.call(set[0], args[index]);
                    if (i2 === -1) {
                      i2 = set[0].push(args[index]) - 1;
                      set[1].push([[], []]);
                    }
                    set = set[1][i2];
                    ++index;
                  }
                  i2 = indexOf.call(set[0], args[index]);
                  if (i2 === -1) {
                    i2 = set[0].push(args[index]) - 1;
                  }
                  set[1][i2] = ++lastId;
                }
                cache[lastId] = args;
                return lastId;
              },
              delete: function(id) {
                var index = 0, set = map, i2, args = cache[id], length = args.length, path = [];
                if (length === 0) {
                  delete set[length];
                } else if (set = set[length]) {
                  while (index < length - 1) {
                    i2 = indexOf.call(set[0], args[index]);
                    if (i2 === -1) {
                      return;
                    }
                    path.push(set, i2);
                    set = set[1][i2];
                    ++index;
                  }
                  i2 = indexOf.call(set[0], args[index]);
                  if (i2 === -1) {
                    return;
                  }
                  id = set[1][i2];
                  set[0].splice(i2, 1);
                  set[1].splice(i2, 1);
                  while (!set[0].length && path.length) {
                    i2 = path.pop();
                    set = path.pop();
                    set[0].splice(i2, 1);
                    set[1].splice(i2, 1);
                  }
                }
                delete cache[id];
              },
              clear: function() {
                map = [];
                cache = create(null);
              }
            };
          };
        }, { "es5-ext/array/#/e-index-of": 118 }], 259: [function(require2, module3, exports3) {
          module3.exports = function(args) {
            var id, i2, length = args.length;
            if (!length) return "";
            id = String(args[i2 = 0]);
            while (--length) id += "" + args[++i2];
            return id;
          };
        }, {}], 260: [function(require2, module3, exports3) {
          var callable = require2("es5-ext/object/valid-callable"), forEach = require2("es5-ext/object/for-each"), extensions = require2("./lib/registered-extensions"), configure = require2("./lib/configure-map"), resolveLength = require2("./lib/resolve-length");
          module3.exports = function self2(fn) {
            var options, length, conf2;
            callable(fn);
            options = Object(arguments[1]);
            if (options.async && options.promise) {
              throw new Error("Options 'async' and 'promise' cannot be used together");
            }
            if (hasOwnProperty.call(fn, "__memoized__") && !options.force) return fn;
            length = resolveLength(options.length, fn.length, options.async && extensions.async);
            conf2 = configure(fn, length, options);
            forEach(extensions, function(extFn, name) {
              if (options[name]) extFn(options[name], conf2, options);
            });
            if (self2.__profiler__) self2.__profiler__(conf2);
            conf2.updateEnv();
            return conf2.memoized;
          };
        }, { "./lib/configure-map": 248, "./lib/registered-extensions": 250, "./lib/resolve-length": 251, "es5-ext/object/for-each": 142, "es5-ext/object/valid-callable": 156 }], 261: [function(require2, module3, exports3) {
          (function(process, setImmediate) {
            (function() {
              var ensureCallable = function(fn) {
                if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
                return fn;
              };
              var byObserver = function(Observer) {
                var node = document.createTextNode(""), queue, currentQueue, i2 = 0;
                new Observer(function() {
                  var callback;
                  if (!queue) {
                    if (!currentQueue) return;
                    queue = currentQueue;
                  } else if (currentQueue) {
                    queue = currentQueue.concat(queue);
                  }
                  currentQueue = queue;
                  queue = null;
                  if (typeof currentQueue === "function") {
                    callback = currentQueue;
                    currentQueue = null;
                    callback();
                    return;
                  }
                  node.data = i2 = ++i2 % 2;
                  while (currentQueue) {
                    callback = currentQueue.shift();
                    if (!currentQueue.length) currentQueue = null;
                    callback();
                  }
                }).observe(node, { characterData: true });
                return function(fn) {
                  ensureCallable(fn);
                  if (queue) {
                    if (typeof queue === "function") queue = [queue, fn];
                    else queue.push(fn);
                    return;
                  }
                  queue = fn;
                  node.data = i2 = ++i2 % 2;
                };
              };
              module3.exports = function() {
                if (typeof process === "object" && process && typeof process.nextTick === "function") {
                  return process.nextTick;
                }
                if (typeof queueMicrotask === "function") {
                  return function(cb) {
                    queueMicrotask(ensureCallable(cb));
                  };
                }
                if (typeof document === "object" && document) {
                  if (typeof MutationObserver === "function") return byObserver(MutationObserver);
                  if (typeof WebKitMutationObserver === "function") return byObserver(WebKitMutationObserver);
                }
                if (typeof setImmediate === "function") {
                  return function(cb) {
                    setImmediate(ensureCallable(cb));
                  };
                }
                if (typeof setTimeout === "function" || typeof setTimeout === "object") {
                  return function(cb) {
                    setTimeout(ensureCallable(cb), 0);
                  };
                }
                return null;
              }();
            }).call(this);
          }).call(this, require2("_process"), require2("timers").setImmediate);
        }, { "_process": 263, "timers": 289 }], 262: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              function assertPath(path) {
                if (typeof path !== "string") {
                  throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
                }
              }
              function normalizeStringPosix(path, allowAboveRoot) {
                var res = "";
                var lastSegmentLength = 0;
                var lastSlash = -1;
                var dots = 0;
                var code;
                for (var i2 = 0; i2 <= path.length; ++i2) {
                  if (i2 < path.length)
                    code = path.charCodeAt(i2);
                  else if (code === 47)
                    break;
                  else
                    code = 47;
                  if (code === 47) {
                    if (lastSlash === i2 - 1 || dots === 1) ;
                    else if (lastSlash !== i2 - 1 && dots === 2) {
                      if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                        if (res.length > 2) {
                          var lastSlashIndex = res.lastIndexOf("/");
                          if (lastSlashIndex !== res.length - 1) {
                            if (lastSlashIndex === -1) {
                              res = "";
                              lastSegmentLength = 0;
                            } else {
                              res = res.slice(0, lastSlashIndex);
                              lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                            }
                            lastSlash = i2;
                            dots = 0;
                            continue;
                          }
                        } else if (res.length === 2 || res.length === 1) {
                          res = "";
                          lastSegmentLength = 0;
                          lastSlash = i2;
                          dots = 0;
                          continue;
                        }
                      }
                      if (allowAboveRoot) {
                        if (res.length > 0)
                          res += "/..";
                        else
                          res = "..";
                        lastSegmentLength = 2;
                      }
                    } else {
                      if (res.length > 0)
                        res += "/" + path.slice(lastSlash + 1, i2);
                      else
                        res = path.slice(lastSlash + 1, i2);
                      lastSegmentLength = i2 - lastSlash - 1;
                    }
                    lastSlash = i2;
                    dots = 0;
                  } else if (code === 46 && dots !== -1) {
                    ++dots;
                  } else {
                    dots = -1;
                  }
                }
                return res;
              }
              function _format(sep, pathObject) {
                var dir = pathObject.dir || pathObject.root;
                var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
                if (!dir) {
                  return base;
                }
                if (dir === pathObject.root) {
                  return dir + base;
                }
                return dir + sep + base;
              }
              var posix = {
                // path.resolve([from ...], to)
                resolve: function resolve() {
                  var resolvedPath = "";
                  var resolvedAbsolute = false;
                  var cwd;
                  for (var i2 = arguments.length - 1; i2 >= -1 && !resolvedAbsolute; i2--) {
                    var path;
                    if (i2 >= 0)
                      path = arguments[i2];
                    else {
                      if (cwd === void 0)
                        cwd = process.cwd();
                      path = cwd;
                    }
                    assertPath(path);
                    if (path.length === 0) {
                      continue;
                    }
                    resolvedPath = path + "/" + resolvedPath;
                    resolvedAbsolute = path.charCodeAt(0) === 47;
                  }
                  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
                  if (resolvedAbsolute) {
                    if (resolvedPath.length > 0)
                      return "/" + resolvedPath;
                    else
                      return "/";
                  } else if (resolvedPath.length > 0) {
                    return resolvedPath;
                  } else {
                    return ".";
                  }
                },
                normalize: function normalize(path) {
                  assertPath(path);
                  if (path.length === 0) return ".";
                  var isAbsolute = path.charCodeAt(0) === 47;
                  var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
                  path = normalizeStringPosix(path, !isAbsolute);
                  if (path.length === 0 && !isAbsolute) path = ".";
                  if (path.length > 0 && trailingSeparator) path += "/";
                  if (isAbsolute) return "/" + path;
                  return path;
                },
                isAbsolute: function isAbsolute(path) {
                  assertPath(path);
                  return path.length > 0 && path.charCodeAt(0) === 47;
                },
                join: function join() {
                  if (arguments.length === 0)
                    return ".";
                  var joined;
                  for (var i2 = 0; i2 < arguments.length; ++i2) {
                    var arg = arguments[i2];
                    assertPath(arg);
                    if (arg.length > 0) {
                      if (joined === void 0)
                        joined = arg;
                      else
                        joined += "/" + arg;
                    }
                  }
                  if (joined === void 0)
                    return ".";
                  return posix.normalize(joined);
                },
                relative: function relative(from, to) {
                  assertPath(from);
                  assertPath(to);
                  if (from === to) return "";
                  from = posix.resolve(from);
                  to = posix.resolve(to);
                  if (from === to) return "";
                  var fromStart = 1;
                  for (; fromStart < from.length; ++fromStart) {
                    if (from.charCodeAt(fromStart) !== 47)
                      break;
                  }
                  var fromEnd = from.length;
                  var fromLen = fromEnd - fromStart;
                  var toStart = 1;
                  for (; toStart < to.length; ++toStart) {
                    if (to.charCodeAt(toStart) !== 47)
                      break;
                  }
                  var toEnd = to.length;
                  var toLen = toEnd - toStart;
                  var length = fromLen < toLen ? fromLen : toLen;
                  var lastCommonSep = -1;
                  var i2 = 0;
                  for (; i2 <= length; ++i2) {
                    if (i2 === length) {
                      if (toLen > length) {
                        if (to.charCodeAt(toStart + i2) === 47) {
                          return to.slice(toStart + i2 + 1);
                        } else if (i2 === 0) {
                          return to.slice(toStart + i2);
                        }
                      } else if (fromLen > length) {
                        if (from.charCodeAt(fromStart + i2) === 47) {
                          lastCommonSep = i2;
                        } else if (i2 === 0) {
                          lastCommonSep = 0;
                        }
                      }
                      break;
                    }
                    var fromCode = from.charCodeAt(fromStart + i2);
                    var toCode = to.charCodeAt(toStart + i2);
                    if (fromCode !== toCode)
                      break;
                    else if (fromCode === 47)
                      lastCommonSep = i2;
                  }
                  var out = "";
                  for (i2 = fromStart + lastCommonSep + 1; i2 <= fromEnd; ++i2) {
                    if (i2 === fromEnd || from.charCodeAt(i2) === 47) {
                      if (out.length === 0)
                        out += "..";
                      else
                        out += "/..";
                    }
                  }
                  if (out.length > 0)
                    return out + to.slice(toStart + lastCommonSep);
                  else {
                    toStart += lastCommonSep;
                    if (to.charCodeAt(toStart) === 47)
                      ++toStart;
                    return to.slice(toStart);
                  }
                },
                _makeLong: function _makeLong(path) {
                  return path;
                },
                dirname: function dirname(path) {
                  assertPath(path);
                  if (path.length === 0) return ".";
                  var code = path.charCodeAt(0);
                  var hasRoot = code === 47;
                  var end = -1;
                  var matchedSlash = true;
                  for (var i2 = path.length - 1; i2 >= 1; --i2) {
                    code = path.charCodeAt(i2);
                    if (code === 47) {
                      if (!matchedSlash) {
                        end = i2;
                        break;
                      }
                    } else {
                      matchedSlash = false;
                    }
                  }
                  if (end === -1) return hasRoot ? "/" : ".";
                  if (hasRoot && end === 1) return "//";
                  return path.slice(0, end);
                },
                basename: function basename(path, ext) {
                  if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
                  assertPath(path);
                  var start = 0;
                  var end = -1;
                  var matchedSlash = true;
                  var i2;
                  if (ext !== void 0 && ext.length > 0 && ext.length <= path.length) {
                    if (ext.length === path.length && ext === path) return "";
                    var extIdx = ext.length - 1;
                    var firstNonSlashEnd = -1;
                    for (i2 = path.length - 1; i2 >= 0; --i2) {
                      var code = path.charCodeAt(i2);
                      if (code === 47) {
                        if (!matchedSlash) {
                          start = i2 + 1;
                          break;
                        }
                      } else {
                        if (firstNonSlashEnd === -1) {
                          matchedSlash = false;
                          firstNonSlashEnd = i2 + 1;
                        }
                        if (extIdx >= 0) {
                          if (code === ext.charCodeAt(extIdx)) {
                            if (--extIdx === -1) {
                              end = i2;
                            }
                          } else {
                            extIdx = -1;
                            end = firstNonSlashEnd;
                          }
                        }
                      }
                    }
                    if (start === end) end = firstNonSlashEnd;
                    else if (end === -1) end = path.length;
                    return path.slice(start, end);
                  } else {
                    for (i2 = path.length - 1; i2 >= 0; --i2) {
                      if (path.charCodeAt(i2) === 47) {
                        if (!matchedSlash) {
                          start = i2 + 1;
                          break;
                        }
                      } else if (end === -1) {
                        matchedSlash = false;
                        end = i2 + 1;
                      }
                    }
                    if (end === -1) return "";
                    return path.slice(start, end);
                  }
                },
                extname: function extname(path) {
                  assertPath(path);
                  var startDot = -1;
                  var startPart = 0;
                  var end = -1;
                  var matchedSlash = true;
                  var preDotState = 0;
                  for (var i2 = path.length - 1; i2 >= 0; --i2) {
                    var code = path.charCodeAt(i2);
                    if (code === 47) {
                      if (!matchedSlash) {
                        startPart = i2 + 1;
                        break;
                      }
                      continue;
                    }
                    if (end === -1) {
                      matchedSlash = false;
                      end = i2 + 1;
                    }
                    if (code === 46) {
                      if (startDot === -1)
                        startDot = i2;
                      else if (preDotState !== 1)
                        preDotState = 1;
                    } else if (startDot !== -1) {
                      preDotState = -1;
                    }
                  }
                  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                    return "";
                  }
                  return path.slice(startDot, end);
                },
                format: function format(pathObject) {
                  if (pathObject === null || typeof pathObject !== "object") {
                    throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
                  }
                  return _format("/", pathObject);
                },
                parse: function parse(path) {
                  assertPath(path);
                  var ret = { root: "", dir: "", base: "", ext: "", name: "" };
                  if (path.length === 0) return ret;
                  var code = path.charCodeAt(0);
                  var isAbsolute = code === 47;
                  var start;
                  if (isAbsolute) {
                    ret.root = "/";
                    start = 1;
                  } else {
                    start = 0;
                  }
                  var startDot = -1;
                  var startPart = 0;
                  var end = -1;
                  var matchedSlash = true;
                  var i2 = path.length - 1;
                  var preDotState = 0;
                  for (; i2 >= start; --i2) {
                    code = path.charCodeAt(i2);
                    if (code === 47) {
                      if (!matchedSlash) {
                        startPart = i2 + 1;
                        break;
                      }
                      continue;
                    }
                    if (end === -1) {
                      matchedSlash = false;
                      end = i2 + 1;
                    }
                    if (code === 46) {
                      if (startDot === -1) startDot = i2;
                      else if (preDotState !== 1) preDotState = 1;
                    } else if (startDot !== -1) {
                      preDotState = -1;
                    }
                  }
                  if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
                  preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
                  preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
                    if (end !== -1) {
                      if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);
                      else ret.base = ret.name = path.slice(startPart, end);
                    }
                  } else {
                    if (startPart === 0 && isAbsolute) {
                      ret.name = path.slice(1, startDot);
                      ret.base = path.slice(1, end);
                    } else {
                      ret.name = path.slice(startPart, startDot);
                      ret.base = path.slice(startPart, end);
                    }
                    ret.ext = path.slice(startDot, end);
                  }
                  if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
                  else if (isAbsolute) ret.dir = "/";
                  return ret;
                },
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null
              };
              posix.posix = posix;
              module3.exports = posix;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "_process": 263 }], 263: [function(require2, module3, exports3) {
          var process = module3.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e2) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e2) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e2) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e22) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e2) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e22) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i2 = 1; i2 < arguments.length; i2++) {
                args[i2 - 1] = arguments[i2];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process.title = "browser";
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = "";
          process.versions = {};
          function noop2() {
          }
          process.on = noop2;
          process.addListener = noop2;
          process.once = noop2;
          process.off = noop2;
          process.removeListener = noop2;
          process.removeAllListeners = noop2;
          process.emit = noop2;
          process.prependListener = noop2;
          process.prependOnceListener = noop2;
          process.listeners = function(name) {
            return [];
          };
          process.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process.cwd = function() {
            return "/";
          };
          process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process.umask = function() {
            return 0;
          };
        }, {}], 264: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              (function(root) {
                var freeExports = typeof exports3 == "object" && exports3 && !exports3.nodeType && exports3;
                var freeModule = typeof module3 == "object" && module3 && !module3.nodeType && module3;
                var freeGlobal = typeof global2 == "object" && global2;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                  root = freeGlobal;
                }
                var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                  "overflow": "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                function error(type) {
                  throw new RangeError(errors[type]);
                }
                function map(array, fn) {
                  var length = array.length;
                  var result = [];
                  while (length--) {
                    result[length] = fn(array[length]);
                  }
                  return result;
                }
                function mapDomain(string, fn) {
                  var parts = string.split("@");
                  var result = "";
                  if (parts.length > 1) {
                    result = parts[0] + "@";
                    string = parts[1];
                  }
                  string = string.replace(regexSeparators, ".");
                  var labels = string.split(".");
                  var encoded = map(labels, fn).join(".");
                  return result + encoded;
                }
                function ucs2decode(string) {
                  var output = [], counter = 0, length = string.length, value, extra;
                  while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                      extra = string.charCodeAt(counter++);
                      if ((extra & 64512) == 56320) {
                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                      } else {
                        output.push(value);
                        counter--;
                      }
                    } else {
                      output.push(value);
                    }
                  }
                  return output;
                }
                function ucs2encode(array) {
                  return map(array, function(value) {
                    var output = "";
                    if (value > 65535) {
                      value -= 65536;
                      output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                      value = 56320 | value & 1023;
                    }
                    output += stringFromCharCode(value);
                    return output;
                  }).join("");
                }
                function basicToDigit(codePoint) {
                  if (codePoint - 48 < 10) {
                    return codePoint - 22;
                  }
                  if (codePoint - 65 < 26) {
                    return codePoint - 65;
                  }
                  if (codePoint - 97 < 26) {
                    return codePoint - 97;
                  }
                  return base;
                }
                function digitToBasic(digit, flag) {
                  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                  var k2 = 0;
                  delta = firstTime ? floor(delta / damp) : delta >> 1;
                  delta += floor(delta / numPoints);
                  for (; delta > baseMinusTMin * tMax >> 1; k2 += base) {
                    delta = floor(delta / baseMinusTMin);
                  }
                  return floor(k2 + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                  var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j2, index, oldi, w2, k2, digit, t2, baseMinusT;
                  basic = input.lastIndexOf(delimiter);
                  if (basic < 0) {
                    basic = 0;
                  }
                  for (j2 = 0; j2 < basic; ++j2) {
                    if (input.charCodeAt(j2) >= 128) {
                      error("not-basic");
                    }
                    output.push(input.charCodeAt(j2));
                  }
                  for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                    for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
                      if (index >= inputLength) {
                        error("invalid-input");
                      }
                      digit = basicToDigit(input.charCodeAt(index++));
                      if (digit >= base || digit > floor((maxInt - i2) / w2)) {
                        error("overflow");
                      }
                      i2 += digit * w2;
                      t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                      if (digit < t2) {
                        break;
                      }
                      baseMinusT = base - t2;
                      if (w2 > floor(maxInt / baseMinusT)) {
                        error("overflow");
                      }
                      w2 *= baseMinusT;
                    }
                    out = output.length + 1;
                    bias = adapt(i2 - oldi, out, oldi == 0);
                    if (floor(i2 / out) > maxInt - n2) {
                      error("overflow");
                    }
                    n2 += floor(i2 / out);
                    i2 %= out;
                    output.splice(i2++, 0, n2);
                  }
                  return ucs2encode(output);
                }
                function encode(input) {
                  var n2, delta, handledCPCount, basicLength, bias, j2, m2, q2, k2, t2, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                  input = ucs2decode(input);
                  inputLength = input.length;
                  n2 = initialN;
                  delta = 0;
                  bias = initialBias;
                  for (j2 = 0; j2 < inputLength; ++j2) {
                    currentValue = input[j2];
                    if (currentValue < 128) {
                      output.push(stringFromCharCode(currentValue));
                    }
                  }
                  handledCPCount = basicLength = output.length;
                  if (basicLength) {
                    output.push(delimiter);
                  }
                  while (handledCPCount < inputLength) {
                    for (m2 = maxInt, j2 = 0; j2 < inputLength; ++j2) {
                      currentValue = input[j2];
                      if (currentValue >= n2 && currentValue < m2) {
                        m2 = currentValue;
                      }
                    }
                    handledCPCountPlusOne = handledCPCount + 1;
                    if (m2 - n2 > floor((maxInt - delta) / handledCPCountPlusOne)) {
                      error("overflow");
                    }
                    delta += (m2 - n2) * handledCPCountPlusOne;
                    n2 = m2;
                    for (j2 = 0; j2 < inputLength; ++j2) {
                      currentValue = input[j2];
                      if (currentValue < n2 && ++delta > maxInt) {
                        error("overflow");
                      }
                      if (currentValue == n2) {
                        for (q2 = delta, k2 = base; ; k2 += base) {
                          t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
                          if (q2 < t2) {
                            break;
                          }
                          qMinusT = q2 - t2;
                          baseMinusT = base - t2;
                          output.push(
                            stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0))
                          );
                          q2 = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q2, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                      }
                    }
                    ++delta;
                    ++n2;
                  }
                  return output.join("");
                }
                function toUnicode(input) {
                  return mapDomain(input, function(string) {
                    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                  });
                }
                function toASCII(input) {
                  return mapDomain(input, function(string) {
                    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                  });
                }
                punycode = {
                  /**
                   * A string representing the current Punycode.js version number.
                   * @memberOf punycode
                   * @type String
                   */
                  "version": "1.4.1",
                  /**
                   * An object of methods to convert from JavaScript's internal character
                   * representation (UCS-2) to Unicode code points, and back.
                   * @see <https://mathiasbynens.be/notes/javascript-encoding>
                   * @memberOf punycode
                   * @type Object
                   */
                  "ucs2": {
                    "decode": ucs2decode,
                    "encode": ucs2encode
                  },
                  "decode": decode,
                  "encode": encode,
                  "toASCII": toASCII,
                  "toUnicode": toUnicode
                };
                if (freeExports && freeModule) {
                  if (module3.exports == freeExports) {
                    freeModule.exports = punycode;
                  } else {
                    for (key in punycode) {
                      punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                    }
                  }
                } else {
                  root.punycode = punycode;
                }
              })(this);
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 265: [function(require2, module3, exports3) {
          function hasOwnProperty2(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
          module3.exports = function(qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
              return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            if (options && typeof options.maxKeys === "number") {
              maxKeys = options.maxKeys;
            }
            var len = qs.length;
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys;
            }
            for (var i2 = 0; i2 < len; ++i2) {
              var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k2, v2;
              if (idx >= 0) {
                kstr = x2.substr(0, idx);
                vstr = x2.substr(idx + 1);
              } else {
                kstr = x2;
                vstr = "";
              }
              k2 = decodeURIComponent(kstr);
              v2 = decodeURIComponent(vstr);
              if (!hasOwnProperty2(obj, k2)) {
                obj[k2] = v2;
              } else if (isArray(obj[k2])) {
                obj[k2].push(v2);
              } else {
                obj[k2] = [obj[k2], v2];
              }
            }
            return obj;
          };
          var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
        }, {}], 266: [function(require2, module3, exports3) {
          var stringifyPrimitive = function(v2) {
            switch (typeof v2) {
              case "string":
                return v2;
              case "boolean":
                return v2 ? "true" : "false";
              case "number":
                return isFinite(v2) ? v2 : "";
              default:
                return "";
            }
          };
          module3.exports = function(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
              obj = void 0;
            }
            if (typeof obj === "object") {
              return map(objectKeys(obj), function(k2) {
                var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq;
                if (isArray(obj[k2])) {
                  return map(obj[k2], function(v2) {
                    return ks + encodeURIComponent(stringifyPrimitive(v2));
                  }).join(sep);
                } else {
                  return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
                }
              }).join(sep);
            }
            if (!name) return "";
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
          };
          var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
          function map(xs, f2) {
            if (xs.map) return xs.map(f2);
            var res = [];
            for (var i2 = 0; i2 < xs.length; i2++) {
              res.push(f2(xs[i2], i2));
            }
            return res;
          }
          var objectKeys = Object.keys || function(obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
          };
        }, {}], 267: [function(require2, module3, exports3) {
          exports3.decode = exports3.parse = require2("./decode");
          exports3.encode = exports3.stringify = require2("./encode");
        }, { "./decode": 265, "./encode": 266 }], 268: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var ClientRequest = require2("./lib/request");
              var response = require2("./lib/response");
              var extend = require2("xtend");
              var statusCodes = require2("builtin-status-codes");
              var url = require2("url");
              var http = exports3;
              http.request = function(opts, cb) {
                if (typeof opts === "string")
                  opts = url.parse(opts);
                else
                  opts = extend(opts);
                var defaultProtocol = global2.location.protocol.search(/^https?:$/) === -1 ? "http:" : "";
                var protocol = opts.protocol || defaultProtocol;
                var host = opts.hostname || opts.host;
                var port = opts.port;
                var path = opts.path || "/";
                if (host && host.indexOf(":") !== -1)
                  host = "[" + host + "]";
                opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path;
                opts.method = (opts.method || "GET").toUpperCase();
                opts.headers = opts.headers || {};
                var req = new ClientRequest(opts);
                if (cb)
                  req.on("response", cb);
                return req;
              };
              http.get = function get2(opts, cb) {
                var req = http.request(opts, cb);
                req.end();
                return req;
              };
              http.ClientRequest = ClientRequest;
              http.IncomingMessage = response.IncomingMessage;
              http.Agent = function() {
              };
              http.Agent.defaultMaxSockets = 4;
              http.globalAgent = new http.Agent();
              http.STATUS_CODES = statusCodes;
              http.METHODS = [
                "CHECKOUT",
                "CONNECT",
                "COPY",
                "DELETE",
                "GET",
                "HEAD",
                "LOCK",
                "M-SEARCH",
                "MERGE",
                "MKACTIVITY",
                "MKCOL",
                "MOVE",
                "NOTIFY",
                "OPTIONS",
                "PATCH",
                "POST",
                "PROPFIND",
                "PROPPATCH",
                "PURGE",
                "PUT",
                "REPORT",
                "SEARCH",
                "SUBSCRIBE",
                "TRACE",
                "UNLOCK",
                "UNSUBSCRIBE"
              ];
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./lib/request": 270, "./lib/response": 271, "builtin-status-codes": 35, "url": 303, "xtend": 310 }], 269: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              exports3.fetch = isFunction(global2.fetch) && isFunction(global2.ReadableStream);
              exports3.writableStream = isFunction(global2.WritableStream);
              exports3.abortController = isFunction(global2.AbortController);
              var xhr;
              function getXHR() {
                if (xhr !== void 0) return xhr;
                if (global2.XMLHttpRequest) {
                  xhr = new global2.XMLHttpRequest();
                  try {
                    xhr.open("GET", global2.XDomainRequest ? "/" : "https://example.com");
                  } catch (e2) {
                    xhr = null;
                  }
                } else {
                  xhr = null;
                }
                return xhr;
              }
              function checkTypeSupport(type) {
                var xhr2 = getXHR();
                if (!xhr2) return false;
                try {
                  xhr2.responseType = type;
                  return xhr2.responseType === type;
                } catch (e2) {
                }
                return false;
              }
              exports3.arraybuffer = exports3.fetch || checkTypeSupport("arraybuffer");
              exports3.msstream = !exports3.fetch && checkTypeSupport("ms-stream");
              exports3.mozchunkedarraybuffer = !exports3.fetch && checkTypeSupport("moz-chunked-arraybuffer");
              exports3.overrideMimeType = exports3.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);
              function isFunction(value) {
                return typeof value === "function";
              }
              xhr = null;
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 270: [function(require2, module3, exports3) {
          (function(process, global2, Buffer2) {
            (function() {
              var capability = require2("./capability");
              var inherits = require2("inherits");
              var response = require2("./response");
              var stream = require2("readable-stream");
              var IncomingMessage = response.IncomingMessage;
              var rStates = response.readyStates;
              function decideMode(preferBinary, useFetch) {
                if (capability.fetch && useFetch) {
                  return "fetch";
                } else if (capability.mozchunkedarraybuffer) {
                  return "moz-chunked-arraybuffer";
                } else if (capability.msstream) {
                  return "ms-stream";
                } else if (capability.arraybuffer && preferBinary) {
                  return "arraybuffer";
                } else {
                  return "text";
                }
              }
              var ClientRequest = module3.exports = function(opts) {
                var self2 = this;
                stream.Writable.call(self2);
                self2._opts = opts;
                self2._body = [];
                self2._headers = {};
                if (opts.auth)
                  self2.setHeader("Authorization", "Basic " + Buffer2.from(opts.auth).toString("base64"));
                Object.keys(opts.headers).forEach(function(name) {
                  self2.setHeader(name, opts.headers[name]);
                });
                var preferBinary;
                var useFetch = true;
                if (opts.mode === "disable-fetch" || "requestTimeout" in opts && !capability.abortController) {
                  useFetch = false;
                  preferBinary = true;
                } else if (opts.mode === "prefer-streaming") {
                  preferBinary = false;
                } else if (opts.mode === "allow-wrong-content-type") {
                  preferBinary = !capability.overrideMimeType;
                } else if (!opts.mode || opts.mode === "default" || opts.mode === "prefer-fast") {
                  preferBinary = true;
                } else {
                  throw new Error("Invalid value for opts.mode");
                }
                self2._mode = decideMode(preferBinary, useFetch);
                self2._fetchTimer = null;
                self2.on("finish", function() {
                  self2._onFinish();
                });
              };
              inherits(ClientRequest, stream.Writable);
              ClientRequest.prototype.setHeader = function(name, value) {
                var self2 = this;
                var lowerName = name.toLowerCase();
                if (unsafeHeaders.indexOf(lowerName) !== -1)
                  return;
                self2._headers[lowerName] = {
                  name,
                  value
                };
              };
              ClientRequest.prototype.getHeader = function(name) {
                var header = this._headers[name.toLowerCase()];
                if (header)
                  return header.value;
                return null;
              };
              ClientRequest.prototype.removeHeader = function(name) {
                var self2 = this;
                delete self2._headers[name.toLowerCase()];
              };
              ClientRequest.prototype._onFinish = function() {
                var self2 = this;
                if (self2._destroyed)
                  return;
                var opts = self2._opts;
                var headersObj = self2._headers;
                var body = null;
                if (opts.method !== "GET" && opts.method !== "HEAD") {
                  body = new Blob(self2._body, {
                    type: (headersObj["content-type"] || {}).value || ""
                  });
                }
                var headersList = [];
                Object.keys(headersObj).forEach(function(keyName) {
                  var name = headersObj[keyName].name;
                  var value = headersObj[keyName].value;
                  if (Array.isArray(value)) {
                    value.forEach(function(v2) {
                      headersList.push([name, v2]);
                    });
                  } else {
                    headersList.push([name, value]);
                  }
                });
                if (self2._mode === "fetch") {
                  var signal2 = null;
                  if (capability.abortController) {
                    var controller = new AbortController();
                    signal2 = controller.signal;
                    self2._fetchAbortController = controller;
                    if ("requestTimeout" in opts && opts.requestTimeout !== 0) {
                      self2._fetchTimer = global2.setTimeout(function() {
                        self2.emit("requestTimeout");
                        if (self2._fetchAbortController)
                          self2._fetchAbortController.abort();
                      }, opts.requestTimeout);
                    }
                  }
                  global2.fetch(self2._opts.url, {
                    method: self2._opts.method,
                    headers: headersList,
                    body: body || void 0,
                    mode: "cors",
                    credentials: opts.withCredentials ? "include" : "same-origin",
                    signal: signal2
                  }).then(function(response2) {
                    self2._fetchResponse = response2;
                    self2._connect();
                  }, function(reason) {
                    global2.clearTimeout(self2._fetchTimer);
                    if (!self2._destroyed)
                      self2.emit("error", reason);
                  });
                } else {
                  var xhr = self2._xhr = new global2.XMLHttpRequest();
                  try {
                    xhr.open(self2._opts.method, self2._opts.url, true);
                  } catch (err) {
                    process.nextTick(function() {
                      self2.emit("error", err);
                    });
                    return;
                  }
                  if ("responseType" in xhr)
                    xhr.responseType = self2._mode;
                  if ("withCredentials" in xhr)
                    xhr.withCredentials = !!opts.withCredentials;
                  if (self2._mode === "text" && "overrideMimeType" in xhr)
                    xhr.overrideMimeType("text/plain; charset=x-user-defined");
                  if ("requestTimeout" in opts) {
                    xhr.timeout = opts.requestTimeout;
                    xhr.ontimeout = function() {
                      self2.emit("requestTimeout");
                    };
                  }
                  headersList.forEach(function(header) {
                    xhr.setRequestHeader(header[0], header[1]);
                  });
                  self2._response = null;
                  xhr.onreadystatechange = function() {
                    switch (xhr.readyState) {
                      case rStates.LOADING:
                      case rStates.DONE:
                        self2._onXHRProgress();
                        break;
                    }
                  };
                  if (self2._mode === "moz-chunked-arraybuffer") {
                    xhr.onprogress = function() {
                      self2._onXHRProgress();
                    };
                  }
                  xhr.onerror = function() {
                    if (self2._destroyed)
                      return;
                    self2.emit("error", new Error("XHR error"));
                  };
                  try {
                    xhr.send(body);
                  } catch (err) {
                    process.nextTick(function() {
                      self2.emit("error", err);
                    });
                    return;
                  }
                }
              };
              function statusValid(xhr) {
                try {
                  var status = xhr.status;
                  return status !== null && status !== 0;
                } catch (e2) {
                  return false;
                }
              }
              ClientRequest.prototype._onXHRProgress = function() {
                var self2 = this;
                if (!statusValid(self2._xhr) || self2._destroyed)
                  return;
                if (!self2._response)
                  self2._connect();
                self2._response._onXHRProgress();
              };
              ClientRequest.prototype._connect = function() {
                var self2 = this;
                if (self2._destroyed)
                  return;
                self2._response = new IncomingMessage(self2._xhr, self2._fetchResponse, self2._mode, self2._fetchTimer);
                self2._response.on("error", function(err) {
                  self2.emit("error", err);
                });
                self2.emit("response", self2._response);
              };
              ClientRequest.prototype._write = function(chunk, encoding, cb) {
                var self2 = this;
                self2._body.push(chunk);
                cb();
              };
              ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
                var self2 = this;
                self2._destroyed = true;
                global2.clearTimeout(self2._fetchTimer);
                if (self2._response)
                  self2._response._destroyed = true;
                if (self2._xhr)
                  self2._xhr.abort();
                else if (self2._fetchAbortController)
                  self2._fetchAbortController.abort();
              };
              ClientRequest.prototype.end = function(data, encoding, cb) {
                var self2 = this;
                if (typeof data === "function") {
                  cb = data;
                  data = void 0;
                }
                stream.Writable.prototype.end.call(self2, data, encoding, cb);
              };
              ClientRequest.prototype.flushHeaders = function() {
              };
              ClientRequest.prototype.setTimeout = function() {
              };
              ClientRequest.prototype.setNoDelay = function() {
              };
              ClientRequest.prototype.setSocketKeepAlive = function() {
              };
              var unsafeHeaders = [
                "accept-charset",
                "accept-encoding",
                "access-control-request-headers",
                "access-control-request-method",
                "connection",
                "content-length",
                "cookie",
                "cookie2",
                "date",
                "dnt",
                "expect",
                "host",
                "keep-alive",
                "origin",
                "referer",
                "te",
                "trailer",
                "transfer-encoding",
                "upgrade",
                "via"
              ];
            }).call(this);
          }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
        }, { "./capability": 269, "./response": 271, "_process": 263, "buffer": 34, "inherits": 195, "readable-stream": 286 }], 271: [function(require2, module3, exports3) {
          (function(process, global2, Buffer2) {
            (function() {
              var capability = require2("./capability");
              var inherits = require2("inherits");
              var stream = require2("readable-stream");
              var rStates = exports3.readyStates = {
                UNSENT: 0,
                OPENED: 1,
                HEADERS_RECEIVED: 2,
                LOADING: 3,
                DONE: 4
              };
              var IncomingMessage = exports3.IncomingMessage = function(xhr, response, mode, fetchTimer) {
                var self2 = this;
                stream.Readable.call(self2);
                self2._mode = mode;
                self2.headers = {};
                self2.rawHeaders = [];
                self2.trailers = {};
                self2.rawTrailers = [];
                self2.on("end", function() {
                  process.nextTick(function() {
                    self2.emit("close");
                  });
                });
                if (mode === "fetch") {
                  let read2 = function() {
                    reader.read().then(function(result) {
                      if (self2._destroyed)
                        return;
                      if (result.done) {
                        global2.clearTimeout(fetchTimer);
                        self2.push(null);
                        return;
                      }
                      self2.push(Buffer2.from(result.value));
                      read2();
                    }).catch(function(err) {
                      global2.clearTimeout(fetchTimer);
                      if (!self2._destroyed)
                        self2.emit("error", err);
                    });
                  };
                  self2._fetchResponse = response;
                  self2.url = response.url;
                  self2.statusCode = response.status;
                  self2.statusMessage = response.statusText;
                  response.headers.forEach(function(header, key) {
                    self2.headers[key.toLowerCase()] = header;
                    self2.rawHeaders.push(key, header);
                  });
                  if (capability.writableStream) {
                    var writable = new WritableStream({
                      write: function(chunk) {
                        return new Promise(function(resolve, reject) {
                          if (self2._destroyed) {
                            reject();
                          } else if (self2.push(Buffer2.from(chunk))) {
                            resolve();
                          } else {
                            self2._resumeFetch = resolve;
                          }
                        });
                      },
                      close: function() {
                        global2.clearTimeout(fetchTimer);
                        if (!self2._destroyed)
                          self2.push(null);
                      },
                      abort: function(err) {
                        if (!self2._destroyed)
                          self2.emit("error", err);
                      }
                    });
                    try {
                      response.body.pipeTo(writable).catch(function(err) {
                        global2.clearTimeout(fetchTimer);
                        if (!self2._destroyed)
                          self2.emit("error", err);
                      });
                      return;
                    } catch (e2) {
                    }
                  }
                  var reader = response.body.getReader();
                  read2();
                } else {
                  self2._xhr = xhr;
                  self2._pos = 0;
                  self2.url = xhr.responseURL;
                  self2.statusCode = xhr.status;
                  self2.statusMessage = xhr.statusText;
                  var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
                  headers.forEach(function(header) {
                    var matches = header.match(/^([^:]+):\s*(.*)/);
                    if (matches) {
                      var key = matches[1].toLowerCase();
                      if (key === "set-cookie") {
                        if (self2.headers[key] === void 0) {
                          self2.headers[key] = [];
                        }
                        self2.headers[key].push(matches[2]);
                      } else if (self2.headers[key] !== void 0) {
                        self2.headers[key] += ", " + matches[2];
                      } else {
                        self2.headers[key] = matches[2];
                      }
                      self2.rawHeaders.push(matches[1], matches[2]);
                    }
                  });
                  self2._charset = "x-user-defined";
                  if (!capability.overrideMimeType) {
                    var mimeType = self2.rawHeaders["mime-type"];
                    if (mimeType) {
                      var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                      if (charsetMatch) {
                        self2._charset = charsetMatch[1].toLowerCase();
                      }
                    }
                    if (!self2._charset)
                      self2._charset = "utf-8";
                  }
                }
              };
              inherits(IncomingMessage, stream.Readable);
              IncomingMessage.prototype._read = function() {
                var self2 = this;
                var resolve = self2._resumeFetch;
                if (resolve) {
                  self2._resumeFetch = null;
                  resolve();
                }
              };
              IncomingMessage.prototype._onXHRProgress = function() {
                var self2 = this;
                var xhr = self2._xhr;
                var response = null;
                switch (self2._mode) {
                  case "text":
                    response = xhr.responseText;
                    if (response.length > self2._pos) {
                      var newData = response.substr(self2._pos);
                      if (self2._charset === "x-user-defined") {
                        var buffer = Buffer2.alloc(newData.length);
                        for (var i2 = 0; i2 < newData.length; i2++)
                          buffer[i2] = newData.charCodeAt(i2) & 255;
                        self2.push(buffer);
                      } else {
                        self2.push(newData, self2._charset);
                      }
                      self2._pos = response.length;
                    }
                    break;
                  case "arraybuffer":
                    if (xhr.readyState !== rStates.DONE || !xhr.response)
                      break;
                    response = xhr.response;
                    self2.push(Buffer2.from(new Uint8Array(response)));
                    break;
                  case "moz-chunked-arraybuffer":
                    response = xhr.response;
                    if (xhr.readyState !== rStates.LOADING || !response)
                      break;
                    self2.push(Buffer2.from(new Uint8Array(response)));
                    break;
                  case "ms-stream":
                    response = xhr.response;
                    if (xhr.readyState !== rStates.LOADING)
                      break;
                    var reader = new global2.MSStreamReader();
                    reader.onprogress = function() {
                      if (reader.result.byteLength > self2._pos) {
                        self2.push(Buffer2.from(new Uint8Array(reader.result.slice(self2._pos))));
                        self2._pos = reader.result.byteLength;
                      }
                    };
                    reader.onload = function() {
                      self2.push(null);
                    };
                    reader.readAsArrayBuffer(response);
                    break;
                }
                if (self2._xhr.readyState === rStates.DONE && self2._mode !== "ms-stream") {
                  self2.push(null);
                }
              };
            }).call(this);
          }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
        }, { "./capability": 269, "_process": 263, "buffer": 34, "inherits": 195, "readable-stream": 286 }], 272: [function(require2, module3, exports3) {
          function _inheritsLoose(subClass, superClass) {
            subClass.prototype = Object.create(superClass.prototype);
            subClass.prototype.constructor = subClass;
            subClass.__proto__ = superClass;
          }
          var codes = {};
          function createErrorType(code, message, Base) {
            if (!Base) {
              Base = Error;
            }
            function getMessage(arg1, arg2, arg3) {
              if (typeof message === "string") {
                return message;
              } else {
                return message(arg1, arg2, arg3);
              }
            }
            var NodeError = /* @__PURE__ */ function(_Base) {
              _inheritsLoose(NodeError2, _Base);
              function NodeError2(arg1, arg2, arg3) {
                return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
              }
              return NodeError2;
            }(Base);
            NodeError.prototype.name = Base.name;
            NodeError.prototype.code = code;
            codes[code] = NodeError;
          }
          function oneOf(expected, thing) {
            if (Array.isArray(expected)) {
              var len = expected.length;
              expected = expected.map(function(i2) {
                return String(i2);
              });
              if (len > 2) {
                return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
              } else if (len === 2) {
                return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
              } else {
                return "of ".concat(thing, " ").concat(expected[0]);
              }
            } else {
              return "of ".concat(thing, " ").concat(String(expected));
            }
          }
          function startsWith(str, search, pos) {
            return str.substr(0, search.length) === search;
          }
          function endsWith(str, search, this_len) {
            if (this_len === void 0 || this_len > str.length) {
              this_len = str.length;
            }
            return str.substring(this_len - search.length, this_len) === search;
          }
          function includes(str, search, start) {
            if (typeof start !== "number") {
              start = 0;
            }
            if (start + search.length > str.length) {
              return false;
            } else {
              return str.indexOf(search, start) !== -1;
            }
          }
          createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
            return 'The value "' + value + '" is invalid for option "' + name + '"';
          }, TypeError);
          createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
            var determiner;
            if (typeof expected === "string" && startsWith(expected, "not ")) {
              determiner = "must not be";
              expected = expected.replace(/^not /, "");
            } else {
              determiner = "must be";
            }
            var msg;
            if (endsWith(name, " argument")) {
              msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
            } else {
              var type = includes(name, ".") ? "property" : "argument";
              msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
            }
            msg += ". Received type ".concat(typeof actual);
            return msg;
          }, TypeError);
          createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
          createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
            return "The " + name + " method is not implemented";
          });
          createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
          createErrorType("ERR_STREAM_DESTROYED", function(name) {
            return "Cannot call " + name + " after a stream was destroyed";
          });
          createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
          createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
          createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
          createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
          createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
            return "Unknown encoding: " + arg;
          }, TypeError);
          createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
          module3.exports.codes = codes;
        }, {}], 273: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var objectKeys = Object.keys || function(obj) {
                var keys2 = [];
                for (var key in obj) {
                  keys2.push(key);
                }
                return keys2;
              };
              module3.exports = Duplex;
              var Readable = require2("./_stream_readable");
              var Writable = require2("./_stream_writable");
              require2("inherits")(Duplex, Readable);
              {
                var keys = objectKeys(Writable.prototype);
                for (var v2 = 0; v2 < keys.length; v2++) {
                  var method = keys[v2];
                  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
                }
              }
              function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options);
                Readable.call(this, options);
                Writable.call(this, options);
                this.allowHalfOpen = true;
                if (options) {
                  if (options.readable === false) this.readable = false;
                  if (options.writable === false) this.writable = false;
                  if (options.allowHalfOpen === false) {
                    this.allowHalfOpen = false;
                    this.once("end", onend);
                  }
                }
              }
              Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._writableState.highWaterMark;
                }
              });
              Object.defineProperty(Duplex.prototype, "writableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._writableState && this._writableState.getBuffer();
                }
              });
              Object.defineProperty(Duplex.prototype, "writableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._writableState.length;
                }
              });
              function onend() {
                if (this._writableState.ended) return;
                process.nextTick(onEndNT, this);
              }
              function onEndNT(self2) {
                self2.end();
              }
              Object.defineProperty(Duplex.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  if (this._readableState === void 0 || this._writableState === void 0) {
                    return false;
                  }
                  return this._readableState.destroyed && this._writableState.destroyed;
                },
                set: function set(value) {
                  if (this._readableState === void 0 || this._writableState === void 0) {
                    return;
                  }
                  this._readableState.destroyed = value;
                  this._writableState.destroyed = value;
                }
              });
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./_stream_readable": 275, "./_stream_writable": 277, "_process": 263, "inherits": 195 }], 274: [function(require2, module3, exports3) {
          module3.exports = PassThrough;
          var Transform = require2("./_stream_transform");
          require2("inherits")(PassThrough, Transform);
          function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options);
            Transform.call(this, options);
          }
          PassThrough.prototype._transform = function(chunk, encoding, cb) {
            cb(null, chunk);
          };
        }, { "./_stream_transform": 276, "inherits": 195 }], 275: [function(require2, module3, exports3) {
          (function(process, global2) {
            (function() {
              module3.exports = Readable;
              var Duplex;
              Readable.ReadableState = ReadableState;
              require2("events").EventEmitter;
              var EElistenerCount = function EElistenerCount2(emitter, type) {
                return emitter.listeners(type).length;
              };
              var Stream = require2("./internal/streams/stream");
              var Buffer2 = require2("buffer").Buffer;
              var OurUint8Array = global2.Uint8Array || function() {
              };
              function _uint8ArrayToBuffer(chunk) {
                return Buffer2.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var debugUtil = require2("util");
              var debug;
              if (debugUtil && debugUtil.debuglog) {
                debug = debugUtil.debuglog("stream");
              } else {
                debug = function debug2() {
                };
              }
              var BufferList = require2("./internal/streams/buffer_list");
              var destroyImpl = require2("./internal/streams/destroy");
              var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
              var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
              var StringDecoder;
              var createReadableStreamAsyncIterator;
              var from;
              require2("inherits")(Readable, Stream);
              var errorOrDestroy = destroyImpl.errorOrDestroy;
              var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
              function prependListener(emitter, event, fn) {
                if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
                if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
                else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
                else emitter._events[event] = [fn, emitter._events[event]];
              }
              function ReadableState(options, stream, isDuplex) {
                Duplex = Duplex || require2("./_stream_duplex");
                options = options || {};
                if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
                this.objectMode = !!options.objectMode;
                if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
                this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
                this.buffer = new BufferList();
                this.length = 0;
                this.pipes = null;
                this.pipesCount = 0;
                this.flowing = null;
                this.ended = false;
                this.endEmitted = false;
                this.reading = false;
                this.sync = true;
                this.needReadable = false;
                this.emittedReadable = false;
                this.readableListening = false;
                this.resumeScheduled = false;
                this.paused = true;
                this.emitClose = options.emitClose !== false;
                this.autoDestroy = !!options.autoDestroy;
                this.destroyed = false;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.awaitDrain = 0;
                this.readingMore = false;
                this.decoder = null;
                this.encoding = null;
                if (options.encoding) {
                  if (!StringDecoder) StringDecoder = require2("string_decoder/").StringDecoder;
                  this.decoder = new StringDecoder(options.encoding);
                  this.encoding = options.encoding;
                }
              }
              function Readable(options) {
                Duplex = Duplex || require2("./_stream_duplex");
                if (!(this instanceof Readable)) return new Readable(options);
                var isDuplex = this instanceof Duplex;
                this._readableState = new ReadableState(options, this, isDuplex);
                this.readable = true;
                if (options) {
                  if (typeof options.read === "function") this._read = options.read;
                  if (typeof options.destroy === "function") this._destroy = options.destroy;
                }
                Stream.call(this);
              }
              Object.defineProperty(Readable.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  if (this._readableState === void 0) {
                    return false;
                  }
                  return this._readableState.destroyed;
                },
                set: function set(value) {
                  if (!this._readableState) {
                    return;
                  }
                  this._readableState.destroyed = value;
                }
              });
              Readable.prototype.destroy = destroyImpl.destroy;
              Readable.prototype._undestroy = destroyImpl.undestroy;
              Readable.prototype._destroy = function(err, cb) {
                cb(err);
              };
              Readable.prototype.push = function(chunk, encoding) {
                var state = this._readableState;
                var skipChunkCheck;
                if (!state.objectMode) {
                  if (typeof chunk === "string") {
                    encoding = encoding || state.defaultEncoding;
                    if (encoding !== state.encoding) {
                      chunk = Buffer2.from(chunk, encoding);
                      encoding = "";
                    }
                    skipChunkCheck = true;
                  }
                } else {
                  skipChunkCheck = true;
                }
                return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
              };
              Readable.prototype.unshift = function(chunk) {
                return readableAddChunk(this, chunk, null, true, false);
              };
              function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                debug("readableAddChunk", chunk);
                var state = stream._readableState;
                if (chunk === null) {
                  state.reading = false;
                  onEofChunk(stream, state);
                } else {
                  var er;
                  if (!skipChunkCheck) er = chunkInvalid(state, chunk);
                  if (er) {
                    errorOrDestroy(stream, er);
                  } else if (state.objectMode || chunk && chunk.length > 0) {
                    if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
                      chunk = _uint8ArrayToBuffer(chunk);
                    }
                    if (addToFront) {
                      if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                      else addChunk(stream, state, chunk, true);
                    } else if (state.ended) {
                      errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
                    } else if (state.destroyed) {
                      return false;
                    } else {
                      state.reading = false;
                      if (state.decoder && !encoding) {
                        chunk = state.decoder.write(chunk);
                        if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
                        else maybeReadMore(stream, state);
                      } else {
                        addChunk(stream, state, chunk, false);
                      }
                    }
                  } else if (!addToFront) {
                    state.reading = false;
                    maybeReadMore(stream, state);
                  }
                }
                return !state.ended && (state.length < state.highWaterMark || state.length === 0);
              }
              function addChunk(stream, state, chunk, addToFront) {
                if (state.flowing && state.length === 0 && !state.sync) {
                  state.awaitDrain = 0;
                  stream.emit("data", chunk);
                } else {
                  state.length += state.objectMode ? 1 : chunk.length;
                  if (addToFront) state.buffer.unshift(chunk);
                  else state.buffer.push(chunk);
                  if (state.needReadable) emitReadable(stream);
                }
                maybeReadMore(stream, state);
              }
              function chunkInvalid(state, chunk) {
                var er;
                if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
                  er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
                }
                return er;
              }
              Readable.prototype.isPaused = function() {
                return this._readableState.flowing === false;
              };
              Readable.prototype.setEncoding = function(enc) {
                if (!StringDecoder) StringDecoder = require2("string_decoder/").StringDecoder;
                var decoder = new StringDecoder(enc);
                this._readableState.decoder = decoder;
                this._readableState.encoding = this._readableState.decoder.encoding;
                var p2 = this._readableState.buffer.head;
                var content = "";
                while (p2 !== null) {
                  content += decoder.write(p2.data);
                  p2 = p2.next;
                }
                this._readableState.buffer.clear();
                if (content !== "") this._readableState.buffer.push(content);
                this._readableState.length = content.length;
                return this;
              };
              var MAX_HWM = 1073741824;
              function computeNewHighWaterMark(n2) {
                if (n2 >= MAX_HWM) {
                  n2 = MAX_HWM;
                } else {
                  n2--;
                  n2 |= n2 >>> 1;
                  n2 |= n2 >>> 2;
                  n2 |= n2 >>> 4;
                  n2 |= n2 >>> 8;
                  n2 |= n2 >>> 16;
                  n2++;
                }
                return n2;
              }
              function howMuchToRead(n2, state) {
                if (n2 <= 0 || state.length === 0 && state.ended) return 0;
                if (state.objectMode) return 1;
                if (n2 !== n2) {
                  if (state.flowing && state.length) return state.buffer.head.data.length;
                  else return state.length;
                }
                if (n2 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n2);
                if (n2 <= state.length) return n2;
                if (!state.ended) {
                  state.needReadable = true;
                  return 0;
                }
                return state.length;
              }
              Readable.prototype.read = function(n2) {
                debug("read", n2);
                n2 = parseInt(n2, 10);
                var state = this._readableState;
                var nOrig = n2;
                if (n2 !== 0) state.emittedReadable = false;
                if (n2 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
                  debug("read: emitReadable", state.length, state.ended);
                  if (state.length === 0 && state.ended) endReadable(this);
                  else emitReadable(this);
                  return null;
                }
                n2 = howMuchToRead(n2, state);
                if (n2 === 0 && state.ended) {
                  if (state.length === 0) endReadable(this);
                  return null;
                }
                var doRead = state.needReadable;
                debug("need readable", doRead);
                if (state.length === 0 || state.length - n2 < state.highWaterMark) {
                  doRead = true;
                  debug("length less than watermark", doRead);
                }
                if (state.ended || state.reading) {
                  doRead = false;
                  debug("reading or ended", doRead);
                } else if (doRead) {
                  debug("do read");
                  state.reading = true;
                  state.sync = true;
                  if (state.length === 0) state.needReadable = true;
                  this._read(state.highWaterMark);
                  state.sync = false;
                  if (!state.reading) n2 = howMuchToRead(nOrig, state);
                }
                var ret;
                if (n2 > 0) ret = fromList(n2, state);
                else ret = null;
                if (ret === null) {
                  state.needReadable = state.length <= state.highWaterMark;
                  n2 = 0;
                } else {
                  state.length -= n2;
                  state.awaitDrain = 0;
                }
                if (state.length === 0) {
                  if (!state.ended) state.needReadable = true;
                  if (nOrig !== n2 && state.ended) endReadable(this);
                }
                if (ret !== null) this.emit("data", ret);
                return ret;
              };
              function onEofChunk(stream, state) {
                debug("onEofChunk");
                if (state.ended) return;
                if (state.decoder) {
                  var chunk = state.decoder.end();
                  if (chunk && chunk.length) {
                    state.buffer.push(chunk);
                    state.length += state.objectMode ? 1 : chunk.length;
                  }
                }
                state.ended = true;
                if (state.sync) {
                  emitReadable(stream);
                } else {
                  state.needReadable = false;
                  if (!state.emittedReadable) {
                    state.emittedReadable = true;
                    emitReadable_(stream);
                  }
                }
              }
              function emitReadable(stream) {
                var state = stream._readableState;
                debug("emitReadable", state.needReadable, state.emittedReadable);
                state.needReadable = false;
                if (!state.emittedReadable) {
                  debug("emitReadable", state.flowing);
                  state.emittedReadable = true;
                  process.nextTick(emitReadable_, stream);
                }
              }
              function emitReadable_(stream) {
                var state = stream._readableState;
                debug("emitReadable_", state.destroyed, state.length, state.ended);
                if (!state.destroyed && (state.length || state.ended)) {
                  stream.emit("readable");
                  state.emittedReadable = false;
                }
                state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
                flow(stream);
              }
              function maybeReadMore(stream, state) {
                if (!state.readingMore) {
                  state.readingMore = true;
                  process.nextTick(maybeReadMore_, stream, state);
                }
              }
              function maybeReadMore_(stream, state) {
                while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
                  var len = state.length;
                  debug("maybeReadMore read 0");
                  stream.read(0);
                  if (len === state.length)
                    break;
                }
                state.readingMore = false;
              }
              Readable.prototype._read = function(n2) {
                errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
              };
              Readable.prototype.pipe = function(dest, pipeOpts) {
                var src = this;
                var state = this._readableState;
                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest;
                    break;
                  case 1:
                    state.pipes = [state.pipes, dest];
                    break;
                  default:
                    state.pipes.push(dest);
                    break;
                }
                state.pipesCount += 1;
                debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                var endFn = doEnd ? onend : unpipe;
                if (state.endEmitted) process.nextTick(endFn);
                else src.once("end", endFn);
                dest.on("unpipe", onunpipe);
                function onunpipe(readable, unpipeInfo) {
                  debug("onunpipe");
                  if (readable === src) {
                    if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                      unpipeInfo.hasUnpiped = true;
                      cleanup();
                    }
                  }
                }
                function onend() {
                  debug("onend");
                  dest.end();
                }
                var ondrain = pipeOnDrain(src);
                dest.on("drain", ondrain);
                var cleanedUp = false;
                function cleanup() {
                  debug("cleanup");
                  dest.removeListener("close", onclose);
                  dest.removeListener("finish", onfinish);
                  dest.removeListener("drain", ondrain);
                  dest.removeListener("error", onerror);
                  dest.removeListener("unpipe", onunpipe);
                  src.removeListener("end", onend);
                  src.removeListener("end", unpipe);
                  src.removeListener("data", ondata);
                  cleanedUp = true;
                  if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
                }
                src.on("data", ondata);
                function ondata(chunk) {
                  debug("ondata");
                  var ret = dest.write(chunk);
                  debug("dest.write", ret);
                  if (ret === false) {
                    if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                      debug("false write response, pause", state.awaitDrain);
                      state.awaitDrain++;
                    }
                    src.pause();
                  }
                }
                function onerror(er) {
                  debug("onerror", er);
                  unpipe();
                  dest.removeListener("error", onerror);
                  if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
                }
                prependListener(dest, "error", onerror);
                function onclose() {
                  dest.removeListener("finish", onfinish);
                  unpipe();
                }
                dest.once("close", onclose);
                function onfinish() {
                  debug("onfinish");
                  dest.removeListener("close", onclose);
                  unpipe();
                }
                dest.once("finish", onfinish);
                function unpipe() {
                  debug("unpipe");
                  src.unpipe(dest);
                }
                dest.emit("pipe", src);
                if (!state.flowing) {
                  debug("pipe resume");
                  src.resume();
                }
                return dest;
              };
              function pipeOnDrain(src) {
                return function pipeOnDrainFunctionResult() {
                  var state = src._readableState;
                  debug("pipeOnDrain", state.awaitDrain);
                  if (state.awaitDrain) state.awaitDrain--;
                  if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
                    state.flowing = true;
                    flow(src);
                  }
                };
              }
              Readable.prototype.unpipe = function(dest) {
                var state = this._readableState;
                var unpipeInfo = {
                  hasUnpiped: false
                };
                if (state.pipesCount === 0) return this;
                if (state.pipesCount === 1) {
                  if (dest && dest !== state.pipes) return this;
                  if (!dest) dest = state.pipes;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  if (dest) dest.emit("unpipe", this, unpipeInfo);
                  return this;
                }
                if (!dest) {
                  var dests = state.pipes;
                  var len = state.pipesCount;
                  state.pipes = null;
                  state.pipesCount = 0;
                  state.flowing = false;
                  for (var i2 = 0; i2 < len; i2++) {
                    dests[i2].emit("unpipe", this, {
                      hasUnpiped: false
                    });
                  }
                  return this;
                }
                var index = indexOf(state.pipes, dest);
                if (index === -1) return this;
                state.pipes.splice(index, 1);
                state.pipesCount -= 1;
                if (state.pipesCount === 1) state.pipes = state.pipes[0];
                dest.emit("unpipe", this, unpipeInfo);
                return this;
              };
              Readable.prototype.on = function(ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                var state = this._readableState;
                if (ev === "data") {
                  state.readableListening = this.listenerCount("readable") > 0;
                  if (state.flowing !== false) this.resume();
                } else if (ev === "readable") {
                  if (!state.endEmitted && !state.readableListening) {
                    state.readableListening = state.needReadable = true;
                    state.flowing = false;
                    state.emittedReadable = false;
                    debug("on readable", state.length, state.reading);
                    if (state.length) {
                      emitReadable(this);
                    } else if (!state.reading) {
                      process.nextTick(nReadingNextTick, this);
                    }
                  }
                }
                return res;
              };
              Readable.prototype.addListener = Readable.prototype.on;
              Readable.prototype.removeListener = function(ev, fn) {
                var res = Stream.prototype.removeListener.call(this, ev, fn);
                if (ev === "readable") {
                  process.nextTick(updateReadableListening, this);
                }
                return res;
              };
              Readable.prototype.removeAllListeners = function(ev) {
                var res = Stream.prototype.removeAllListeners.apply(this, arguments);
                if (ev === "readable" || ev === void 0) {
                  process.nextTick(updateReadableListening, this);
                }
                return res;
              };
              function updateReadableListening(self2) {
                var state = self2._readableState;
                state.readableListening = self2.listenerCount("readable") > 0;
                if (state.resumeScheduled && !state.paused) {
                  state.flowing = true;
                } else if (self2.listenerCount("data") > 0) {
                  self2.resume();
                }
              }
              function nReadingNextTick(self2) {
                debug("readable nexttick read 0");
                self2.read(0);
              }
              Readable.prototype.resume = function() {
                var state = this._readableState;
                if (!state.flowing) {
                  debug("resume");
                  state.flowing = !state.readableListening;
                  resume(this, state);
                }
                state.paused = false;
                return this;
              };
              function resume(stream, state) {
                if (!state.resumeScheduled) {
                  state.resumeScheduled = true;
                  process.nextTick(resume_, stream, state);
                }
              }
              function resume_(stream, state) {
                debug("resume", state.reading);
                if (!state.reading) {
                  stream.read(0);
                }
                state.resumeScheduled = false;
                stream.emit("resume");
                flow(stream);
                if (state.flowing && !state.reading) stream.read(0);
              }
              Readable.prototype.pause = function() {
                debug("call pause flowing=%j", this._readableState.flowing);
                if (this._readableState.flowing !== false) {
                  debug("pause");
                  this._readableState.flowing = false;
                  this.emit("pause");
                }
                this._readableState.paused = true;
                return this;
              };
              function flow(stream) {
                var state = stream._readableState;
                debug("flow", state.flowing);
                while (state.flowing && stream.read() !== null) {
                }
              }
              Readable.prototype.wrap = function(stream) {
                var _this = this;
                var state = this._readableState;
                var paused = false;
                stream.on("end", function() {
                  debug("wrapped end");
                  if (state.decoder && !state.ended) {
                    var chunk = state.decoder.end();
                    if (chunk && chunk.length) _this.push(chunk);
                  }
                  _this.push(null);
                });
                stream.on("data", function(chunk) {
                  debug("wrapped data");
                  if (state.decoder) chunk = state.decoder.write(chunk);
                  if (state.objectMode && (chunk === null || chunk === void 0)) return;
                  else if (!state.objectMode && (!chunk || !chunk.length)) return;
                  var ret = _this.push(chunk);
                  if (!ret) {
                    paused = true;
                    stream.pause();
                  }
                });
                for (var i2 in stream) {
                  if (this[i2] === void 0 && typeof stream[i2] === "function") {
                    this[i2] = /* @__PURE__ */ function methodWrap(method) {
                      return function methodWrapReturnFunction() {
                        return stream[method].apply(stream, arguments);
                      };
                    }(i2);
                  }
                }
                for (var n2 = 0; n2 < kProxyEvents.length; n2++) {
                  stream.on(kProxyEvents[n2], this.emit.bind(this, kProxyEvents[n2]));
                }
                this._read = function(n22) {
                  debug("wrapped _read", n22);
                  if (paused) {
                    paused = false;
                    stream.resume();
                  }
                };
                return this;
              };
              if (typeof Symbol === "function") {
                Readable.prototype[Symbol.asyncIterator] = function() {
                  if (createReadableStreamAsyncIterator === void 0) {
                    createReadableStreamAsyncIterator = require2("./internal/streams/async_iterator");
                  }
                  return createReadableStreamAsyncIterator(this);
                };
              }
              Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._readableState.highWaterMark;
                }
              });
              Object.defineProperty(Readable.prototype, "readableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._readableState && this._readableState.buffer;
                }
              });
              Object.defineProperty(Readable.prototype, "readableFlowing", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._readableState.flowing;
                },
                set: function set(state) {
                  if (this._readableState) {
                    this._readableState.flowing = state;
                  }
                }
              });
              Readable._fromList = fromList;
              Object.defineProperty(Readable.prototype, "readableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._readableState.length;
                }
              });
              function fromList(n2, state) {
                if (state.length === 0) return null;
                var ret;
                if (state.objectMode) ret = state.buffer.shift();
                else if (!n2 || n2 >= state.length) {
                  if (state.decoder) ret = state.buffer.join("");
                  else if (state.buffer.length === 1) ret = state.buffer.first();
                  else ret = state.buffer.concat(state.length);
                  state.buffer.clear();
                } else {
                  ret = state.buffer.consume(n2, state.decoder);
                }
                return ret;
              }
              function endReadable(stream) {
                var state = stream._readableState;
                debug("endReadable", state.endEmitted);
                if (!state.endEmitted) {
                  state.ended = true;
                  process.nextTick(endReadableNT, state, stream);
                }
              }
              function endReadableNT(state, stream) {
                debug("endReadableNT", state.endEmitted, state.length);
                if (!state.endEmitted && state.length === 0) {
                  state.endEmitted = true;
                  stream.readable = false;
                  stream.emit("end");
                  if (state.autoDestroy) {
                    var wState = stream._writableState;
                    if (!wState || wState.autoDestroy && wState.finished) {
                      stream.destroy();
                    }
                  }
                }
              }
              if (typeof Symbol === "function") {
                Readable.from = function(iterable, opts) {
                  if (from === void 0) {
                    from = require2("./internal/streams/from");
                  }
                  return from(Readable, iterable, opts);
                };
              }
              function indexOf(xs, x2) {
                for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
                  if (xs[i2] === x2) return i2;
                }
                return -1;
              }
            }).call(this);
          }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../errors": 272, "./_stream_duplex": 273, "./internal/streams/async_iterator": 278, "./internal/streams/buffer_list": 279, "./internal/streams/destroy": 280, "./internal/streams/from": 282, "./internal/streams/state": 284, "./internal/streams/stream": 285, "_process": 263, "buffer": 34, "events": 182, "inherits": 195, "string_decoder/": 288, "util": 32 }], 276: [function(require2, module3, exports3) {
          module3.exports = Transform;
          var _require$codes = require2("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
          var Duplex = require2("./_stream_duplex");
          require2("inherits")(Transform, Duplex);
          function afterTransform(er, data) {
            var ts = this._transformState;
            ts.transforming = false;
            var cb = ts.writecb;
            if (cb === null) {
              return this.emit("error", new ERR_MULTIPLE_CALLBACK());
            }
            ts.writechunk = null;
            ts.writecb = null;
            if (data != null)
              this.push(data);
            cb(er);
            var rs = this._readableState;
            rs.reading = false;
            if (rs.needReadable || rs.length < rs.highWaterMark) {
              this._read(rs.highWaterMark);
            }
          }
          function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options);
            Duplex.call(this, options);
            this._transformState = {
              afterTransform: afterTransform.bind(this),
              needTransform: false,
              transforming: false,
              writecb: null,
              writechunk: null,
              writeencoding: null
            };
            this._readableState.needReadable = true;
            this._readableState.sync = false;
            if (options) {
              if (typeof options.transform === "function") this._transform = options.transform;
              if (typeof options.flush === "function") this._flush = options.flush;
            }
            this.on("prefinish", prefinish);
          }
          function prefinish() {
            var _this = this;
            if (typeof this._flush === "function" && !this._readableState.destroyed) {
              this._flush(function(er, data) {
                done(_this, er, data);
              });
            } else {
              done(this, null, null);
            }
          }
          Transform.prototype.push = function(chunk, encoding) {
            this._transformState.needTransform = false;
            return Duplex.prototype.push.call(this, chunk, encoding);
          };
          Transform.prototype._transform = function(chunk, encoding, cb) {
            cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
          };
          Transform.prototype._write = function(chunk, encoding, cb) {
            var ts = this._transformState;
            ts.writecb = cb;
            ts.writechunk = chunk;
            ts.writeencoding = encoding;
            if (!ts.transforming) {
              var rs = this._readableState;
              if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
            }
          };
          Transform.prototype._read = function(n2) {
            var ts = this._transformState;
            if (ts.writechunk !== null && !ts.transforming) {
              ts.transforming = true;
              this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
            } else {
              ts.needTransform = true;
            }
          };
          Transform.prototype._destroy = function(err, cb) {
            Duplex.prototype._destroy.call(this, err, function(err2) {
              cb(err2);
            });
          };
          function done(stream, er, data) {
            if (er) return stream.emit("error", er);
            if (data != null)
              stream.push(data);
            if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
            if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
            return stream.push(null);
          }
        }, { "../errors": 272, "./_stream_duplex": 273, "inherits": 195 }], 277: [function(require2, module3, exports3) {
          (function(process, global2) {
            (function() {
              module3.exports = Writable;
              function CorkedRequest(state) {
                var _this = this;
                this.next = null;
                this.entry = null;
                this.finish = function() {
                  onCorkedFinish(_this, state);
                };
              }
              var Duplex;
              Writable.WritableState = WritableState;
              var internalUtil = {
                deprecate: require2("util-deprecate")
              };
              var Stream = require2("./internal/streams/stream");
              var Buffer2 = require2("buffer").Buffer;
              var OurUint8Array = global2.Uint8Array || function() {
              };
              function _uint8ArrayToBuffer(chunk) {
                return Buffer2.from(chunk);
              }
              function _isUint8Array(obj) {
                return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
              }
              var destroyImpl = require2("./internal/streams/destroy");
              var _require = require2("./internal/streams/state"), getHighWaterMark = _require.getHighWaterMark;
              var _require$codes = require2("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
              var errorOrDestroy = destroyImpl.errorOrDestroy;
              require2("inherits")(Writable, Stream);
              function nop() {
              }
              function WritableState(options, stream, isDuplex) {
                Duplex = Duplex || require2("./_stream_duplex");
                options = options || {};
                if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
                this.objectMode = !!options.objectMode;
                if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
                this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
                this.finalCalled = false;
                this.needDrain = false;
                this.ending = false;
                this.ended = false;
                this.finished = false;
                this.destroyed = false;
                var noDecode = options.decodeStrings === false;
                this.decodeStrings = !noDecode;
                this.defaultEncoding = options.defaultEncoding || "utf8";
                this.length = 0;
                this.writing = false;
                this.corked = 0;
                this.sync = true;
                this.bufferProcessing = false;
                this.onwrite = function(er) {
                  onwrite(stream, er);
                };
                this.writecb = null;
                this.writelen = 0;
                this.bufferedRequest = null;
                this.lastBufferedRequest = null;
                this.pendingcb = 0;
                this.prefinished = false;
                this.errorEmitted = false;
                this.emitClose = options.emitClose !== false;
                this.autoDestroy = !!options.autoDestroy;
                this.bufferedRequestCount = 0;
                this.corkedRequestsFree = new CorkedRequest(this);
              }
              WritableState.prototype.getBuffer = function getBuffer() {
                var current = this.bufferedRequest;
                var out = [];
                while (current) {
                  out.push(current);
                  current = current.next;
                }
                return out;
              };
              (function() {
                try {
                  Object.defineProperty(WritableState.prototype, "buffer", {
                    get: internalUtil.deprecate(function writableStateBufferGetter() {
                      return this.getBuffer();
                    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                  });
                } catch (_2) {
                }
              })();
              var realHasInstance;
              if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
                realHasInstance = Function.prototype[Symbol.hasInstance];
                Object.defineProperty(Writable, Symbol.hasInstance, {
                  value: function value(object) {
                    if (realHasInstance.call(this, object)) return true;
                    if (this !== Writable) return false;
                    return object && object._writableState instanceof WritableState;
                  }
                });
              } else {
                realHasInstance = function realHasInstance2(object) {
                  return object instanceof this;
                };
              }
              function Writable(options) {
                Duplex = Duplex || require2("./_stream_duplex");
                var isDuplex = this instanceof Duplex;
                if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
                this._writableState = new WritableState(options, this, isDuplex);
                this.writable = true;
                if (options) {
                  if (typeof options.write === "function") this._write = options.write;
                  if (typeof options.writev === "function") this._writev = options.writev;
                  if (typeof options.destroy === "function") this._destroy = options.destroy;
                  if (typeof options.final === "function") this._final = options.final;
                }
                Stream.call(this);
              }
              Writable.prototype.pipe = function() {
                errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
              };
              function writeAfterEnd(stream, cb) {
                var er = new ERR_STREAM_WRITE_AFTER_END();
                errorOrDestroy(stream, er);
                process.nextTick(cb, er);
              }
              function validChunk(stream, state, chunk, cb) {
                var er;
                if (chunk === null) {
                  er = new ERR_STREAM_NULL_VALUES();
                } else if (typeof chunk !== "string" && !state.objectMode) {
                  er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
                }
                if (er) {
                  errorOrDestroy(stream, er);
                  process.nextTick(cb, er);
                  return false;
                }
                return true;
              }
              Writable.prototype.write = function(chunk, encoding, cb) {
                var state = this._writableState;
                var ret = false;
                var isBuf = !state.objectMode && _isUint8Array(chunk);
                if (isBuf && !Buffer2.isBuffer(chunk)) {
                  chunk = _uint8ArrayToBuffer(chunk);
                }
                if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (isBuf) encoding = "buffer";
                else if (!encoding) encoding = state.defaultEncoding;
                if (typeof cb !== "function") cb = nop;
                if (state.ending) writeAfterEnd(this, cb);
                else if (isBuf || validChunk(this, state, chunk, cb)) {
                  state.pendingcb++;
                  ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
                }
                return ret;
              };
              Writable.prototype.cork = function() {
                this._writableState.corked++;
              };
              Writable.prototype.uncork = function() {
                var state = this._writableState;
                if (state.corked) {
                  state.corked--;
                  if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
                }
              };
              Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                if (typeof encoding === "string") encoding = encoding.toLowerCase();
                if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
                this._writableState.defaultEncoding = encoding;
                return this;
              };
              Object.defineProperty(Writable.prototype, "writableBuffer", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._writableState && this._writableState.getBuffer();
                }
              });
              function decodeChunk(state, chunk, encoding) {
                if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
                  chunk = Buffer2.from(chunk, encoding);
                }
                return chunk;
              }
              Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._writableState.highWaterMark;
                }
              });
              function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                if (!isBuf) {
                  var newChunk = decodeChunk(state, chunk, encoding);
                  if (chunk !== newChunk) {
                    isBuf = true;
                    encoding = "buffer";
                    chunk = newChunk;
                  }
                }
                var len = state.objectMode ? 1 : chunk.length;
                state.length += len;
                var ret = state.length < state.highWaterMark;
                if (!ret) state.needDrain = true;
                if (state.writing || state.corked) {
                  var last = state.lastBufferedRequest;
                  state.lastBufferedRequest = {
                    chunk,
                    encoding,
                    isBuf,
                    callback: cb,
                    next: null
                  };
                  if (last) {
                    last.next = state.lastBufferedRequest;
                  } else {
                    state.bufferedRequest = state.lastBufferedRequest;
                  }
                  state.bufferedRequestCount += 1;
                } else {
                  doWrite(stream, state, false, len, chunk, encoding, cb);
                }
                return ret;
              }
              function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len;
                state.writecb = cb;
                state.writing = true;
                state.sync = true;
                if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
                else if (writev) stream._writev(chunk, state.onwrite);
                else stream._write(chunk, encoding, state.onwrite);
                state.sync = false;
              }
              function onwriteError(stream, state, sync2, er, cb) {
                --state.pendingcb;
                if (sync2) {
                  process.nextTick(cb, er);
                  process.nextTick(finishMaybe, stream, state);
                  stream._writableState.errorEmitted = true;
                  errorOrDestroy(stream, er);
                } else {
                  cb(er);
                  stream._writableState.errorEmitted = true;
                  errorOrDestroy(stream, er);
                  finishMaybe(stream, state);
                }
              }
              function onwriteStateUpdate(state) {
                state.writing = false;
                state.writecb = null;
                state.length -= state.writelen;
                state.writelen = 0;
              }
              function onwrite(stream, er) {
                var state = stream._writableState;
                var sync2 = state.sync;
                var cb = state.writecb;
                if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
                onwriteStateUpdate(state);
                if (er) onwriteError(stream, state, sync2, er, cb);
                else {
                  var finished = needFinish(state) || stream.destroyed;
                  if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                    clearBuffer(stream, state);
                  }
                  if (sync2) {
                    process.nextTick(afterWrite, stream, state, finished, cb);
                  } else {
                    afterWrite(stream, state, finished, cb);
                  }
                }
              }
              function afterWrite(stream, state, finished, cb) {
                if (!finished) onwriteDrain(stream, state);
                state.pendingcb--;
                cb();
                finishMaybe(stream, state);
              }
              function onwriteDrain(stream, state) {
                if (state.length === 0 && state.needDrain) {
                  state.needDrain = false;
                  stream.emit("drain");
                }
              }
              function clearBuffer(stream, state) {
                state.bufferProcessing = true;
                var entry = state.bufferedRequest;
                if (stream._writev && entry && entry.next) {
                  var l2 = state.bufferedRequestCount;
                  var buffer = new Array(l2);
                  var holder = state.corkedRequestsFree;
                  holder.entry = entry;
                  var count = 0;
                  var allBuffers = true;
                  while (entry) {
                    buffer[count] = entry;
                    if (!entry.isBuf) allBuffers = false;
                    entry = entry.next;
                    count += 1;
                  }
                  buffer.allBuffers = allBuffers;
                  doWrite(stream, state, true, state.length, buffer, "", holder.finish);
                  state.pendingcb++;
                  state.lastBufferedRequest = null;
                  if (holder.next) {
                    state.corkedRequestsFree = holder.next;
                    holder.next = null;
                  } else {
                    state.corkedRequestsFree = new CorkedRequest(state);
                  }
                  state.bufferedRequestCount = 0;
                } else {
                  while (entry) {
                    var chunk = entry.chunk;
                    var encoding = entry.encoding;
                    var cb = entry.callback;
                    var len = state.objectMode ? 1 : chunk.length;
                    doWrite(stream, state, false, len, chunk, encoding, cb);
                    entry = entry.next;
                    state.bufferedRequestCount--;
                    if (state.writing) {
                      break;
                    }
                  }
                  if (entry === null) state.lastBufferedRequest = null;
                }
                state.bufferedRequest = entry;
                state.bufferProcessing = false;
              }
              Writable.prototype._write = function(chunk, encoding, cb) {
                cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
              };
              Writable.prototype._writev = null;
              Writable.prototype.end = function(chunk, encoding, cb) {
                var state = this._writableState;
                if (typeof chunk === "function") {
                  cb = chunk;
                  chunk = null;
                  encoding = null;
                } else if (typeof encoding === "function") {
                  cb = encoding;
                  encoding = null;
                }
                if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
                if (state.corked) {
                  state.corked = 1;
                  this.uncork();
                }
                if (!state.ending) endWritable(this, state, cb);
                return this;
              };
              Object.defineProperty(Writable.prototype, "writableLength", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  return this._writableState.length;
                }
              });
              function needFinish(state) {
                return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
              }
              function callFinal(stream, state) {
                stream._final(function(err) {
                  state.pendingcb--;
                  if (err) {
                    errorOrDestroy(stream, err);
                  }
                  state.prefinished = true;
                  stream.emit("prefinish");
                  finishMaybe(stream, state);
                });
              }
              function prefinish(stream, state) {
                if (!state.prefinished && !state.finalCalled) {
                  if (typeof stream._final === "function" && !state.destroyed) {
                    state.pendingcb++;
                    state.finalCalled = true;
                    process.nextTick(callFinal, stream, state);
                  } else {
                    state.prefinished = true;
                    stream.emit("prefinish");
                  }
                }
              }
              function finishMaybe(stream, state) {
                var need = needFinish(state);
                if (need) {
                  prefinish(stream, state);
                  if (state.pendingcb === 0) {
                    state.finished = true;
                    stream.emit("finish");
                    if (state.autoDestroy) {
                      var rState = stream._readableState;
                      if (!rState || rState.autoDestroy && rState.endEmitted) {
                        stream.destroy();
                      }
                    }
                  }
                }
                return need;
              }
              function endWritable(stream, state, cb) {
                state.ending = true;
                finishMaybe(stream, state);
                if (cb) {
                  if (state.finished) process.nextTick(cb);
                  else stream.once("finish", cb);
                }
                state.ended = true;
                stream.writable = false;
              }
              function onCorkedFinish(corkReq, state, err) {
                var entry = corkReq.entry;
                corkReq.entry = null;
                while (entry) {
                  var cb = entry.callback;
                  state.pendingcb--;
                  cb(err);
                  entry = entry.next;
                }
                state.corkedRequestsFree.next = corkReq;
              }
              Object.defineProperty(Writable.prototype, "destroyed", {
                // making it explicit this property is not enumerable
                // because otherwise some prototype manipulation in
                // userland will fail
                enumerable: false,
                get: function get2() {
                  if (this._writableState === void 0) {
                    return false;
                  }
                  return this._writableState.destroyed;
                },
                set: function set(value) {
                  if (!this._writableState) {
                    return;
                  }
                  this._writableState.destroyed = value;
                }
              });
              Writable.prototype.destroy = destroyImpl.destroy;
              Writable.prototype._undestroy = destroyImpl.undestroy;
              Writable.prototype._destroy = function(err, cb) {
                cb(err);
              };
            }).call(this);
          }).call(this, require2("_process"), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "../errors": 272, "./_stream_duplex": 273, "./internal/streams/destroy": 280, "./internal/streams/state": 284, "./internal/streams/stream": 285, "_process": 263, "buffer": 34, "inherits": 195, "util-deprecate": 305 }], 278: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var _Object$setPrototypeO;
              function _defineProperty(obj, key, value) {
                if (key in obj) {
                  Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
                } else {
                  obj[key] = value;
                }
                return obj;
              }
              var finished = require2("./end-of-stream");
              var kLastResolve = Symbol("lastResolve");
              var kLastReject = Symbol("lastReject");
              var kError = Symbol("error");
              var kEnded = Symbol("ended");
              var kLastPromise = Symbol("lastPromise");
              var kHandlePromise = Symbol("handlePromise");
              var kStream = Symbol("stream");
              function createIterResult(value, done) {
                return {
                  value,
                  done
                };
              }
              function readAndResolve(iter) {
                var resolve = iter[kLastResolve];
                if (resolve !== null) {
                  var data = iter[kStream].read();
                  if (data !== null) {
                    iter[kLastPromise] = null;
                    iter[kLastResolve] = null;
                    iter[kLastReject] = null;
                    resolve(createIterResult(data, false));
                  }
                }
              }
              function onReadable(iter) {
                process.nextTick(readAndResolve, iter);
              }
              function wrapForNext(lastPromise, iter) {
                return function(resolve, reject) {
                  lastPromise.then(function() {
                    if (iter[kEnded]) {
                      resolve(createIterResult(void 0, true));
                      return;
                    }
                    iter[kHandlePromise](resolve, reject);
                  }, reject);
                };
              }
              var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
              });
              var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
                get stream() {
                  return this[kStream];
                },
                next: function next() {
                  var _this = this;
                  var error = this[kError];
                  if (error !== null) {
                    return Promise.reject(error);
                  }
                  if (this[kEnded]) {
                    return Promise.resolve(createIterResult(void 0, true));
                  }
                  if (this[kStream].destroyed) {
                    return new Promise(function(resolve, reject) {
                      process.nextTick(function() {
                        if (_this[kError]) {
                          reject(_this[kError]);
                        } else {
                          resolve(createIterResult(void 0, true));
                        }
                      });
                    });
                  }
                  var lastPromise = this[kLastPromise];
                  var promise;
                  if (lastPromise) {
                    promise = new Promise(wrapForNext(lastPromise, this));
                  } else {
                    var data = this[kStream].read();
                    if (data !== null) {
                      return Promise.resolve(createIterResult(data, false));
                    }
                    promise = new Promise(this[kHandlePromise]);
                  }
                  this[kLastPromise] = promise;
                  return promise;
                }
              }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
                return this;
              }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
                var _this2 = this;
                return new Promise(function(resolve, reject) {
                  _this2[kStream].destroy(null, function(err) {
                    if (err) {
                      reject(err);
                      return;
                    }
                    resolve(createIterResult(void 0, true));
                  });
                });
              }), _Object$setPrototypeO), AsyncIteratorPrototype);
              var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
                var _Object$create;
                var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
                  value: stream,
                  writable: true
                }), _defineProperty(_Object$create, kLastResolve, {
                  value: null,
                  writable: true
                }), _defineProperty(_Object$create, kLastReject, {
                  value: null,
                  writable: true
                }), _defineProperty(_Object$create, kError, {
                  value: null,
                  writable: true
                }), _defineProperty(_Object$create, kEnded, {
                  value: stream._readableState.endEmitted,
                  writable: true
                }), _defineProperty(_Object$create, kHandlePromise, {
                  value: function value(resolve, reject) {
                    var data = iterator[kStream].read();
                    if (data) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      resolve(createIterResult(data, false));
                    } else {
                      iterator[kLastResolve] = resolve;
                      iterator[kLastReject] = reject;
                    }
                  },
                  writable: true
                }), _Object$create));
                iterator[kLastPromise] = null;
                finished(stream, function(err) {
                  if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                    var reject = iterator[kLastReject];
                    if (reject !== null) {
                      iterator[kLastPromise] = null;
                      iterator[kLastResolve] = null;
                      iterator[kLastReject] = null;
                      reject(err);
                    }
                    iterator[kError] = err;
                    return;
                  }
                  var resolve = iterator[kLastResolve];
                  if (resolve !== null) {
                    iterator[kLastPromise] = null;
                    iterator[kLastResolve] = null;
                    iterator[kLastReject] = null;
                    resolve(createIterResult(void 0, true));
                  }
                  iterator[kEnded] = true;
                });
                stream.on("readable", onReadable.bind(null, iterator));
                return iterator;
              };
              module3.exports = createReadableStreamAsyncIterator;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./end-of-stream": 281, "_process": 263 }], 279: [function(require2, module3, exports3) {
          function ownKeys(object, enumerableOnly) {
            var keys = Object.keys(object);
            if (Object.getOwnPropertySymbols) {
              var symbols = Object.getOwnPropertySymbols(object);
              if (enumerableOnly) symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
              });
              keys.push.apply(keys, symbols);
            }
            return keys;
          }
          function _objectSpread(target) {
            for (var i2 = 1; i2 < arguments.length; i2++) {
              var source = arguments[i2] != null ? arguments[i2] : {};
              if (i2 % 2) {
                ownKeys(Object(source), true).forEach(function(key) {
                  _defineProperty(target, key, source[key]);
                });
              } else if (Object.getOwnPropertyDescriptors) {
                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
              } else {
                ownKeys(Object(source)).forEach(function(key) {
                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
              }
            }
            return target;
          }
          function _defineProperty(obj, key, value) {
            if (key in obj) {
              Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
            } else {
              obj[key] = value;
            }
            return obj;
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps) _defineProperties(Constructor.prototype, protoProps);
            return Constructor;
          }
          var _require = require2("buffer"), Buffer2 = _require.Buffer;
          var _require2 = require2("util"), inspect = _require2.inspect;
          var custom = inspect && inspect.custom || "inspect";
          function copyBuffer(src, target, offset) {
            Buffer2.prototype.copy.call(src, target, offset);
          }
          module3.exports = /* @__PURE__ */ function() {
            function BufferList() {
              _classCallCheck(this, BufferList);
              this.head = null;
              this.tail = null;
              this.length = 0;
            }
            _createClass(BufferList, [{
              key: "push",
              value: function push(v2) {
                var entry = {
                  data: v2,
                  next: null
                };
                if (this.length > 0) this.tail.next = entry;
                else this.head = entry;
                this.tail = entry;
                ++this.length;
              }
            }, {
              key: "unshift",
              value: function unshift(v2) {
                var entry = {
                  data: v2,
                  next: this.head
                };
                if (this.length === 0) this.tail = entry;
                this.head = entry;
                ++this.length;
              }
            }, {
              key: "shift",
              value: function shift() {
                if (this.length === 0) return;
                var ret = this.head.data;
                if (this.length === 1) this.head = this.tail = null;
                else this.head = this.head.next;
                --this.length;
                return ret;
              }
            }, {
              key: "clear",
              value: function clear() {
                this.head = this.tail = null;
                this.length = 0;
              }
            }, {
              key: "join",
              value: function join(s2) {
                if (this.length === 0) return "";
                var p2 = this.head;
                var ret = "" + p2.data;
                while (p2 = p2.next) {
                  ret += s2 + p2.data;
                }
                return ret;
              }
            }, {
              key: "concat",
              value: function concat(n2) {
                if (this.length === 0) return Buffer2.alloc(0);
                var ret = Buffer2.allocUnsafe(n2 >>> 0);
                var p2 = this.head;
                var i2 = 0;
                while (p2) {
                  copyBuffer(p2.data, ret, i2);
                  i2 += p2.data.length;
                  p2 = p2.next;
                }
                return ret;
              }
              // Consumes a specified amount of bytes or characters from the buffered data.
            }, {
              key: "consume",
              value: function consume(n2, hasStrings) {
                var ret;
                if (n2 < this.head.data.length) {
                  ret = this.head.data.slice(0, n2);
                  this.head.data = this.head.data.slice(n2);
                } else if (n2 === this.head.data.length) {
                  ret = this.shift();
                } else {
                  ret = hasStrings ? this._getString(n2) : this._getBuffer(n2);
                }
                return ret;
              }
            }, {
              key: "first",
              value: function first() {
                return this.head.data;
              }
              // Consumes a specified amount of characters from the buffered data.
            }, {
              key: "_getString",
              value: function _getString(n2) {
                var p2 = this.head;
                var c2 = 1;
                var ret = p2.data;
                n2 -= ret.length;
                while (p2 = p2.next) {
                  var str = p2.data;
                  var nb = n2 > str.length ? str.length : n2;
                  if (nb === str.length) ret += str;
                  else ret += str.slice(0, n2);
                  n2 -= nb;
                  if (n2 === 0) {
                    if (nb === str.length) {
                      ++c2;
                      if (p2.next) this.head = p2.next;
                      else this.head = this.tail = null;
                    } else {
                      this.head = p2;
                      p2.data = str.slice(nb);
                    }
                    break;
                  }
                  ++c2;
                }
                this.length -= c2;
                return ret;
              }
              // Consumes a specified amount of bytes from the buffered data.
            }, {
              key: "_getBuffer",
              value: function _getBuffer(n2) {
                var ret = Buffer2.allocUnsafe(n2);
                var p2 = this.head;
                var c2 = 1;
                p2.data.copy(ret);
                n2 -= p2.data.length;
                while (p2 = p2.next) {
                  var buf = p2.data;
                  var nb = n2 > buf.length ? buf.length : n2;
                  buf.copy(ret, ret.length - n2, 0, nb);
                  n2 -= nb;
                  if (n2 === 0) {
                    if (nb === buf.length) {
                      ++c2;
                      if (p2.next) this.head = p2.next;
                      else this.head = this.tail = null;
                    } else {
                      this.head = p2;
                      p2.data = buf.slice(nb);
                    }
                    break;
                  }
                  ++c2;
                }
                this.length -= c2;
                return ret;
              }
              // Make sure the linked list only shows the minimal necessary information.
            }, {
              key: custom,
              value: function value(_2, options) {
                return inspect(this, _objectSpread({}, options, {
                  // Only inspect one level.
                  depth: 0,
                  // It should not recurse.
                  customInspect: false
                }));
              }
            }]);
            return BufferList;
          }();
        }, { "buffer": 34, "util": 32 }], 280: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              function destroy(err, cb) {
                var _this = this;
                var readableDestroyed = this._readableState && this._readableState.destroyed;
                var writableDestroyed = this._writableState && this._writableState.destroyed;
                if (readableDestroyed || writableDestroyed) {
                  if (cb) {
                    cb(err);
                  } else if (err) {
                    if (!this._writableState) {
                      process.nextTick(emitErrorNT, this, err);
                    } else if (!this._writableState.errorEmitted) {
                      this._writableState.errorEmitted = true;
                      process.nextTick(emitErrorNT, this, err);
                    }
                  }
                  return this;
                }
                if (this._readableState) {
                  this._readableState.destroyed = true;
                }
                if (this._writableState) {
                  this._writableState.destroyed = true;
                }
                this._destroy(err || null, function(err2) {
                  if (!cb && err2) {
                    if (!_this._writableState) {
                      process.nextTick(emitErrorAndCloseNT, _this, err2);
                    } else if (!_this._writableState.errorEmitted) {
                      _this._writableState.errorEmitted = true;
                      process.nextTick(emitErrorAndCloseNT, _this, err2);
                    } else {
                      process.nextTick(emitCloseNT, _this);
                    }
                  } else if (cb) {
                    process.nextTick(emitCloseNT, _this);
                    cb(err2);
                  } else {
                    process.nextTick(emitCloseNT, _this);
                  }
                });
                return this;
              }
              function emitErrorAndCloseNT(self2, err) {
                emitErrorNT(self2, err);
                emitCloseNT(self2);
              }
              function emitCloseNT(self2) {
                if (self2._writableState && !self2._writableState.emitClose) return;
                if (self2._readableState && !self2._readableState.emitClose) return;
                self2.emit("close");
              }
              function undestroy() {
                if (this._readableState) {
                  this._readableState.destroyed = false;
                  this._readableState.reading = false;
                  this._readableState.ended = false;
                  this._readableState.endEmitted = false;
                }
                if (this._writableState) {
                  this._writableState.destroyed = false;
                  this._writableState.ended = false;
                  this._writableState.ending = false;
                  this._writableState.finalCalled = false;
                  this._writableState.prefinished = false;
                  this._writableState.finished = false;
                  this._writableState.errorEmitted = false;
                }
              }
              function emitErrorNT(self2, err) {
                self2.emit("error", err);
              }
              function errorOrDestroy(stream, err) {
                var rState = stream._readableState;
                var wState = stream._writableState;
                if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
                else stream.emit("error", err);
              }
              module3.exports = {
                destroy,
                undestroy,
                errorOrDestroy
              };
            }).call(this);
          }).call(this, require2("_process"));
        }, { "_process": 263 }], 281: [function(require2, module3, exports3) {
          var ERR_STREAM_PREMATURE_CLOSE = require2("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
          function once(callback) {
            var called = false;
            return function() {
              if (called) return;
              called = true;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              callback.apply(this, args);
            };
          }
          function noop2() {
          }
          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          }
          function eos(stream, opts, callback) {
            if (typeof opts === "function") return eos(stream, null, opts);
            if (!opts) opts = {};
            callback = once(callback || noop2);
            var readable = opts.readable || opts.readable !== false && stream.readable;
            var writable = opts.writable || opts.writable !== false && stream.writable;
            var onlegacyfinish = function onlegacyfinish2() {
              if (!stream.writable) onfinish();
            };
            var writableEnded = stream._writableState && stream._writableState.finished;
            var onfinish = function onfinish2() {
              writable = false;
              writableEnded = true;
              if (!readable) callback.call(stream);
            };
            var readableEnded = stream._readableState && stream._readableState.endEmitted;
            var onend = function onend2() {
              readable = false;
              readableEnded = true;
              if (!writable) callback.call(stream);
            };
            var onerror = function onerror2(err) {
              callback.call(stream, err);
            };
            var onclose = function onclose2() {
              var err;
              if (readable && !readableEnded) {
                if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
                return callback.call(stream, err);
              }
              if (writable && !writableEnded) {
                if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
                return callback.call(stream, err);
              }
            };
            var onrequest = function onrequest2() {
              stream.req.on("finish", onfinish);
            };
            if (isRequest(stream)) {
              stream.on("complete", onfinish);
              stream.on("abort", onclose);
              if (stream.req) onrequest();
              else stream.on("request", onrequest);
            } else if (writable && !stream._writableState) {
              stream.on("end", onlegacyfinish);
              stream.on("close", onlegacyfinish);
            }
            stream.on("end", onend);
            stream.on("finish", onfinish);
            if (opts.error !== false) stream.on("error", onerror);
            stream.on("close", onclose);
            return function() {
              stream.removeListener("complete", onfinish);
              stream.removeListener("abort", onclose);
              stream.removeListener("request", onrequest);
              if (stream.req) stream.req.removeListener("finish", onfinish);
              stream.removeListener("end", onlegacyfinish);
              stream.removeListener("close", onlegacyfinish);
              stream.removeListener("finish", onfinish);
              stream.removeListener("end", onend);
              stream.removeListener("error", onerror);
              stream.removeListener("close", onclose);
            };
          }
          module3.exports = eos;
        }, { "../../../errors": 272 }], 282: [function(require2, module3, exports3) {
          module3.exports = function() {
            throw new Error("Readable.from is not available in the browser");
          };
        }, {}], 283: [function(require2, module3, exports3) {
          var eos;
          function once(callback) {
            var called = false;
            return function() {
              if (called) return;
              called = true;
              callback.apply(void 0, arguments);
            };
          }
          var _require$codes = require2("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
          function noop2(err) {
            if (err) throw err;
          }
          function isRequest(stream) {
            return stream.setHeader && typeof stream.abort === "function";
          }
          function destroyer(stream, reading, writing, callback) {
            callback = once(callback);
            var closed = false;
            stream.on("close", function() {
              closed = true;
            });
            if (eos === void 0) eos = require2("./end-of-stream");
            eos(stream, {
              readable: reading,
              writable: writing
            }, function(err) {
              if (err) return callback(err);
              closed = true;
              callback();
            });
            var destroyed = false;
            return function(err) {
              if (closed) return;
              if (destroyed) return;
              destroyed = true;
              if (isRequest(stream)) return stream.abort();
              if (typeof stream.destroy === "function") return stream.destroy();
              callback(err || new ERR_STREAM_DESTROYED("pipe"));
            };
          }
          function call(fn) {
            fn();
          }
          function pipe(from, to) {
            return from.pipe(to);
          }
          function popCallback(streams) {
            if (!streams.length) return noop2;
            if (typeof streams[streams.length - 1] !== "function") return noop2;
            return streams.pop();
          }
          function pipeline() {
            for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
              streams[_key] = arguments[_key];
            }
            var callback = popCallback(streams);
            if (Array.isArray(streams[0])) streams = streams[0];
            if (streams.length < 2) {
              throw new ERR_MISSING_ARGS("streams");
            }
            var error;
            var destroys = streams.map(function(stream, i2) {
              var reading = i2 < streams.length - 1;
              var writing = i2 > 0;
              return destroyer(stream, reading, writing, function(err) {
                if (!error) error = err;
                if (err) destroys.forEach(call);
                if (reading) return;
                destroys.forEach(call);
                callback(error);
              });
            });
            return streams.reduce(pipe);
          }
          module3.exports = pipeline;
        }, { "../../../errors": 272, "./end-of-stream": 281 }], 284: [function(require2, module3, exports3) {
          var ERR_INVALID_OPT_VALUE = require2("../../../errors").codes.ERR_INVALID_OPT_VALUE;
          function highWaterMarkFrom(options, isDuplex, duplexKey) {
            return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
          }
          function getHighWaterMark(state, options, duplexKey, isDuplex) {
            var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
            if (hwm != null) {
              if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
                var name = isDuplex ? duplexKey : "highWaterMark";
                throw new ERR_INVALID_OPT_VALUE(name, hwm);
              }
              return Math.floor(hwm);
            }
            return state.objectMode ? 16 : 16 * 1024;
          }
          module3.exports = {
            getHighWaterMark
          };
        }, { "../../../errors": 272 }], 285: [function(require2, module3, exports3) {
          module3.exports = require2("events").EventEmitter;
        }, { "events": 182 }], 286: [function(require2, module3, exports3) {
          exports3 = module3.exports = require2("./lib/_stream_readable.js");
          exports3.Stream = exports3;
          exports3.Readable = exports3;
          exports3.Writable = require2("./lib/_stream_writable.js");
          exports3.Duplex = require2("./lib/_stream_duplex.js");
          exports3.Transform = require2("./lib/_stream_transform.js");
          exports3.PassThrough = require2("./lib/_stream_passthrough.js");
          exports3.finished = require2("./lib/internal/streams/end-of-stream.js");
          exports3.pipeline = require2("./lib/internal/streams/pipeline.js");
        }, { "./lib/_stream_duplex.js": 273, "./lib/_stream_passthrough.js": 274, "./lib/_stream_readable.js": 275, "./lib/_stream_transform.js": 276, "./lib/_stream_writable.js": 277, "./lib/internal/streams/end-of-stream.js": 281, "./lib/internal/streams/pipeline.js": 283 }], 287: [function(require2, module3, exports3) {
          var buffer = require2("buffer");
          var Buffer2 = buffer.Buffer;
          function copyProps(src, dst) {
            for (var key in src) {
              dst[key] = src[key];
            }
          }
          if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
            module3.exports = buffer;
          } else {
            copyProps(buffer, exports3);
            exports3.Buffer = SafeBuffer;
          }
          function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer2(arg, encodingOrOffset, length);
          }
          SafeBuffer.prototype = Object.create(Buffer2.prototype);
          copyProps(Buffer2, SafeBuffer);
          SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if (typeof arg === "number") {
              throw new TypeError("Argument must not be a number");
            }
            return Buffer2(arg, encodingOrOffset, length);
          };
          SafeBuffer.alloc = function(size, fill, encoding) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }
            var buf = Buffer2(size);
            if (fill !== void 0) {
              if (typeof encoding === "string") {
                buf.fill(fill, encoding);
              } else {
                buf.fill(fill);
              }
            } else {
              buf.fill(0);
            }
            return buf;
          };
          SafeBuffer.allocUnsafe = function(size) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }
            return Buffer2(size);
          };
          SafeBuffer.allocUnsafeSlow = function(size) {
            if (typeof size !== "number") {
              throw new TypeError("Argument must be a number");
            }
            return buffer.SlowBuffer(size);
          };
        }, { "buffer": 34 }], 288: [function(require2, module3, exports3) {
          var Buffer2 = require2("safe-buffer").Buffer;
          var isEncoding = Buffer2.isEncoding || function(encoding) {
            encoding = "" + encoding;
            switch (encoding && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return true;
              default:
                return false;
            }
          };
          function _normalizeEncoding(enc) {
            if (!enc) return "utf8";
            var retried;
            while (true) {
              switch (enc) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return enc;
                default:
                  if (retried) return;
                  enc = ("" + enc).toLowerCase();
                  retried = true;
              }
            }
          }
          function normalizeEncoding(enc) {
            var nenc = _normalizeEncoding(enc);
            if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
            return nenc || enc;
          }
          exports3.StringDecoder = StringDecoder;
          function StringDecoder(encoding) {
            this.encoding = normalizeEncoding(encoding);
            var nb;
            switch (this.encoding) {
              case "utf16le":
                this.text = utf16Text;
                this.end = utf16End;
                nb = 4;
                break;
              case "utf8":
                this.fillLast = utf8FillLast;
                nb = 4;
                break;
              case "base64":
                this.text = base64Text;
                this.end = base64End;
                nb = 3;
                break;
              default:
                this.write = simpleWrite;
                this.end = simpleEnd;
                return;
            }
            this.lastNeed = 0;
            this.lastTotal = 0;
            this.lastChar = Buffer2.allocUnsafe(nb);
          }
          StringDecoder.prototype.write = function(buf) {
            if (buf.length === 0) return "";
            var r2;
            var i2;
            if (this.lastNeed) {
              r2 = this.fillLast(buf);
              if (r2 === void 0) return "";
              i2 = this.lastNeed;
              this.lastNeed = 0;
            } else {
              i2 = 0;
            }
            if (i2 < buf.length) return r2 ? r2 + this.text(buf, i2) : this.text(buf, i2);
            return r2 || "";
          };
          StringDecoder.prototype.end = utf8End;
          StringDecoder.prototype.text = utf8Text;
          StringDecoder.prototype.fillLast = function(buf) {
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
            this.lastNeed -= buf.length;
          };
          function utf8CheckByte(byte) {
            if (byte <= 127) return 0;
            else if (byte >> 5 === 6) return 2;
            else if (byte >> 4 === 14) return 3;
            else if (byte >> 3 === 30) return 4;
            return byte >> 6 === 2 ? -1 : -2;
          }
          function utf8CheckIncomplete(self2, buf, i2) {
            var j2 = buf.length - 1;
            if (j2 < i2) return 0;
            var nb = utf8CheckByte(buf[j2]);
            if (nb >= 0) {
              if (nb > 0) self2.lastNeed = nb - 1;
              return nb;
            }
            if (--j2 < i2 || nb === -2) return 0;
            nb = utf8CheckByte(buf[j2]);
            if (nb >= 0) {
              if (nb > 0) self2.lastNeed = nb - 2;
              return nb;
            }
            if (--j2 < i2 || nb === -2) return 0;
            nb = utf8CheckByte(buf[j2]);
            if (nb >= 0) {
              if (nb > 0) {
                if (nb === 2) nb = 0;
                else self2.lastNeed = nb - 3;
              }
              return nb;
            }
            return 0;
          }
          function utf8CheckExtraBytes(self2, buf, p2) {
            if ((buf[0] & 192) !== 128) {
              self2.lastNeed = 0;
              return "�";
            }
            if (self2.lastNeed > 1 && buf.length > 1) {
              if ((buf[1] & 192) !== 128) {
                self2.lastNeed = 1;
                return "�";
              }
              if (self2.lastNeed > 2 && buf.length > 2) {
                if ((buf[2] & 192) !== 128) {
                  self2.lastNeed = 2;
                  return "�";
                }
              }
            }
          }
          function utf8FillLast(buf) {
            var p2 = this.lastTotal - this.lastNeed;
            var r2 = utf8CheckExtraBytes(this, buf);
            if (r2 !== void 0) return r2;
            if (this.lastNeed <= buf.length) {
              buf.copy(this.lastChar, p2, 0, this.lastNeed);
              return this.lastChar.toString(this.encoding, 0, this.lastTotal);
            }
            buf.copy(this.lastChar, p2, 0, buf.length);
            this.lastNeed -= buf.length;
          }
          function utf8Text(buf, i2) {
            var total = utf8CheckIncomplete(this, buf, i2);
            if (!this.lastNeed) return buf.toString("utf8", i2);
            this.lastTotal = total;
            var end = buf.length - (total - this.lastNeed);
            buf.copy(this.lastChar, 0, end);
            return buf.toString("utf8", i2, end);
          }
          function utf8End(buf) {
            var r2 = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) return r2 + "�";
            return r2;
          }
          function utf16Text(buf, i2) {
            if ((buf.length - i2) % 2 === 0) {
              var r2 = buf.toString("utf16le", i2);
              if (r2) {
                var c2 = r2.charCodeAt(r2.length - 1);
                if (c2 >= 55296 && c2 <= 56319) {
                  this.lastNeed = 2;
                  this.lastTotal = 4;
                  this.lastChar[0] = buf[buf.length - 2];
                  this.lastChar[1] = buf[buf.length - 1];
                  return r2.slice(0, -1);
                }
              }
              return r2;
            }
            this.lastNeed = 1;
            this.lastTotal = 2;
            this.lastChar[0] = buf[buf.length - 1];
            return buf.toString("utf16le", i2, buf.length - 1);
          }
          function utf16End(buf) {
            var r2 = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) {
              var end = this.lastTotal - this.lastNeed;
              return r2 + this.lastChar.toString("utf16le", 0, end);
            }
            return r2;
          }
          function base64Text(buf, i2) {
            var n2 = (buf.length - i2) % 3;
            if (n2 === 0) return buf.toString("base64", i2);
            this.lastNeed = 3 - n2;
            this.lastTotal = 3;
            if (n2 === 1) {
              this.lastChar[0] = buf[buf.length - 1];
            } else {
              this.lastChar[0] = buf[buf.length - 2];
              this.lastChar[1] = buf[buf.length - 1];
            }
            return buf.toString("base64", i2, buf.length - n2);
          }
          function base64End(buf) {
            var r2 = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
            return r2;
          }
          function simpleWrite(buf) {
            return buf.toString(this.encoding);
          }
          function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : "";
          }
        }, { "safe-buffer": 287 }], 289: [function(require2, module3, exports3) {
          (function(setImmediate, clearImmediate) {
            (function() {
              var nextTick = require2("process/browser.js").nextTick;
              var apply = Function.prototype.apply;
              var slice = Array.prototype.slice;
              var immediateIds = {};
              var nextImmediateId = 0;
              exports3.setTimeout = function() {
                return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
              };
              exports3.setInterval = function() {
                return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
              };
              exports3.clearTimeout = exports3.clearInterval = function(timeout) {
                timeout.close();
              };
              function Timeout(id, clearFn) {
                this._id = id;
                this._clearFn = clearFn;
              }
              Timeout.prototype.unref = Timeout.prototype.ref = function() {
              };
              Timeout.prototype.close = function() {
                this._clearFn.call(window, this._id);
              };
              exports3.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = msecs;
              };
              exports3.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = -1;
              };
              exports3._unrefActive = exports3.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;
                if (msecs >= 0) {
                  item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout)
                      item._onTimeout();
                  }, msecs);
                }
              };
              exports3.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
                var id = nextImmediateId++;
                var args = arguments.length < 2 ? false : slice.call(arguments, 1);
                immediateIds[id] = true;
                nextTick(function onNextTick() {
                  if (immediateIds[id]) {
                    if (args) {
                      fn.apply(null, args);
                    } else {
                      fn.call(null);
                    }
                    exports3.clearImmediate(id);
                  }
                });
                return id;
              };
              exports3.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
                delete immediateIds[id];
              };
            }).call(this);
          }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
        }, { "process/browser.js": 263, "timers": 289 }], 290: [function(require2, module3, exports3) {
          module3.exports = 2147483647;
        }, {}], 291: [function(require2, module3, exports3) {
          var toPosInt = require2("es5-ext/number/to-pos-integer"), maxTimeout = require2("./max-timeout");
          module3.exports = function(value) {
            value = toPosInt(value);
            if (value > maxTimeout) throw new TypeError(value + " exceeds maximum possible timeout");
            return value;
          };
        }, { "./max-timeout": 290, "es5-ext/number/to-pos-integer": 135 }], 292: [function(require2, module3, exports3) {
          var isPrototype = require2("../prototype/is");
          module3.exports = function(value) {
            if (typeof value !== "function") return false;
            if (!hasOwnProperty.call(value, "length")) return false;
            try {
              if (typeof value.length !== "number") return false;
              if (typeof value.call !== "function") return false;
              if (typeof value.apply !== "function") return false;
            } catch (error) {
              return false;
            }
            return !isPrototype(value);
          };
        }, { "../prototype/is": 299 }], 293: [function(require2, module3, exports3) {
          var isValue = require2("../value/is"), isObject2 = require2("../object/is"), stringCoerce = require2("../string/coerce"), toShortString = require2("./to-short-string");
          var resolveMessage = function(message, value) {
            return message.replace("%v", toShortString(value));
          };
          module3.exports = function(value, defaultMessage, inputOptions) {
            if (!isObject2(inputOptions)) throw new TypeError(resolveMessage(defaultMessage, value));
            if (!isValue(value)) {
              if ("default" in inputOptions) return inputOptions["default"];
              if (inputOptions.isOptional) return null;
            }
            var errorMessage = stringCoerce(inputOptions.errorMessage);
            if (!isValue(errorMessage)) errorMessage = defaultMessage;
            throw new TypeError(resolveMessage(errorMessage, value));
          };
        }, { "../object/is": 296, "../string/coerce": 300, "../value/is": 302, "./to-short-string": 295 }], 294: [function(require2, module3, exports3) {
          module3.exports = function(value) {
            try {
              return value.toString();
            } catch (error) {
              try {
                return String(value);
              } catch (error2) {
                return null;
              }
            }
          };
        }, {}], 295: [function(require2, module3, exports3) {
          var safeToString = require2("./safe-to-string");
          var reNewLine = /[\n\r\u2028\u2029]/g;
          module3.exports = function(value) {
            var string = safeToString(value);
            if (string === null) return "<Non-coercible to string value>";
            if (string.length > 100) string = string.slice(0, 99) + "…";
            string = string.replace(reNewLine, function(char) {
              switch (char) {
                case "\n":
                  return "\\n";
                case "\r":
                  return "\\r";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                /* istanbul ignore next */
                default:
                  throw new Error("Unexpected character");
              }
            });
            return string;
          };
        }, { "./safe-to-string": 294 }], 296: [function(require2, module3, exports3) {
          var isValue = require2("../value/is");
          var possibleTypes = {
            "object": true,
            "function": true,
            "undefined": true
            /* document.all */
          };
          module3.exports = function(value) {
            if (!isValue(value)) return false;
            return hasOwnProperty.call(possibleTypes, typeof value);
          };
        }, { "../value/is": 302 }], 297: [function(require2, module3, exports3) {
          var resolveException = require2("../lib/resolve-exception"), is = require2("./is");
          module3.exports = function(value) {
            if (is(value)) return value;
            return resolveException(value, "%v is not a plain function", arguments[1]);
          };
        }, { "../lib/resolve-exception": 293, "./is": 298 }], 298: [function(require2, module3, exports3) {
          var isFunction = require2("../function/is");
          var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;
          module3.exports = function(value) {
            if (!isFunction(value)) return false;
            if (classRe.test(functionToString.call(value))) return false;
            return true;
          };
        }, { "../function/is": 292 }], 299: [function(require2, module3, exports3) {
          var isObject2 = require2("../object/is");
          module3.exports = function(value) {
            if (!isObject2(value)) return false;
            try {
              if (!value.constructor) return false;
              return value.constructor.prototype === value;
            } catch (error) {
              return false;
            }
          };
        }, { "../object/is": 296 }], 300: [function(require2, module3, exports3) {
          var isValue = require2("../value/is"), isObject2 = require2("../object/is");
          var objectToString = Object.prototype.toString;
          module3.exports = function(value) {
            if (!isValue(value)) return null;
            if (isObject2(value)) {
              var valueToString = value.toString;
              if (typeof valueToString !== "function") return null;
              if (valueToString === objectToString) return null;
            }
            try {
              return "" + value;
            } catch (error) {
              return null;
            }
          };
        }, { "../object/is": 296, "../value/is": 302 }], 301: [function(require2, module3, exports3) {
          var resolveException = require2("../lib/resolve-exception"), is = require2("./is");
          module3.exports = function(value) {
            if (is(value)) return value;
            return resolveException(value, "Cannot use %v", arguments[1]);
          };
        }, { "../lib/resolve-exception": 293, "./is": 302 }], 302: [function(require2, module3, exports3) {
          var _undefined = void 0;
          module3.exports = function(value) {
            return value !== _undefined && value !== null;
          };
        }, {}], 303: [function(require2, module3, exports3) {
          var punycode = require2("punycode");
          var util = require2("./util");
          exports3.parse = urlParse;
          exports3.resolve = urlResolve;
          exports3.resolveObject = urlResolveObject;
          exports3.format = urlFormat;
          exports3.Url = Url;
          function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
          }
          var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
            "javascript": true,
            "javascript:": true
          }, hostlessProtocol = {
            "javascript": true,
            "javascript:": true
          }, slashedProtocol = {
            "http": true,
            "https": true,
            "ftp": true,
            "gopher": true,
            "file": true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true
          }, querystring = require2("querystring");
          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url) return url;
            var u2 = new Url();
            u2.parse(url, parseQueryString, slashesDenoteHost);
            return u2;
          }
          Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url)) {
              throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            }
            var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
            uSplit[0] = uSplit[0].replace(slashRegex, "/");
            url = uSplit.join(splitter);
            var rest = url;
            rest = rest.trim();
            if (!slashesDenoteHost && url.split("#").length === 1) {
              var simplePath = simplePathPattern.exec(rest);
              if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                  this.search = simplePath[2];
                  if (parseQueryString) {
                    this.query = querystring.parse(this.search.substr(1));
                  } else {
                    this.query = this.search.substr(1);
                  }
                } else if (parseQueryString) {
                  this.search = "";
                  this.query = {};
                }
                return this;
              }
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
              proto = proto[0];
              var lowerProto = proto.toLowerCase();
              this.protocol = lowerProto;
              rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
              var slashes = rest.substr(0, 2) === "//";
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
              }
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
              var hostEnd = -1;
              for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
                var hec = rest.indexOf(hostEndingChars[i2]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              }
              var auth, atSign;
              if (hostEnd === -1) {
                atSign = rest.lastIndexOf("@");
              } else {
                atSign = rest.lastIndexOf("@", hostEnd);
              }
              if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
              }
              hostEnd = -1;
              for (var i2 = 0; i2 < nonHostChars.length; i2++) {
                var hec = rest.indexOf(nonHostChars[i2]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              }
              if (hostEnd === -1)
                hostEnd = rest.length;
              this.host = rest.slice(0, hostEnd);
              rest = rest.slice(hostEnd);
              this.parseHost();
              this.hostname = this.hostname || "";
              var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
                  var part = hostparts[i2];
                  if (!part) continue;
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = "";
                    for (var j2 = 0, k2 = part.length; j2 < k2; j2++) {
                      if (part.charCodeAt(j2) > 127) {
                        newpart += "x";
                      } else {
                        newpart += part[j2];
                      }
                    }
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i2);
                      var notHost = hostparts.slice(i2 + 1);
                      var bit = part.match(hostnamePartStart);
                      if (bit) {
                        validParts.push(bit[1]);
                        notHost.unshift(bit[2]);
                      }
                      if (notHost.length) {
                        rest = "/" + notHost.join(".") + rest;
                      }
                      this.hostname = validParts.join(".");
                      break;
                    }
                  }
                }
              }
              if (this.hostname.length > hostnameMaxLen) {
                this.hostname = "";
              } else {
                this.hostname = this.hostname.toLowerCase();
              }
              if (!ipv6Hostname) {
                this.hostname = punycode.toASCII(this.hostname);
              }
              var p2 = this.port ? ":" + this.port : "";
              var h2 = this.hostname || "";
              this.host = h2 + p2;
              this.href += this.host;
              if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== "/") {
                  rest = "/" + rest;
                }
              }
            }
            if (!unsafeProtocol[lowerProto]) {
              for (var i2 = 0, l2 = autoEscape.length; i2 < l2; i2++) {
                var ae2 = autoEscape[i2];
                if (rest.indexOf(ae2) === -1)
                  continue;
                var esc = encodeURIComponent(ae2);
                if (esc === ae2) {
                  esc = escape(ae2);
                }
                rest = rest.split(ae2).join(esc);
              }
            }
            var hash = rest.indexOf("#");
            if (hash !== -1) {
              this.hash = rest.substr(hash);
              rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
              this.search = rest.substr(qm);
              this.query = rest.substr(qm + 1);
              if (parseQueryString) {
                this.query = querystring.parse(this.query);
              }
              rest = rest.slice(0, qm);
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            if (rest) this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
              this.pathname = "/";
            }
            if (this.pathname || this.search) {
              var p2 = this.pathname || "";
              var s2 = this.search || "";
              this.path = p2 + s2;
            }
            this.href = this.format();
            return this;
          };
          function urlFormat(obj) {
            if (util.isString(obj)) obj = urlParse(obj);
            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
            return obj.format();
          }
          Url.prototype.format = function() {
            var auth = this.auth || "";
            if (auth) {
              auth = encodeURIComponent(auth);
              auth = auth.replace(/%3A/i, ":");
              auth += "@";
            }
            var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
            if (this.host) {
              host = auth + this.host;
            } else if (this.hostname) {
              host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
              if (this.port) {
                host += ":" + this.port;
              }
            }
            if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
              query = querystring.stringify(this.query);
            }
            var search = this.search || query && "?" + query || "";
            if (protocol && protocol.substr(-1) !== ":") protocol += ":";
            if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
              host = "//" + (host || "");
              if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
            } else if (!host) {
              host = "";
            }
            if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
            if (search && search.charAt(0) !== "?") search = "?" + search;
            pathname = pathname.replace(/[?#]/g, function(match) {
              return encodeURIComponent(match);
            });
            search = search.replace("#", "%23");
            return protocol + host + pathname + search + hash;
          };
          function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
          }
          Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
          };
          function urlResolveObject(source, relative) {
            if (!source) return relative;
            return urlParse(source, false, true).resolveObject(relative);
          }
          Url.prototype.resolveObject = function(relative) {
            if (util.isString(relative)) {
              var rel = new Url();
              rel.parse(relative, false, true);
              relative = rel;
            }
            var result = new Url();
            var tkeys = Object.keys(this);
            for (var tk = 0; tk < tkeys.length; tk++) {
              var tkey = tkeys[tk];
              result[tkey] = this[tkey];
            }
            result.hash = relative.hash;
            if (relative.href === "") {
              result.href = result.format();
              return result;
            }
            if (relative.slashes && !relative.protocol) {
              var rkeys = Object.keys(relative);
              for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== "protocol")
                  result[rkey] = relative[rkey];
              }
              if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
              }
              result.href = result.format();
              return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
              if (!slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v2 = 0; v2 < keys.length; v2++) {
                  var k2 = keys[v2];
                  result[k2] = relative[k2];
                }
                result.href = result.format();
                return result;
              }
              result.protocol = relative.protocol;
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || "").split("/");
                while (relPath.length && !(relative.host = relPath.shift())) ;
                if (!relative.host) relative.host = "";
                if (!relative.hostname) relative.hostname = "";
                if (relPath[0] !== "") relPath.unshift("");
                if (relPath.length < 2) relPath.unshift("");
                result.pathname = relPath.join("/");
              } else {
                result.pathname = relative.pathname;
              }
              result.search = relative.search;
              result.query = relative.query;
              result.host = relative.host || "";
              result.auth = relative.auth;
              result.hostname = relative.hostname || relative.host;
              result.port = relative.port;
              if (result.pathname || result.search) {
                var p2 = result.pathname || "";
                var s2 = result.search || "";
                result.path = p2 + s2;
              }
              result.slashes = result.slashes || relative.slashes;
              result.href = result.format();
              return result;
            }
            var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
            if (psychotic) {
              result.hostname = "";
              result.port = null;
              if (result.host) {
                if (srcPath[0] === "") srcPath[0] = result.host;
                else srcPath.unshift(result.host);
              }
              result.host = "";
              if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                  if (relPath[0] === "") relPath[0] = relative.host;
                  else relPath.unshift(relative.host);
                }
                relative.host = null;
              }
              mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }
            if (isRelAbs) {
              result.host = relative.host || relative.host === "" ? relative.host : result.host;
              result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
              result.search = relative.search;
              result.query = relative.query;
              srcPath = relPath;
            } else if (relPath.length) {
              if (!srcPath) srcPath = [];
              srcPath.pop();
              srcPath = srcPath.concat(relPath);
              result.search = relative.search;
              result.query = relative.query;
            } else if (!util.isNullOrUndefined(relative.search)) {
              if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                  result.auth = authInHost.shift();
                  result.host = result.hostname = authInHost.shift();
                }
              }
              result.search = relative.search;
              result.query = relative.query;
              if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
              }
              result.href = result.format();
              return result;
            }
            if (!srcPath.length) {
              result.pathname = null;
              if (result.search) {
                result.path = "/" + result.search;
              } else {
                result.path = null;
              }
              result.href = result.format();
              return result;
            }
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
            var up = 0;
            for (var i2 = srcPath.length; i2 >= 0; i2--) {
              last = srcPath[i2];
              if (last === ".") {
                srcPath.splice(i2, 1);
              } else if (last === "..") {
                srcPath.splice(i2, 1);
                up++;
              } else if (up) {
                srcPath.splice(i2, 1);
                up--;
              }
            }
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift("..");
              }
            }
            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
              srcPath.unshift("");
            }
            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
              srcPath.push("");
            }
            var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
            if (psychotic) {
              result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            mustEndAbs = mustEndAbs || result.host && srcPath.length;
            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift("");
            }
            if (!srcPath.length) {
              result.pathname = null;
              result.path = null;
            } else {
              result.pathname = srcPath.join("/");
            }
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          };
          Url.prototype.parseHost = function() {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
              port = port[0];
              if (port !== ":") {
                this.port = port.substr(1);
              }
              host = host.substr(0, host.length - port.length);
            }
            if (host) this.hostname = host;
          };
        }, { "./util": 304, "punycode": 264, "querystring": 267 }], 304: [function(require2, module3, exports3) {
          module3.exports = {
            isString: function(arg) {
              return typeof arg === "string";
            },
            isObject: function(arg) {
              return typeof arg === "object" && arg !== null;
            },
            isNull: function(arg) {
              return arg === null;
            },
            isNullOrUndefined: function(arg) {
              return arg == null;
            }
          };
        }, {}], 305: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              module3.exports = deprecate;
              function deprecate(fn, msg) {
                if (config("noDeprecation")) {
                  return fn;
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (config("throwDeprecation")) {
                      throw new Error(msg);
                    } else if (config("traceDeprecation")) {
                      console.trace(msg);
                    } else {
                      console.warn(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              }
              function config(name) {
                try {
                  if (!global2.localStorage) return false;
                } catch (_2) {
                  return false;
                }
                var val = global2.localStorage[name];
                if (null == val) return false;
                return String(val).toLowerCase() === "true";
              }
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 306: [function(require2, module3, exports3) {
          module3.exports = function isBuffer(arg) {
            return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
          };
        }, {}], 307: [function(require2, module3, exports3) {
          var isArgumentsObject = require2("is-arguments");
          var isGeneratorFunction = require2("is-generator-function");
          var whichTypedArray = require2("which-typed-array");
          var isTypedArray = require2("is-typed-array");
          function uncurryThis(f2) {
            return f2.call.bind(f2);
          }
          var BigIntSupported = typeof BigInt !== "undefined";
          var SymbolSupported = typeof Symbol !== "undefined";
          var ObjectToString = uncurryThis(Object.prototype.toString);
          var numberValue = uncurryThis(Number.prototype.valueOf);
          var stringValue = uncurryThis(String.prototype.valueOf);
          var booleanValue = uncurryThis(Boolean.prototype.valueOf);
          if (BigIntSupported) {
            var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
          }
          if (SymbolSupported) {
            var symbolValue = uncurryThis(Symbol.prototype.valueOf);
          }
          function checkBoxedPrimitive(value, prototypeValueOf) {
            if (typeof value !== "object") {
              return false;
            }
            try {
              prototypeValueOf(value);
              return true;
            } catch (e2) {
              return false;
            }
          }
          exports3.isArgumentsObject = isArgumentsObject;
          exports3.isGeneratorFunction = isGeneratorFunction;
          exports3.isTypedArray = isTypedArray;
          function isPromise(input) {
            return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
          }
          exports3.isPromise = isPromise;
          function isArrayBufferView(value) {
            if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
              return ArrayBuffer.isView(value);
            }
            return isTypedArray(value) || isDataView(value);
          }
          exports3.isArrayBufferView = isArrayBufferView;
          function isUint8Array(value) {
            return whichTypedArray(value) === "Uint8Array";
          }
          exports3.isUint8Array = isUint8Array;
          function isUint8ClampedArray(value) {
            return whichTypedArray(value) === "Uint8ClampedArray";
          }
          exports3.isUint8ClampedArray = isUint8ClampedArray;
          function isUint16Array(value) {
            return whichTypedArray(value) === "Uint16Array";
          }
          exports3.isUint16Array = isUint16Array;
          function isUint32Array(value) {
            return whichTypedArray(value) === "Uint32Array";
          }
          exports3.isUint32Array = isUint32Array;
          function isInt8Array(value) {
            return whichTypedArray(value) === "Int8Array";
          }
          exports3.isInt8Array = isInt8Array;
          function isInt16Array(value) {
            return whichTypedArray(value) === "Int16Array";
          }
          exports3.isInt16Array = isInt16Array;
          function isInt32Array(value) {
            return whichTypedArray(value) === "Int32Array";
          }
          exports3.isInt32Array = isInt32Array;
          function isFloat32Array(value) {
            return whichTypedArray(value) === "Float32Array";
          }
          exports3.isFloat32Array = isFloat32Array;
          function isFloat64Array(value) {
            return whichTypedArray(value) === "Float64Array";
          }
          exports3.isFloat64Array = isFloat64Array;
          function isBigInt64Array(value) {
            return whichTypedArray(value) === "BigInt64Array";
          }
          exports3.isBigInt64Array = isBigInt64Array;
          function isBigUint64Array(value) {
            return whichTypedArray(value) === "BigUint64Array";
          }
          exports3.isBigUint64Array = isBigUint64Array;
          function isMapToString(value) {
            return ObjectToString(value) === "[object Map]";
          }
          isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
          function isMap2(value) {
            if (typeof Map === "undefined") {
              return false;
            }
            return isMapToString.working ? isMapToString(value) : value instanceof Map;
          }
          exports3.isMap = isMap2;
          function isSetToString(value) {
            return ObjectToString(value) === "[object Set]";
          }
          isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
          function isSet2(value) {
            if (typeof Set === "undefined") {
              return false;
            }
            return isSetToString.working ? isSetToString(value) : value instanceof Set;
          }
          exports3.isSet = isSet2;
          function isWeakMapToString(value) {
            return ObjectToString(value) === "[object WeakMap]";
          }
          isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
          function isWeakMap(value) {
            if (typeof WeakMap === "undefined") {
              return false;
            }
            return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
          }
          exports3.isWeakMap = isWeakMap;
          function isWeakSetToString(value) {
            return ObjectToString(value) === "[object WeakSet]";
          }
          isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
          function isWeakSet(value) {
            return isWeakSetToString(value);
          }
          exports3.isWeakSet = isWeakSet;
          function isArrayBufferToString(value) {
            return ObjectToString(value) === "[object ArrayBuffer]";
          }
          isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
          function isArrayBuffer(value) {
            if (typeof ArrayBuffer === "undefined") {
              return false;
            }
            return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
          }
          exports3.isArrayBuffer = isArrayBuffer;
          function isDataViewToString(value) {
            return ObjectToString(value) === "[object DataView]";
          }
          isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
          function isDataView(value) {
            if (typeof DataView === "undefined") {
              return false;
            }
            return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
          }
          exports3.isDataView = isDataView;
          function isSharedArrayBufferToString(value) {
            return ObjectToString(value) === "[object SharedArrayBuffer]";
          }
          isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== "undefined" && isSharedArrayBufferToString(new SharedArrayBuffer());
          function isSharedArrayBuffer(value) {
            if (typeof SharedArrayBuffer === "undefined") {
              return false;
            }
            return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
          }
          exports3.isSharedArrayBuffer = isSharedArrayBuffer;
          function isAsyncFunction(value) {
            return ObjectToString(value) === "[object AsyncFunction]";
          }
          exports3.isAsyncFunction = isAsyncFunction;
          function isMapIterator(value) {
            return ObjectToString(value) === "[object Map Iterator]";
          }
          exports3.isMapIterator = isMapIterator;
          function isSetIterator(value) {
            return ObjectToString(value) === "[object Set Iterator]";
          }
          exports3.isSetIterator = isSetIterator;
          function isGeneratorObject(value) {
            return ObjectToString(value) === "[object Generator]";
          }
          exports3.isGeneratorObject = isGeneratorObject;
          function isWebAssemblyCompiledModule(value) {
            return ObjectToString(value) === "[object WebAssembly.Module]";
          }
          exports3.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
          function isNumberObject(value) {
            return checkBoxedPrimitive(value, numberValue);
          }
          exports3.isNumberObject = isNumberObject;
          function isStringObject(value) {
            return checkBoxedPrimitive(value, stringValue);
          }
          exports3.isStringObject = isStringObject;
          function isBooleanObject(value) {
            return checkBoxedPrimitive(value, booleanValue);
          }
          exports3.isBooleanObject = isBooleanObject;
          function isBigIntObject(value) {
            return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
          }
          exports3.isBigIntObject = isBigIntObject;
          function isSymbolObject(value) {
            return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
          }
          exports3.isSymbolObject = isSymbolObject;
          function isBoxedPrimitive(value) {
            return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
          }
          exports3.isBoxedPrimitive = isBoxedPrimitive;
          function isAnyArrayBuffer(value) {
            return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
          }
          exports3.isAnyArrayBuffer = isAnyArrayBuffer;
          ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
            Object.defineProperty(exports3, method, {
              enumerable: false,
              value: function() {
                throw new Error(method + " is not supported in userland");
              }
            });
          });
        }, { "is-arguments": 196, "is-generator-function": 198, "is-typed-array": 200, "which-typed-array": 309 }], 308: [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
                var keys = Object.keys(obj);
                var descriptors = {};
                for (var i2 = 0; i2 < keys.length; i2++) {
                  descriptors[keys[i2]] = Object.getOwnPropertyDescriptor(obj, keys[i2]);
                }
                return descriptors;
              };
              var formatRegExp = /%[sdj%]/g;
              exports3.format = function(f2) {
                if (!isString(f2)) {
                  var objects = [];
                  for (var i2 = 0; i2 < arguments.length; i2++) {
                    objects.push(inspect(arguments[i2]));
                  }
                  return objects.join(" ");
                }
                var i2 = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f2).replace(formatRegExp, function(x22) {
                  if (x22 === "%%") return "%";
                  if (i2 >= len) return x22;
                  switch (x22) {
                    case "%s":
                      return String(args[i2++]);
                    case "%d":
                      return Number(args[i2++]);
                    case "%j":
                      try {
                        return JSON.stringify(args[i2++]);
                      } catch (_2) {
                        return "[Circular]";
                      }
                    default:
                      return x22;
                  }
                });
                for (var x2 = args[i2]; i2 < len; x2 = args[++i2]) {
                  if (isNull(x2) || !isObject2(x2)) {
                    str += " " + x2;
                  } else {
                    str += " " + inspect(x2);
                  }
                }
                return str;
              };
              exports3.deprecate = function(fn, msg) {
                if (typeof process !== "undefined" && process.noDeprecation === true) {
                  return fn;
                }
                if (typeof process === "undefined") {
                  return function() {
                    return exports3.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              var debugs = {};
              var debugEnvRegex = /^$/;
              if (process.env.NODE_DEBUG) {
                var debugEnv = process.env.NODE_DEBUG;
                debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
                debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
              }
              exports3.debuglog = function(set) {
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (debugEnvRegex.test(set)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                      var msg = exports3.format.apply(exports3, arguments);
                      console.error("%s %d: %s", set, pid, msg);
                    };
                  } else {
                    debugs[set] = function() {
                    };
                  }
                }
                return debugs[set];
              };
              function inspect(obj, opts) {
                var ctx2 = {
                  seen: [],
                  stylize: stylizeNoColor
                };
                if (arguments.length >= 3) ctx2.depth = arguments[2];
                if (arguments.length >= 4) ctx2.colors = arguments[3];
                if (isBoolean(opts)) {
                  ctx2.showHidden = opts;
                } else if (opts) {
                  exports3._extend(ctx2, opts);
                }
                if (isUndefined(ctx2.showHidden)) ctx2.showHidden = false;
                if (isUndefined(ctx2.depth)) ctx2.depth = 2;
                if (isUndefined(ctx2.colors)) ctx2.colors = false;
                if (isUndefined(ctx2.customInspect)) ctx2.customInspect = true;
                if (ctx2.colors) ctx2.stylize = stylizeWithColor;
                return formatValue(ctx2, obj, ctx2.depth);
              }
              exports3.inspect = inspect;
              inspect.colors = {
                "bold": [1, 22],
                "italic": [3, 23],
                "underline": [4, 24],
                "inverse": [7, 27],
                "white": [37, 39],
                "grey": [90, 39],
                "black": [30, 39],
                "blue": [34, 39],
                "cyan": [36, 39],
                "green": [32, 39],
                "magenta": [35, 39],
                "red": [31, 39],
                "yellow": [33, 39]
              };
              inspect.styles = {
                "special": "cyan",
                "number": "yellow",
                "boolean": "yellow",
                "undefined": "grey",
                "null": "bold",
                "string": "green",
                "date": "magenta",
                // "name": intentionally not styling
                "regexp": "red"
              };
              function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                  return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
                } else {
                  return str;
                }
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx2, value, recurseTimes) {
                if (ctx2.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                value.inspect !== exports3.inspect && // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                  var ret = value.inspect(recurseTimes, ctx2);
                  if (!isString(ret)) {
                    ret = formatValue(ctx2, ret, recurseTimes);
                  }
                  return ret;
                }
                var primitive = formatPrimitive(ctx2, value);
                if (primitive) {
                  return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx2.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                  return formatError(value);
                }
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx2.stylize("[Function" + name + "]", "special");
                  }
                  if (isRegExp(value)) {
                    return ctx2.stylize(RegExp.prototype.toString.call(value), "regexp");
                  }
                  if (isDate(value)) {
                    return ctx2.stylize(Date.prototype.toString.call(value), "date");
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                var base = "", array = false, braces = ["{", "}"];
                if (isArray(value)) {
                  array = true;
                  braces = ["[", "]"];
                }
                if (isFunction(value)) {
                  var n2 = value.name ? ": " + value.name : "";
                  base = " [Function" + n2 + "]";
                }
                if (isRegExp(value)) {
                  base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                  base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                  base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx2.stylize(RegExp.prototype.toString.call(value), "regexp");
                  } else {
                    return ctx2.stylize("[Object]", "special");
                  }
                }
                ctx2.seen.push(value);
                var output;
                if (array) {
                  output = formatArray(ctx2, value, recurseTimes, visibleKeys, keys);
                } else {
                  output = keys.map(function(key) {
                    return formatProperty(ctx2, value, recurseTimes, visibleKeys, key, array);
                  });
                }
                ctx2.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx2, value) {
                if (isUndefined(value))
                  return ctx2.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return ctx2.stylize(simple, "string");
                }
                if (isNumber(value))
                  return ctx2.stylize("" + value, "number");
                if (isBoolean(value))
                  return ctx2.stylize("" + value, "boolean");
                if (isNull(value))
                  return ctx2.stylize("null", "null");
              }
              function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
              }
              function formatArray(ctx2, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i2 = 0, l2 = value.length; i2 < l2; ++i2) {
                  if (hasOwnProperty2(value, String(i2))) {
                    output.push(formatProperty(
                      ctx2,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i2),
                      true
                    ));
                  } else {
                    output.push("");
                  }
                }
                keys.forEach(function(key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(
                      ctx2,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    ));
                  }
                });
                return output;
              }
              function formatProperty(ctx2, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx2.stylize("[Getter/Setter]", "special");
                  } else {
                    str = ctx2.stylize("[Getter]", "special");
                  }
                } else {
                  if (desc.set) {
                    str = ctx2.stylize("[Setter]", "special");
                  }
                }
                if (!hasOwnProperty2(visibleKeys, key)) {
                  name = "[" + key + "]";
                }
                if (!str) {
                  if (ctx2.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx2, desc.value, null);
                    } else {
                      str = formatValue(ctx2, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                      if (array) {
                        str = str.split("\n").map(function(line) {
                          return "  " + line;
                        }).join("\n").substr(2);
                      } else {
                        str = "\n" + str.split("\n").map(function(line) {
                          return "   " + line;
                        }).join("\n");
                      }
                    }
                  } else {
                    str = ctx2.stylize("[Circular]", "special");
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify("" + key);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx2.stylize(name, "name");
                  } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx2.stylize(name, "string");
                  }
                }
                return name + ": " + str;
              }
              function reduceToSingleString(output, base, braces) {
                var length = output.reduce(function(prev, cur) {
                  if (cur.indexOf("\n") >= 0) ;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                  return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
              }
              exports3.types = require2("./support/types");
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports3.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports3.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports3.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports3.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports3.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports3.isString = isString;
              function isSymbol(arg) {
                return typeof arg === "symbol";
              }
              exports3.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports3.isUndefined = isUndefined;
              function isRegExp(re2) {
                return isObject2(re2) && objectToString(re2) === "[object RegExp]";
              }
              exports3.isRegExp = isRegExp;
              exports3.types.isRegExp = isRegExp;
              function isObject2(arg) {
                return typeof arg === "object" && arg !== null;
              }
              exports3.isObject = isObject2;
              function isDate(d2) {
                return isObject2(d2) && objectToString(d2) === "[object Date]";
              }
              exports3.isDate = isDate;
              exports3.types.isDate = isDate;
              function isError(e2) {
                return isObject2(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
              }
              exports3.isError = isError;
              exports3.types.isNativeError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports3.isFunction = isFunction;
              function isPrimitive2(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined";
              }
              exports3.isPrimitive = isPrimitive2;
              exports3.isBuffer = require2("./support/isBuffer");
              function objectToString(o2) {
                return Object.prototype.toString.call(o2);
              }
              function pad(n2) {
                return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
              }
              var months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ];
              function timestamp() {
                var d2 = /* @__PURE__ */ new Date();
                var time = [
                  pad(d2.getHours()),
                  pad(d2.getMinutes()),
                  pad(d2.getSeconds())
                ].join(":");
                return [d2.getDate(), months[d2.getMonth()], time].join(" ");
              }
              exports3.log = function() {
                console.log("%s - %s", timestamp(), exports3.format.apply(exports3, arguments));
              };
              exports3.inherits = require2("inherits");
              exports3._extend = function(origin, add) {
                if (!add || !isObject2(add)) return origin;
                var keys = Object.keys(add);
                var i2 = keys.length;
                while (i2--) {
                  origin[keys[i2]] = add[keys[i2]];
                }
                return origin;
              };
              function hasOwnProperty2(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
              var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
              exports3.promisify = function promisify(original) {
                if (typeof original !== "function")
                  throw new TypeError('The "original" argument must be of type Function');
                if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
                  var fn = original[kCustomPromisifiedSymbol];
                  if (typeof fn !== "function") {
                    throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                  }
                  Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                    value: fn,
                    enumerable: false,
                    writable: false,
                    configurable: true
                  });
                  return fn;
                }
                function fn() {
                  var promiseResolve, promiseReject;
                  var promise = new Promise(function(resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                  });
                  var args = [];
                  for (var i2 = 0; i2 < arguments.length; i2++) {
                    args.push(arguments[i2]);
                  }
                  args.push(function(err, value) {
                    if (err) {
                      promiseReject(err);
                    } else {
                      promiseResolve(value);
                    }
                  });
                  try {
                    original.apply(this, args);
                  } catch (err) {
                    promiseReject(err);
                  }
                  return promise;
                }
                Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
                if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
                  value: fn,
                  enumerable: false,
                  writable: false,
                  configurable: true
                });
                return Object.defineProperties(
                  fn,
                  getOwnPropertyDescriptors(original)
                );
              };
              exports3.promisify.custom = kCustomPromisifiedSymbol;
              function callbackifyOnRejected(reason, cb) {
                if (!reason) {
                  var newReason = new Error("Promise was rejected with a falsy value");
                  newReason.reason = reason;
                  reason = newReason;
                }
                return cb(reason);
              }
              function callbackify(original) {
                if (typeof original !== "function") {
                  throw new TypeError('The "original" argument must be of type Function');
                }
                function callbackified() {
                  var args = [];
                  for (var i2 = 0; i2 < arguments.length; i2++) {
                    args.push(arguments[i2]);
                  }
                  var maybeCb = args.pop();
                  if (typeof maybeCb !== "function") {
                    throw new TypeError("The last argument must be of type Function");
                  }
                  var self2 = this;
                  var cb = function() {
                    return maybeCb.apply(self2, arguments);
                  };
                  original.apply(this, args).then(
                    function(ret) {
                      process.nextTick(cb.bind(null, null, ret));
                    },
                    function(rej) {
                      process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
                    }
                  );
                }
                Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
                Object.defineProperties(
                  callbackified,
                  getOwnPropertyDescriptors(original)
                );
                return callbackified;
              }
              exports3.callbackify = callbackify;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./support/isBuffer": 306, "./support/types": 307, "_process": 263, "inherits": 195 }], 309: [function(require2, module3, exports3) {
          (function(global2) {
            (function() {
              var forEach = require2("foreach");
              var availableTypedArrays = require2("available-typed-arrays");
              var callBound = require2("call-bind/callBound");
              var $toString = callBound("Object.prototype.toString");
              var hasSymbols = require2("has-symbols")();
              var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
              var typedArrays = availableTypedArrays();
              var $slice = callBound("String.prototype.slice");
              var toStrTags = {};
              var gOPD = require2("es-abstract/helpers/getOwnPropertyDescriptor");
              var getPrototypeOf = Object.getPrototypeOf;
              if (hasToStringTag && gOPD && getPrototypeOf) {
                forEach(typedArrays, function(typedArray) {
                  if (typeof global2[typedArray] === "function") {
                    var arr = new global2[typedArray]();
                    if (!(Symbol.toStringTag in arr)) {
                      throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
                    }
                    var proto = getPrototypeOf(arr);
                    var descriptor = gOPD(proto, Symbol.toStringTag);
                    if (!descriptor) {
                      var superProto = getPrototypeOf(proto);
                      descriptor = gOPD(superProto, Symbol.toStringTag);
                    }
                    toStrTags[typedArray] = descriptor.get;
                  }
                });
              }
              var tryTypedArrays = function tryAllTypedArrays(value) {
                var foundName = false;
                forEach(toStrTags, function(getter, typedArray) {
                  if (!foundName) {
                    try {
                      var name = getter.call(value);
                      if (name === typedArray) {
                        foundName = name;
                      }
                    } catch (e2) {
                    }
                  }
                });
                return foundName;
              };
              var isTypedArray = require2("is-typed-array");
              module3.exports = function whichTypedArray(value) {
                if (!isTypedArray(value)) {
                  return false;
                }
                if (!hasToStringTag) {
                  return $slice($toString(value), 8, -1);
                }
                return tryTypedArrays(value);
              };
            }).call(this);
          }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "available-typed-arrays": 30, "call-bind/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 116, "foreach": 186, "has-symbols": 190, "is-typed-array": 200 }], 310: [function(require2, module3, exports3) {
          module3.exports = extend;
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          function extend() {
            var target = {};
            for (var i2 = 0; i2 < arguments.length; i2++) {
              var source = arguments[i2];
              for (var key in source) {
                if (hasOwnProperty2.call(source, key)) {
                  target[key] = source[key];
                }
              }
            }
            return target;
          }
        }, {}], "json-schema-to-typescript": [function(require2, module3, exports3) {
          (function(process) {
            (function() {
              var __extends = this && this.__extends || /* @__PURE__ */ function() {
                var extendStatics = function(d2, b2) {
                  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d22, b22) {
                    d22.__proto__ = b22;
                  } || function(d22, b22) {
                    for (var p2 in b22) if (Object.prototype.hasOwnProperty.call(b22, p2)) d22[p2] = b22[p2];
                  };
                  return extendStatics(d2, b2);
                };
                return function(d2, b2) {
                  if (typeof b2 !== "function" && b2 !== null)
                    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
                  extendStatics(d2, b2);
                  function __() {
                    this.constructor = d2;
                  }
                  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
                };
              }();
              var __assign = this && this.__assign || function() {
                __assign = Object.assign || function(t2) {
                  for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
                    s2 = arguments[i2];
                    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2))
                      t2[p2] = s2[p2];
                  }
                  return t2;
                };
                return __assign.apply(this, arguments);
              };
              var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P2, generator) {
                function adopt(value) {
                  return value instanceof P2 ? value : new P2(function(resolve) {
                    resolve(value);
                  });
                }
                return new (P2 || (P2 = Promise))(function(resolve, reject) {
                  function fulfilled(value) {
                    try {
                      step(generator.next(value));
                    } catch (e2) {
                      reject(e2);
                    }
                  }
                  function rejected(value) {
                    try {
                      step(generator["throw"](value));
                    } catch (e2) {
                      reject(e2);
                    }
                  }
                  function step(result) {
                    result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
                  }
                  step((generator = generator.apply(thisArg, _arguments || [])).next());
                });
              };
              var __generator = this && this.__generator || function(thisArg, body) {
                var _2 = { label: 0, sent: function() {
                  if (t2[0] & 1) throw t2[1];
                  return t2[1];
                }, trys: [], ops: [] }, f2, y2, t2, g2;
                return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
                  return this;
                }), g2;
                function verb(n2) {
                  return function(v2) {
                    return step([n2, v2]);
                  };
                }
                function step(op) {
                  if (f2) throw new TypeError("Generator is already executing.");
                  while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
                    if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
                    if (y2 = 0, t2) op = [op[0] & 2, t2.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t2 = op;
                        break;
                      case 4:
                        _2.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _2.label++;
                        y2 = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _2.ops.pop();
                        _2.trys.pop();
                        continue;
                      default:
                        if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                          _2 = 0;
                          continue;
                        }
                        if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                          _2.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _2.label < t2[1]) {
                          _2.label = t2[1];
                          t2 = op;
                          break;
                        }
                        if (t2 && _2.label < t2[2]) {
                          _2.label = t2[2];
                          _2.ops.push(op);
                          break;
                        }
                        if (t2[2]) _2.ops.pop();
                        _2.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _2);
                  } catch (e2) {
                    op = [6, e2];
                    y2 = 0;
                  } finally {
                    f2 = t2 = 0;
                  }
                  if (op[0] & 5) throw op[1];
                  return { value: op[0] ? op[1] : void 0, done: true };
                }
              };
              Object.defineProperty(exports3, "__esModule", { value: true });
              exports3.ValidationError = exports3.compile = exports3.compileFromFile = exports3.DEFAULT_OPTIONS = void 0;
              var fs_1 = require2("fs");
              var lodash_1 = require2("lodash");
              var path_1 = require2("path");
              var formatter_1 = require2("./formatter");
              var generator_1 = require2("./generator");
              var normalizer_1 = require2("./normalizer");
              var optimizer_1 = require2("./optimizer");
              var parser_1 = require2("./parser");
              var resolver_1 = require2("./resolver");
              var utils_1 = require2("./utils");
              var validator_1 = require2("./validator");
              var util_1 = require2("util");
              var linker_1 = require2("./linker");
              var optionValidator_1 = require2("./optionValidator");
              exports3.DEFAULT_OPTIONS = {
                $refOptions: {},
                additionalProperties: true,
                bannerComment: "/* eslint-disable */\n/**\n* This file was automatically generated by json-schema-to-typescript.\n* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,\n* and run json-schema-to-typescript to regenerate this file.\n*/",
                cwd: process.cwd(),
                declareExternallyReferenced: true,
                enableConstEnums: true,
                format: true,
                ignoreMinAndMaxItems: false,
                maxItems: 20,
                strictIndexSignatures: false,
                style: {
                  bracketSpacing: false,
                  printWidth: 120,
                  semi: true,
                  singleQuote: false,
                  tabWidth: 2,
                  trailingComma: "none",
                  useTabs: false
                },
                unreachableDefinitions: false,
                unknownAny: true
              };
              function compileFromFile(filename, options) {
                if (options === void 0) {
                  options = exports3.DEFAULT_OPTIONS;
                }
                var contents = (0, utils_1.Try)(function() {
                  return (0, fs_1.readFileSync)(filename);
                }, function() {
                  throw new ReferenceError('Unable to read file "'.concat(filename, '"'));
                });
                var schema = (0, utils_1.Try)(function() {
                  return JSON.parse(contents.toString());
                }, function() {
                  throw new TypeError('Error parsing JSON in file "'.concat(filename, '"'));
                });
                return compile(schema, (0, utils_1.stripExtension)(filename), __assign({ cwd: (0, path_1.dirname)(filename) }, options));
              }
              exports3.compileFromFile = compileFromFile;
              function compile(schema, name, options) {
                if (options === void 0) {
                  options = {};
                }
                return __awaiter(this, void 0, void 0, function() {
                  function time() {
                    return "(".concat(Date.now() - start, "ms)");
                  }
                  var _options, start, _schema, _a, dereferencedPaths, dereferencedSchema, linked, errors, normalized, parsed, optimized, generated, formatted;
                  return __generator(this, function(_b) {
                    switch (_b.label) {
                      case 0:
                        (0, optionValidator_1.validateOptions)(options);
                        _options = (0, lodash_1.merge)({}, exports3.DEFAULT_OPTIONS, options);
                        start = Date.now();
                        if (!(0, lodash_1.endsWith)(_options.cwd, "/")) {
                          _options.cwd += "/";
                        }
                        _schema = (0, lodash_1.cloneDeep)(schema);
                        return [4, (0, resolver_1.dereference)(_schema, _options)];
                      case 1:
                        _a = _b.sent(), dereferencedPaths = _a.dereferencedPaths, dereferencedSchema = _a.dereferencedSchema;
                        if (process.env.VERBOSE) {
                          if ((0, util_1.isDeepStrictEqual)(_schema, dereferencedSchema)) {
                            (0, utils_1.log)("green", "dereferencer", time(), "✅ No change");
                          } else {
                            (0, utils_1.log)("green", "dereferencer", time(), "✅ Result:", dereferencedSchema);
                          }
                        }
                        linked = (0, linker_1.link)(dereferencedSchema);
                        if (process.env.VERBOSE) {
                          (0, utils_1.log)("green", "linker", time(), "✅ No change");
                        }
                        errors = (0, validator_1.validate)(linked, name);
                        if (errors.length) {
                          errors.forEach(function(_2) {
                            return (0, utils_1.error)(_2);
                          });
                          throw new ValidationError();
                        }
                        if (process.env.VERBOSE) {
                          (0, utils_1.log)("green", "validator", time(), "✅ No change");
                        }
                        normalized = (0, normalizer_1.normalize)(linked, dereferencedPaths, name, _options);
                        (0, utils_1.log)("yellow", "normalizer", time(), "✅ Result:", normalized);
                        parsed = (0, parser_1.parse)(normalized, _options);
                        (0, utils_1.log)("blue", "parser", time(), "✅ Result:", parsed);
                        optimized = (0, optimizer_1.optimize)(parsed, _options);
                        (0, utils_1.log)("cyan", "optimizer", time(), "✅ Result:", optimized);
                        generated = (0, generator_1.generate)(optimized, _options);
                        (0, utils_1.log)("magenta", "generator", time(), "✅ Result:", generated);
                        formatted = (0, formatter_1.format)(generated, _options);
                        (0, utils_1.log)("white", "formatter", time(), "✅ Result:", formatted);
                        return [2, formatted];
                    }
                  });
                });
              }
              exports3.compile = compile;
              var ValidationError = (
                /** @class */
                function(_super) {
                  __extends(ValidationError2, _super);
                  function ValidationError2() {
                    return _super !== null && _super.apply(this, arguments) || this;
                  }
                  return ValidationError2;
                }(Error)
              );
              exports3.ValidationError = ValidationError;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./formatter": 226, "./generator": 227, "./linker": 228, "./normalizer": 229, "./optimizer": 230, "./optionValidator": 231, "./parser": 232, "./resolver": 233, "./utils": 237, "./validator": 238, "_process": 263, "fs": 33, "lodash": 239, "path": 262, "util": 308 }] }, {}, [])("json-schema-to-typescript");
      });
      const jstt = window.jstt;
      const compileOptions = {
        bannerComment: "",
        declareExternallyReferenced: true,
        enablevarEnums: true,
        unreachableDefinitions: false,
        strictIndexSignatures: false,
        format: false,
        unknownAny: false
      };
      function formatJson(objectJson) {
        const cloneObject = JSON.parse(objectJson);
        if (cloneObject.properties) {
          cloneObject.additionalProperties = false;
        }
        function processNestedProperties(obj) {
          var _a;
          for (const key in obj) {
            if ((_a = obj[key]) == null ? void 0 : _a.properties) {
              obj[key].additionalProperties = false;
            }
            if (typeof obj[key] === "object" && obj[key] !== null) {
              processNestedProperties(obj[key]);
            }
          }
        }
        processNestedProperties(cloneObject);
        return cloneObject;
      }
      function getTypeNameFromPath(path) {
        if (!path) {
          return "";
        }
        const words = path.split("/").filter(Boolean);
        if (words.length === 0) {
          return "";
        }
        let typeName = "I";
        for (const word of words) {
          typeName += word.charAt(0).toUpperCase() + word.slice(1);
        }
        return typeName;
      }
      async function convertJsonToTypeScript(json, name) {
        try {
          const formattedJson = formatJson(json);
          const result = await jstt.compile(formattedJson, name, compileOptions);
          return result;
        } catch (error) {
          console.error("📢 convertJsonToTypeScript error:", error);
          return "";
        }
      }
      async function handleData(data) {
        var _a;
        try {
          const name = getTypeNameFromPath(((_a = data.query_path) == null ? void 0 : _a.path) || data.path);
          const query = data.req_query || [];
          const reqBodyOther = data.req_body_other || "{}";
          const params = JSON.parse(reqBodyOther);
          const resBody = JSON.parse(data.res_body || "{}");
          const response = resBody.properties && resBody.properties.data || resBody;
          const [queryType, paramsType, responseType] = await Promise.all([
            convertJsonToTypeScript(JSON.stringify(query), `${name}Query`),
            convertJsonToTypeScript(JSON.stringify(params), `${name}Params`),
            convertJsonToTypeScript(JSON.stringify(response), `${name}Response`)
          ]);
          return {
            queryType,
            paramsType,
            responseType
          };
        } catch (error) {
          console.error("📢 handleData error:", error);
          throw new Error(`生成TypeScript类型失败: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
      const defaults = {
        typeStyle: "interface",
        // 类型定义风格: interface 或 type
        requestLib: "axios",
        // 请求库: axios, fetch 或 custom
        enableComments: true,
        // 是否添加注释
        includeExamples: true,
        // 是否包含示例代码
        useOptionalProps: true,
        // 是否对可选属性使用 ? 标记
        useEnums: true
        // 是否使用类型字面量+as const代替enum
      };
      function get(key) {
        try {
          return _GM_getValue(key, defaults[key]);
        } catch (e2) {
          const value = localStorage.getItem(`yapi_helper_${key}`);
          return value !== null ? JSON.parse(value) : defaults[key];
        }
      }
      function save(key, value) {
        try {
          _GM_setValue(key, value);
        } catch (e2) {
          localStorage.setItem(`yapi_helper_${key}`, JSON.stringify(value));
        }
        showNotification(`已保存偏好: ${key}`);
      }
      function getAll() {
        const prefs = {};
        for (const key in defaults) {
          prefs[key] = get(key);
        }
        return prefs;
      }
      function resetAll() {
        for (const key in defaults) {
          try {
            _GM_setValue(key, defaults[key]);
          } catch (e2) {
            localStorage.setItem(
              `yapi_helper_${key}`,
              JSON.stringify(defaults[key])
            );
          }
        }
        showNotification("已重置所有偏好为默认值");
      }
      const UserPreferences = {
        defaults,
        get,
        save,
        getAll,
        resetAll
      };
      const useUserPreferencesStore = A("UserPreferencesStore", {
        // 状态定义
        state: () => ({
          ...UserPreferences.defaults,
          ...UserPreferences.getAll()
        }),
        // 操作方法
        actions: {
          /**
           * 设置单个偏好设置
           */
          setPreference(key, value) {
            this[key] = value;
            UserPreferences.save(key, value);
          },
          /**
           * 获取所有偏好设置
           */
          getAllPreferences() {
            return { ...this.$state };
          },
          /**
           * 重置所有偏好为默认值
           */
          resetAllPreferences() {
            const defaults2 = UserPreferences.defaults;
            for (const key in defaults2) {
              const typedKey = key;
              this[typedKey] = defaults2[typedKey];
            }
            UserPreferences.resetAll();
            showNotification("已重置所有偏好为默认值");
          },
          /**
           * 从 UserPreferences 重新加载所有偏好
           */
          reloadPreferences() {
            const prefs = UserPreferences.getAll();
            for (const key in prefs) {
              const typedKey = key;
              this[typedKey] = prefs[typedKey];
            }
          }
        }
      });
      function generateAgentInstruction(data) {
        let prefs;
        try {
          const prefsStore = useUserPreferencesStore.useStore();
          prefs = prefsStore.getAllPreferences();
        } catch (e2) {
          prefs = UserPreferences.getAll();
        }
        const apiData = data.data;
        const method = apiData.method.toUpperCase();
        const path = apiData.query_path.path;
        const title = apiData.title;
        const domain = window.location.href;
        let reqBody = "无请求体";
        if (apiData.req_body_other) {
          try {
            const reqJson = JSON.parse(apiData.req_body_other);
            reqBody = JSON.stringify(reqJson, null, 2);
          } catch (e2) {
            reqBody = apiData.req_body_other;
          }
        }
        let resBody = "无响应数据";
        if (apiData.res_body) {
          try {
            const resJson = JSON.parse(apiData.res_body);
            resBody = JSON.stringify(resJson, null, 2);
          } catch (e2) {
            resBody = apiData.res_body;
          }
        }
        return generateInstructionText(
          title,
          path,
          method,
          domain,
          reqBody,
          resBody,
          prefs
        );
      }
      function generateInstructionText(title, path, method, domain, reqBody, resBody, prefs) {
        return `我需要你帮我将以下 YApi 接口转换为 TypeScript 代码：

## 接口基本信息
- 接口名称: ${title}
- 请求路径: ${path}
- 请求方法: ${method}
- 接口域名: ${domain}

## 请求数据
\`\`\`json
${reqBody}
\`\`\`

## 响应数据
\`\`\`json
${resBody}
\`\`\`

## 代码生成严格要求
1. 使用 ${prefs.typeStyle} 定义所有类型
2. 仅使用 export 导出顶层接口/类型（请求参数和响应数据的主要类型）
3. 所有嵌套/内部类型必须定义为内部类型，不要导出它们
4. 使用 ${prefs.requestLib} 作为请求库
5. ${prefs.enableComments ? "添加详细的注释" : "尽量减少注释"}
6. ${prefs.useOptionalProps ? "对可选属性使用 ? 标记" : "不使用 ? 标记可选属性"}
7. ${prefs.includeExamples ? "提供使用示例代码，并使用 try-catch 包裹示例代码以处理可能的异常，不要注释示例代码" : "不需要提供使用示例"}
${prefs.useEnums ? `8. 对于有固定值集合的字段（如状态码、类型标识等），不要使用enum，应该使用类型字面量+as const方案，例如：
\`\`\`typescript
// 类型字面量+as const方案
const METHOD = {
  ADD: 'add',
  /**
   * @deprecated 不再支持删除
   */  
  DELETE: 'delete', // 可以添加丰富的JSDoc注释
  UPDATE: 'update',
  QUERY: 'query'
} as const
type METHOD_TYPE = typeof METHOD[keyof typeof METHOD]
\`\`\`
这种方案支持添加JSDoc注释，代码可读性更好，并且值可以在运行时使用。` : ""}

请确保代码符合 TypeScript 最佳实践，保持类型安全和代码清晰度。`;
      }
      const useYapiStore = A("YapiStore", {
        // 状态定义
        state: () => ({
          apiData: null,
          apiId: null,
          instruction: "",
          typescriptResult: null,
          isModalVisible: false,
          activeTab: "instruction",
          isLoading: false,
          error: null
        }),
        // 计算属性
        getters: {
          // 是否有可用的API数据
          hasApiData() {
            return this.apiData !== null;
          },
          // 合并后的TypeScript类型
          mergedTypeScript() {
            if (!this.typescriptResult) return "";
            const { queryType, paramsType, responseType } = this.typescriptResult;
            return [
              "// 请求参数类型",
              [queryType, paramsType].join("\n"),
              "",
              "// 响应数据类型",
              responseType
            ].join("\n\n");
          }
        },
        // 操作方法
        actions: {
          /**
           * 从当前URL获取API ID
           */
          extractApiIdFromUrl() {
            this.apiId = window.location.pathname.split("/").pop() || null;
            return this.apiId;
          },
          /**
           * 重置状态
           */
          resetState() {
            this.apiData = null;
            this.instruction = "";
            this.typescriptResult = null;
            this.error = null;
          },
          /**
           * 设置当前激活的标签页
           */
          setActiveTab(tab) {
            this.activeTab = tab;
          },
          /**
           * 显示/隐藏模态框
           */
          setModalVisibility(isVisible) {
            this.isModalVisible = isVisible;
          },
          /**
           * 获取API数据
           */
          async fetchApiData() {
            try {
              this.isLoading = true;
              this.error = null;
              const apiId = this.apiId || this.extractApiIdFromUrl();
              if (!apiId) {
                throw new Error("无法获取接口ID");
              }
              const response = await fetch(`/api/interface/get?id=${apiId}`);
              const data = await response.json();
              this.apiData = data.data;
              return data;
            } catch (error) {
              this.error = error.message || "获取API数据失败";
              throw error;
            } finally {
              this.isLoading = false;
            }
          },
          /**
           * 生成Agent指令
           */
          async generateInstruction() {
            try {
              if (!this.apiData) {
                await this.fetchApiData();
              }
              if (this.apiData) {
                this.instruction = generateAgentInstruction({ data: this.apiData });
                this.setActiveTab("instruction");
                this.setModalVisibility(true);
              }
              return this.instruction;
            } catch (error) {
              this.error = error.message || "生成指令失败";
              throw error;
            }
          },
          /**
           * 生成TypeScript类型
           */
          async generateTypeScript() {
            try {
              if (!this.apiData) {
                await this.fetchApiData();
              }
              if (this.apiData) {
                this.typescriptResult = await handleData(this.apiData);
                this.setActiveTab("typescript");
              }
              return this.typescriptResult;
            } catch (error) {
              this.error = error.message || "生成TypeScript失败";
              throw error;
            }
          },
          /**
           * 复制内容到剪贴板
           */
          copyToClipboard(content, message = "内容已复制到剪贴板！") {
            try {
              navigator.clipboard.writeText(content);
              showNotification(message);
              sendSystemNotification("YApi to TypeScript", message);
              return true;
            } catch (error) {
              this.error = error.message || "复制失败";
              return false;
            }
          },
          /**
           * 复制指令到剪贴板
           */
          copyInstruction() {
            if (this.instruction) {
              const success = this.copyToClipboard(
                this.instruction,
                "指令已复制到剪贴板！请切换到 Cursor 编辑器并粘贴。"
              );
              if (success) {
                this.setModalVisibility(false);
              }
            }
          },
          /**
           * 复制TypeScript类型到剪贴板
           */
          copyTypeScript() {
            if (this.typescriptResult) {
              this.copyToClipboard(
                this.mergedTypeScript,
                "TypeScript类型已复制到剪贴板！"
              );
            }
          }
        }
      });
      function useClipboard(defaultOptions = {}) {
        const [error, setError] = require$$0__default.useState(null);
        const [isCopied, setIsCopied] = require$$0__default.useState(false);
        const copyToClipboard = require$$0__default.useCallback(async (text, options = {}) => {
          const {
            successMessage = "内容已复制到剪贴板！",
            notificationTitle = "YApi to TypeScript",
            sendSystemNotify = true,
            onSuccess,
            onError
          } = { ...defaultOptions, ...options };
          try {
            await navigator.clipboard.writeText(text);
            showNotification(successMessage);
            if (sendSystemNotify) {
              sendSystemNotification(notificationTitle, successMessage);
            }
            setIsCopied(true);
            setError(null);
            onSuccess == null ? void 0 : onSuccess();
            setTimeout(() => setIsCopied(false), 2e3);
            return true;
          } catch (err) {
            const error2 = err instanceof Error ? err : new Error("复制失败");
            setError(error2);
            setIsCopied(false);
            onError == null ? void 0 : onError(error2);
            return false;
          }
        }, [defaultOptions]);
        return {
          copyToClipboard,
          isCopied,
          error,
          reset: () => {
            setIsCopied(false);
            setError(null);
          }
        };
      }
      const YapiModal = ({ onClose, onCopy }) => {
        const store = useYapiStore.useStore();
        const prefsStore = useUserPreferencesStore.useStore();
        const { copyToClipboard } = useClipboard();
        require$$0__default.useEffect(() => {
          if (store.activeTab === "typescript" && !store.typescriptResult) {
            handleGenerateTs();
          }
        }, [store.activeTab]);
        const handleGenerateTs = async () => {
          try {
            await store.generateTypeScript();
          } catch (error) {
            console.error("生成TypeScript失败:", error);
          }
        };
        const handleCopyTs = () => {
          if (store.mergedTypeScript) {
            copyToClipboard(store.mergedTypeScript, {
              successMessage: "TypeScript类型已复制到剪贴板！"
            });
          }
        };
        const RadioOption = ({
          name,
          value,
          label,
          checked
        }) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-checkbox-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "radio",
                name,
                value,
                checked,
                id: `${name}-${value}`,
                onChange: () => {
                  prefsStore.setPreference(name, value);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `${name}-${value}`, children: label })
          ] });
        };
        const CheckboxOption = ({
          name,
          label,
          checked
        }) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-checkbox-item", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "checkbox",
                name,
                checked,
                id: `checkbox-${name}`,
                onChange: (e2) => {
                  prefsStore.setPreference(name, e2.target.checked);
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: `checkbox-${name}`, children: label })
          ] });
        };
        const handleReset = async () => {
          prefsStore.resetAllPreferences();
          if (store.apiData) {
            const freshInstruction = generateAgentInstruction({ data: store.apiData });
            store.instruction = freshInstruction;
            store.setActiveTab(store.activeTab);
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-modal", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-tabs", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `yapi-helper-tab ${store.activeTab === "instruction" ? "active" : ""}`,
                onClick: () => store.setActiveTab("instruction"),
                children: "Cursor 指令"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `yapi-helper-tab ${store.activeTab === "typescript" ? "active" : ""}`,
                onClick: () => {
                  handleGenerateTs();
                  store.setActiveTab("typescript");
                },
                children: "TypeScript"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                className: `yapi-helper-tab ${store.activeTab === "preferences" ? "active" : ""}`,
                onClick: () => store.setActiveTab("preferences"),
                children: "偏好设置"
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            store.activeTab === "instruction" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "yapi-helper-instruction-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "pre",
              {
                style: {
                  whiteSpace: "pre-wrap",
                  background: "#f6f8fa",
                  padding: "16px",
                  borderRadius: "4px",
                  overflowX: "auto",
                  fontSize: "14px",
                  fontFamily: "SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace",
                  maxHeight: "400px",
                  overflowY: "auto"
                },
                children: store.instruction
              }
            ) }),
            store.activeTab === "typescript" && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "yapi-helper-instruction-content", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "pre",
              {
                style: {
                  whiteSpace: "pre-wrap",
                  background: "#f6f8fa",
                  padding: "16px",
                  borderRadius: "4px",
                  overflowX: "auto",
                  fontSize: "14px",
                  fontFamily: "SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace",
                  maxHeight: "400px",
                  overflowY: "auto"
                },
                children: store.typescriptResult ? store.mergedTypeScript : "// 正在生成TypeScript接口..."
              }
            ) }),
            store.activeTab === "preferences" && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "yapi-helper-section-title", children: "类型定义风格" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-checkbox-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioOption,
                    {
                      name: "typeStyle",
                      value: "interface",
                      label: "Interface",
                      checked: prefsStore.typeStyle === "interface"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioOption,
                    {
                      name: "typeStyle",
                      value: "type",
                      label: "Type",
                      checked: prefsStore.typeStyle === "type"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "yapi-helper-section-title", children: "请求库" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-checkbox-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioOption,
                    {
                      name: "requestLib",
                      value: "axios",
                      label: "Axios",
                      checked: prefsStore.requestLib === "axios"
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    RadioOption,
                    {
                      name: "requestLib",
                      value: "fetch",
                      label: "Fetch API",
                      checked: prefsStore.requestLib === "fetch"
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-section", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "yapi-helper-section-title", children: "其他选项" }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-checkbox-group", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CheckboxOption,
                    {
                      name: "enableComments",
                      label: "添加详细注释",
                      checked: prefsStore.enableComments
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CheckboxOption,
                    {
                      name: "includeExamples",
                      label: "包含使用示例",
                      checked: prefsStore.includeExamples
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CheckboxOption,
                    {
                      name: "useOptionalProps",
                      label: "使用可选属性标记 (?)",
                      checked: prefsStore.useOptionalProps
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CheckboxOption,
                    {
                      name: "useEnums",
                      label: "使用类型字面量+as const代替enum",
                      checked: prefsStore.useEnums
                    }
                  )
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "yapi-helper-button secondary", onClick: handleReset, children: "重置为默认值" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "yapi-helper-button-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "yapi-helper-button secondary", onClick: onClose, children: "关闭" }),
            store.activeTab === "instruction" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "yapi-helper-button primary", onClick: onCopy, children: "复制Cursor指令" }),
            store.activeTab === "typescript" && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: "yapi-helper-button primary", onClick: handleCopyTs, children: "复制TypeScript" })
          ] })
        ] });
      };
      const YapiButton = () => {
        const store = useYapiStore.useStore();
        const loading = useYapiStore.useLoading();
        const { copyToClipboard } = useClipboard();
        const handleClick = async () => {
          try {
            await store.generateInstruction();
          } catch (error) {
            console.error("YApi Helper: 生成指令失败:", error);
          }
        };
        const handleCopy = () => {
          copyToClipboard(store.instruction, {
            successMessage: "指令已复制到剪贴板！请切换到 Cursor 编辑器并粘贴。",
            notificationTitle: "YApi to TypeScript",
            onSuccess: () => store.setModalVisibility(false)
          });
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: "yapi-helper-btn",
              onClick: handleClick,
              "data-yapi-helper": "true",
              disabled: loading.fetchApiData.loading || loading.generateInstruction.loading,
              children: loading.fetchApiData.loading || loading.generateInstruction.loading ? "加载中..." : "生成 TypeScript 代码"
            }
          ),
          store.isModalVisible && store.apiData && /* @__PURE__ */ jsxRuntimeExports.jsx(
            YapiModal,
            {
              onClose: () => store.setModalVisibility(false),
              onCopy: handleCopy
            }
          )
        ] });
      };
      const JsonToTsButton = () => {
        const store = useYapiStore.useStore();
        const loading = useYapiStore.useLoading();
        const { copyToClipboard } = useClipboard();
        const handleClick = async () => {
          try {
            if (store.typescriptResult) {
              handleCopy();
              return;
            }
            await store.generateTypeScript();
            handleCopy();
          } catch (error) {
            console.error("JSON转TypeScript失败:", error);
          }
        };
        const handleCopy = () => {
          if (store.mergedTypeScript) {
            copyToClipboard(store.mergedTypeScript, {
              successMessage: "TypeScript类型已复制到剪贴板！",
              notificationTitle: "YApi to TypeScript"
            });
          }
        };
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: "yapi-helper-btn json-to-ts-btn",
            onClick: handleClick,
            "data-yapi-helper": "true",
            disabled: loading.fetchApiData.loading || loading.generateTypeScript.loading,
            children: loading.fetchApiData.loading || loading.generateTypeScript.loading ? "转换中..." : "转换为TypeScript"
          }
        ) });
      };
      const App = () => {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(YapiButton, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(JsonToTsButton, {})
        ] });
      };
      ReactDOM.createRoot(
        (() => {
          const app = document.createElement("div");
          document.body.append(app);
          return app;
        })()
      ).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(require$$0__default.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
      );
    }
  });
  require_main_001();

})(React, ReactDOM);